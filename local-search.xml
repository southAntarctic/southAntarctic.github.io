<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Qt中使用OpenGL（五）</title>
    <link href="/2022/04/18/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2022/04/18/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><div class="note note-warning">            <p>难度：中等</p>          </div><div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p>示例</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt中使用OpenGL（四）</title>
    <link href="/2022/04/14/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2022/04/14/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="如何画一个骰子"><a href="#如何画一个骰子" class="headerlink" title="如何画一个骰子"></a>如何画一个骰子</h2><h3 id="整理顶点"><a href="#整理顶点" class="headerlink" title="整理顶点"></a>整理顶点</h3><p>一个骰子是有六个正方形组成。</p><p>根据骰子纹理资源，不再使用（0，0）为左下角和（1，1）为右上角，而是使用和图片相同的左上角为（0，0），右下角为（1，1）。（因为需要人工处理这些坐标映射，所以使用和图片相同的坐标系统比较节省脑子）</p><p>骰子每个面的安排如下：1在前面，6在后面，2在右侧，5在左侧，3在上面，4在下面</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 顶点缓存中前三个是 顶点坐标， 后两个是 纹理坐标， 一个顶点由 5 个 float 组成</span><br><span class="hljs-keyword">float</span> _vertex[] = &#123;<br>  <span class="hljs-comment">// 1</span><br>  <span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.50</span>,<span class="hljs-number">0.25</span>,<span class="hljs-comment">// 左上</span><br>  <span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.50</span>,<span class="hljs-number">0.50</span>,<span class="hljs-comment">// 左下</span><br>  <span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.75</span>,<span class="hljs-number">0.50</span>,<span class="hljs-comment">// 右下</span><br>  <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.75</span>,<span class="hljs-number">0.25</span>,<span class="hljs-comment">// 右上</span><br>  <br>  <span class="hljs-comment">/// 6</span><br> <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">0.00</span>, <span class="hljs-number">0.25</span>,<span class="hljs-comment">// 左上</span><br> <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">0.00</span>, <span class="hljs-number">0.50</span>,<span class="hljs-comment">// 左下</span><br><span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">0.25</span>, <span class="hljs-number">0.50</span>,<span class="hljs-comment">// 右下</span><br><span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>,<span class="hljs-comment">// 右上</span><br><span class="hljs-comment">// 2</span><br> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,<span class="hljs-number">0.75</span>, <span class="hljs-number">0.25</span>,  <span class="hljs-comment">// 左上</span><br> <span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>,<span class="hljs-number">0.75</span>, <span class="hljs-number">0.50</span>,<span class="hljs-comment">// 左下</span><br> <span class="hljs-number">1</span>,<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">1.00</span>, <span class="hljs-number">0.50</span>,<span class="hljs-comment">// 右下</span><br> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">1.00</span>, <span class="hljs-number">0.25</span>,<span class="hljs-comment">// 右上</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>,<span class="hljs-comment">// 左上</span><br><span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">0.25</span>, <span class="hljs-number">0.50</span>,<span class="hljs-comment">// 左下</span><br><span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>,<span class="hljs-number">0.50</span>, <span class="hljs-number">0.50</span>,<span class="hljs-comment">// 右下</span><br><span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,<span class="hljs-number">0.50</span>, <span class="hljs-number">0.25</span>,<span class="hljs-comment">// 右上</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">0.00</span>, <span class="hljs-number">0.00</span>,<span class="hljs-comment">// 左上</span><br><span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,<span class="hljs-number">0.00</span>, <span class="hljs-number">0.25</span>,<span class="hljs-comment">// 左下</span><br> <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>,  <span class="hljs-comment">// 右下</span><br> <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">0.25</span>, <span class="hljs-number">0.00</span>,<span class="hljs-comment">// 右上</span><br><span class="hljs-comment">// 4</span><br><span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>,<span class="hljs-number">0.00</span>, <span class="hljs-number">0.50</span>,  <span class="hljs-comment">// 左上</span><br><span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">0.00</span>, <span class="hljs-number">0.75</span>,<span class="hljs-comment">// 左下</span><br> <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,<span class="hljs-number">0.25</span>, <span class="hljs-number">0.75</span>,<span class="hljs-comment">// 右下</span><br> <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>,<span class="hljs-number">0.25</span>, <span class="hljs-number">0.50</span>,<span class="hljs-comment">// 右上</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="绘制六个矩形"><a href="#绘制六个矩形" class="headerlink" title="绘制六个矩形"></a>绘制六个矩形</h3><p>每次按照两个三角形的方法来绘制六个矩形，循环六次，每次 4 个点。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 绘制</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">6</span>; ++i)<br>&#123;<br>  <span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLE_FAN, i*<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="加载纹理"><a href="#加载纹理" class="headerlink" title="加载纹理"></a>加载纹理</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_texture = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QOpenGLTexture</span>(<span class="hljs-built_in">QImage</span>(<span class="hljs-string">&quot;path/to/image.png&quot;</span>));<br></code></pre></div></td></tr></table></figure><p>因为在设计纹理坐标时，和图片坐标保持了一致，所以此时不同镜像。</p><h3 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h3><p>因为模型是三维的，而显示器只能显示一张图片，所以可以通过一系列的数学计算，将三维空间的一个物体，映射到一个二维平面，当我们观察这个二维平面时，可以有一种我们是在三维空间的某一个位置观察它的错觉。</p><p>实际在用的时候，只需要定义三个矩阵，然后让顶点依此乘以矩阵就可以了。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#version 450 core</span><br>in vec3 vPos;<br>in vec2 vTexture;<br>out vec2 oTexture;<br>uniform mat4 projection;<br>uniform mat4 view;<br>uniform mat4 model;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  gl_Position = projection * view * model * vec4(vPos, <span class="hljs-number">1.0</span>);<br>  oTexture = vTexture;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里定义了三个 uniform 变量，分别叫做 投影矩阵，视图矩阵和模型矩阵。</p><ul><li>投影矩阵负责让你看到的画面符合近大远小的透视规律，并且保证无论窗口的宽高比是多少，看到的画面都不会变形</li><li>视图矩阵负责模拟一个摄像机的镜头，让你可以在三维空间的某一个位置去观察另一个位置</li><li>模型矩阵负责让你绘制模型的时候，可以对它进行缩放、平移、旋转的操作</li></ul><p>在 Qt 中，这些矩阵可以通过 <code>QMatrix4x4</code> 类进行表示</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">QMatrix4x4 m_projection;<br>QMatrix4x4 m_view;<br>QMatrix4x4 m_model;<br></code></pre></div></td></tr></table></figure><h3 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OpenGLWdiget::resizeGL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h)</span></span><br><span class="hljs-function"></span>&#123;<br>  m_projection.<span class="hljs-built_in">setToIdentity</span>();<br>  m_projection.<span class="hljs-built_in">perspective</span>(<span class="hljs-number">60</span>, (<span class="hljs-keyword">float</span>) w / h, <span class="hljs-number">0.001</span>, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>setToIdentity()</code> 函数保证接下来的所有矩阵运算都会在一个单位矩阵上进行。</p><p><code>perspective()</code> 函数就可以构建出一个基于窗口大小的近大远小的投影矩阵了：</p><ul><li>第一个参数表示用什么样的视角来进行投影。可以理解为看到的画面的视野有多大。人眼在头部不动的情况下，视野大概是 60 度。（这里的角度是指纵向视野的角度，不对横向视野进行限制，窗口越宽，看到的内容就会越多，但是靠近边缘的部分变形也会越严重）</li><li>第二个参数是窗口的横纵比。</li><li>第三、四个参数是离摄像机多近到多远范围内的物体要被显示。超出这个范围顶点物体将无法显示。</li></ul><h3 id="视图矩阵"><a href="#视图矩阵" class="headerlink" title="视图矩阵"></a>视图矩阵</h3><p>视图矩阵用于模拟摄像机，所以可以用 <code>QMatrix4x4</code> 类的 <code>lookAt</code> 函数来设置视角。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_view.<span class="hljs-built_in">setToIdentity</span>();<br>m_view.<span class="hljs-built_in">lookAt</span>(<span class="hljs-built_in">QVector3D</span>(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), <span class="hljs-built_in">QVector3D</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>). <span class="hljs-built_in">QVector3D</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br></code></pre></div></td></tr></table></figure><p><code>lookAt</code> 函数：</p><ul><li>第一个参数表示你的眼睛在哪里</li><li>第二个参数表示你的眼睛看向了哪里</li><li>第三个参数表示你的头顶朝向是哪里</li></ul><h3 id="模型矩阵"><a href="#模型矩阵" class="headerlink" title="模型矩阵"></a>模型矩阵</h3><p>模型矩阵用于让绘制的模型可以缩放、旋转和平移。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_model.<span class="hljs-built_in">setToIdentity</span>();<br>model.<span class="hljs-built_in">rotate</span>(m_angle, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><p><code>rotate</code> 函数表示绕某个轴进行一定角度的旋转，这里的角度是指具体的角度，如果每次都首先调用 <code>setToIdentity</code> 清零，则旋转的角度不会累加。</p><p>如果希望模型可以一直转下去，可以设置一个定时器，以 60 帧/秒的频率修改 <code>m_angle</code> 的值，每帧 +1，到了 360 度就归零。</p><p>Qt 中自带定时器，可以在构造函数中开启一个定时器</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">OpenGLWidget::<span class="hljs-built_in">OpenGLWidget</span>(QWidget *parent) : <span class="hljs-built_in">QOpenGLWidget</span>(parent)<br>&#123;<br>  <span class="hljs-built_in">startTimer</span>(<span class="hljs-number">1000</span> / <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后在定时器事件中修改旋转角度和矩阵</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OpenGLWdiget::tinerEvent</span><span class="hljs-params">(QTimerEvent * event)</span></span><br><span class="hljs-function"></span>&#123;<br>  m_angle+=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(m_angle &gt;= <span class="hljs-number">360</span>)&#123;<br>    m_angle = <span class="hljs-number">0</span>;<br>  &#125;<br>  m_model.<span class="hljs-built_in">setToIdentity</span>();<br>  m_model.<span class="hljs-built_in">rotate</span>(m_angle, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">repaint</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后调用 <code>repaint()</code> 函数告诉 OpenGL 重新绘制</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt中使用OpenGL（三）</title>
    <link href="/2022/04/14/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2022/04/14/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>简单理解，纹理就是将 “一层皮” 套在了三维世界中的物体身上，物体身上的每个顶点都对应到了这层皮上的一个位置。</p><p>以下通过简单的例子解释纹理，展示一张风景画。</p><h2 id="绘制矩形与设定纹理映射坐标"><a href="#绘制矩形与设定纹理映射坐标" class="headerlink" title="绘制矩形与设定纹理映射坐标"></a>绘制矩形与设定纹理映射坐标</h2><p>首先要绘制一个矩形。OpenGL 提供了多种绘制多个三角形的方法，其中有一个方法，使得我们只需要 逆时针 定义 4 个顶点，就可以绘制出可以组成矩形的两个三角形。</p><p>在屏幕坐标中，左上是 <code>(-1, 1)</code>，左下是 <code>(-1, -1)</code>，右下是 <code>(1, -1)</code>，右上是 <code>(1, 1)</code>。按照这个顺序就可以定义四个顶点了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">float</span> _vertex[] = &#123;<br>  <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-comment">// 左上</span><br>  <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-comment">// 左下</span><br>  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-comment">// 右下</span><br>  <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> <span class="hljs-comment">//右上</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>至此，画两个三角形的准备工作就完成了。然后需要纹理映射坐标，就是将每一个顶点，都对应到纹理上的一个位置。</p><p>简单来讲就是用（x，y）这个二维坐标来表示纹理上的一个位置，其中，x 与 y 的值域是 <code>[0, 1]。</code></p><p>其中 <code>[0, 0]</code>表示左下角 ，<code>[1, 1]</code>表示右上角。了解了这些，就可以给顶点附加纹理坐标了，方法很简单，只需要在每个顶点坐标后面，附加两个代表纹理坐标的 float 值就行。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 顶点缓存中前三个是顶点坐标，后两个是纹理坐标</span><br><span class="hljs-keyword">float</span> _vertex[] = &#123;<br>  <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-comment">// 左上</span><br>  <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-comment">// 左下</span><br>  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,  <span class="hljs-comment">// 右下</span><br>  <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-comment">//右上</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>此时，每个顶点就有 5 个 float 值了。</p><h2 id="使用包含纹理的顶点缓存"><a href="#使用包含纹理的顶点缓存" class="headerlink" title="使用包含纹理的顶点缓存"></a>使用包含纹理的顶点缓存</h2><p>很显然，之前使用了 <code>setAttributeBuffer()</code> 这个函数告诉了 OpenGL 每个顶点有 3 个值，现在同样需要使用 <code>setAttributeBuffer()</code> 这个函数告诉 OpenGL，现在每个顶点有 5 个值，其中前三个是顶点坐标，后两个是纹理坐标。</p><p>所以，首先要修改shader。</p><h3 id="修改-shader"><a href="#修改-shader" class="headerlink" title="修改 shader"></a>修改 shader</h3><p>之前的 shader 里面，定义了 1 个 vec3 类型的输入，所以要再加一个 vec2 类型的输入</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#version 450 core</span><br>in vec3 vPos;<br>in vec2 vTexture;<br>out vec2 oTexture;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  gl_Position = vec4(vPos, <span class="hljs-number">1.0</span>);<br>  oTexture = vTexture;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 Vertex shader 中，在获取坐标的同时也要获取纹理坐标，然后将纹理坐标发送给其他shader。</p><p>这里添加了一个输入变量 vTexture，还定义了一个输出变量 oTexture，因为 shader 是一种链式调用的代码，Vertex shader 会自动从顶点缓存中获取数据，可是 Fargment shader 不会，所以需要从顶点缓存中获取数据，然后将获取到的数据传给 Fragment shader。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta"># version 450 core</span><br>in vec2 oTexture;<br>uniform sampler2D uTexture;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  gl_FragColor = texture(uTexture, oTexture);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 Fragment shader 中，要定义一个名字和 Vertex shader 中定义输出变量名字一致的输入变量 oTexture，Vertex shader 中的输出变量就会自动的传递到 Fragment shader 中的输入变量中。然后使用 OpenGL 内置的函数 texture() 来进行纹理映射了。</p><p>这里除了 in 和 out 之外还有另一个指示器 uniform，它和 in 一样，也表示一种输入，但是，和 in 不一样的是，它的来源可以是任何地方。而 in 的来源只能是顶点缓存或者其他 shader 的输出。可以在不修改顶点缓存的情况下，在任何合理地方输入 uniform 的值。例如可以根据需要，动态的改变纹理。sampler2D 这个类型表示二维纹理。</p><p>然后告诉 OpenGL 如何使用顶点缓存。</p><h3 id="绑定坐标信息"><a href="#绑定坐标信息" class="headerlink" title="绑定坐标信息"></a>绑定坐标信息</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 绑定顶点坐标，从 0 * sizeof(flaot) 字节开始读取 3 个 float，</span><br><span class="hljs-comment">// 因为每个顶点有 5 个 float 数据，所以下一个数据需要偏移 5 * sizeof(float) 字节</span><br>m_program-&gt;<span class="hljs-built_in">setAttributeBuffer</span>(<span class="hljs-string">&quot;vPos&quot;</span>, GL_FLOAT, <span class="hljs-number">0</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>), <span class="hljs-number">3</span>, <span class="hljs-number">5</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>));<br>m_program-&gt;<span class="hljs-built_in">enableAttributeArray</span>(<span class="hljs-string">&quot;vPos&quot;</span>);<br><span class="hljs-comment">// 绑定纹理坐标，从 3 * sizeof(float) 字节开始读取 2 个 float，</span><br><span class="hljs-comment">// 因为每个顶点有 5 个 float 数据，所以下一个数据需要偏移 5 * sizeof(float) 字节</span><br>m_program-&gt;<span class="hljs-built_in">setAttributeBuffer</span>(<span class="hljs-string">&quot;vTexture&quot;</span>, GL_FLOAT, <span class="hljs-number">3</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>), <span class="hljs-number">2</span>, <span class="hljs-number">5</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>));<br>m_program-&gt;<span class="hljs-built_in">enableAttributeArray</span>(<span class="hljs-string">&quot;vTexture&quot;</span>);<br></code></pre></div></td></tr></table></figure><p><code>setAttributeBuffer()</code>：</p><ul><li>第一个参数：表示 shader 中变量的名字</li><li>第二个参数：表示数据类型</li><li>第三个参数：表示在一个顶点中从哪个位置开始是需要的数据，坐标是 0 * sizeof(float)，纹理是 3 * sizeof(float)</li><li>第四个参数：表示有几个数据，坐标有 3 个数据，纹理坐标有 2 个数据</li><li>第五个参数：表示顶点数据中多少数据表示一个顶点，在这里是 5 个 float 值表示一个顶点</li></ul><h2 id="绘制带纹理的矩形"><a href="#绘制带纹理的矩形" class="headerlink" title="绘制带纹理的矩形"></a>绘制带纹理的矩形</h2><h3 id="加载纹理"><a href="#加载纹理" class="headerlink" title="加载纹理"></a>加载纹理</h3><p>在 Qt 中，OpenGL 的纹理使用 <code>QOpenGLTexture</code> 表示。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_texture = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QOpenGLTexture</span>(<span class="hljs-built_in">QImage</span>(<span class="hljs-string">&quot;path/to/image.png&quot;</span>).<span class="hljs-built_in">mirrored</span>());<br></code></pre></div></td></tr></table></figure><p>只要在类的头文件中定义了 <code>QOpenGLTexture *m_texture = nullptr;</code> ，初始化的时候就可以创建纹理了。</p><p>在加载图片的时候，要使用 mirrored() 方法，它默认会将图片沿 y 轴进行镜像翻转。因为我们用 （0， 0）表示左下角，所以坐标和一般的图像坐标发生了镜像翻转，所以加载纹理的时候也要镜像翻转一下。</p><h3 id="绑定纹理"><a href="#绑定纹理" class="headerlink" title="绑定纹理"></a>绑定纹理</h3><p>加载好纹理后，要绑定一下，告诉 OpenGL 有纹理才可以使用。</p><p>在绘制前 bind 一下，绘制完毕 release 就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OpenGLWidget::paintGL</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  m_texture.<span class="hljs-built_in">bind</span>();<br>  m_vao.<span class="hljs-built_in">bind</span>();<br>  m_program-&gt;<span class="hljs-built_in">bind</span>();<br>  <span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLE_FAN, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>  m_program-&gt;<span class="hljs-built_in">release</span>();<br>  m_vao.<span class="hljs-built_in">release</span>();<br>  m_texture.<span class="hljs-built_in">release</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>绘制矩形的参数不是之前绘制三角形时的 GL_TRIANGLES，0，3, 而是 GL_TRIANGLE_FAN，0，4。其中 GL_TRIANGLE_FAN 就是另一种绘制三角形的方法，它允许我们逆时针定义四个顶点，然后绘制出来两个三角形组成一个矩形。</p><p>此时，虽然定义了 <code>uniform sampler2D uTexture;</code> 用来表示纹理，但是始终没有给这个输入变量赋值，但是 OpenGL 又是如何将加载的纹理传到 shader 中？</p><p>因为 OpenGL 的纹理系统有个默认设定，那就是使用纹理的时候（调用 bind 函数的时候），会被自动对应到当前激活的纹理，默认激活的纹理就是纹理 0，而我们第一个定义的纹理变量，就会被当作纹理 0。这样，使用的纹理就自动的和 shader 中定义的纹理对应上了。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt中使用OpenGL（二）</title>
    <link href="/2022/04/13/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/04/13/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇从最简单的实现来把在 Qt 中使用 OpenGL 的流程走一遍</p><h2 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h2><h3 id="新建类"><a href="#新建类" class="headerlink" title="新建类"></a>新建类</h3><p>首先创建一个自己的窗口</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QOpenGLWidget&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QOpenGLFunctions_4_5_Core&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenGLWidget</span> :</span> <span class="hljs-keyword">public</span> QOpenGLWidget, QOpenGLFunctions_4_5_Core<br>&#123;<br>  Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">OpenGLWidget</span>(QWidget *parent);<br>  ~<span class="hljs-built_in">OpenGLWidget</span>();<br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeGL</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resizeGL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paintGL</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>protected 中的三个函数继承自 QOpenGLWidget，必须要进行重载。</p><h3 id="在-initializeGL-中做一些基本的初始化"><a href="#在-initializeGL-中做一些基本的初始化" class="headerlink" title="在 initializeGL() 中做一些基本的初始化"></a>在 initializeGL() 中做一些基本的初始化</h3><p>首先要做的就是初始化 OpenGL 函数，OpenGL 本身的 API 只提供了函数定义，所有的实现实际上是操作系统或者其他库的工作，初始化 OpenGL 函数的目的，就是加载这些 OpenGL 的实现。这个操作可以通过 <code>initializeOpenGLFunctions()</code> 这个函数实现。</p><p>其次要做的就是设置一些 OpenGL 的特性，比如深度测试。深度测试是指 “近处的物体会遮挡远处的物体” 这种在现实中最为基础的法则。可以通过 <code>glEnable(GL_DEPTH_TEST)</code> 这个函数实现。</p><p>在最后，还可以设置一下刷新时的背景颜色，可以通过 <code>glClearColor(0.2f, 0.3f, 0.3f, 1.0f)</code> 来实现，四个参数分别是 R，G，B，A 的值，取值范围 <code>[0, 1]</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OpenGLWidget::initializeGL</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">initializeOpenGLFunctions</span>();<br>  <span class="hljs-built_in">glEnable</span>(GL_DEPTH_TEST);<br>  <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 OpenGL 中，颜色值的范围，RGBA 每个通道都是从 0 开始，1 结束，如果希望按照 <code>[0, 255]</code> 的范围来设置，可以用 <code>(X / 255.0)</code> 。</p><h3 id="创建缓存"><a href="#创建缓存" class="headerlink" title="创建缓存"></a>创建缓存</h3><p>在绘制三维图像时，需要的输入是顶点，即用<code>(x, y, z)</code>表示的三维的点，三个点就能确定一个三角形。在 OpenGL 中，如果想传入顶点，就需要将顶点中的 x, y, z 每个值，一个一个的放到缓存中。</p><p>OpenGL 中存在两个概念：VAO 和 VBO</p><p>VAO 是 Vertex Array Object，顶点数组对象，VBO 是 Vertex Buffer Object，顶点缓存对象。</p><p>很显然，我们需要把顶点放到缓存中，也就是 VBO 中。 VAO 可以帮助我们在绘制多个三维对象时，将各自的绘制状态进行隔离，即每个绘制对象都可以有自己的顶点缓存，shader，以及它的各种状态，VAO 可以把这些状态保存起来，下一次执行的时候，就不需要重复设置了，也就是：一次设置，到处使用。</p><p>VAO 对应的 Qt 中的 <code>QOpenGLVertexArrayObject</code> 类， VBO 对应 Qt 中的 <code>QOpenGLBuffer</code> 类。</p><p>操作方法：创建两个对象，调用各自的创建函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QOpenGLWidget&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QOpenGLFunctions_4_5_Core&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QOpenGLVertexArrayObject&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QOpenGLBuffer&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenGLWidget</span> :</span> <span class="hljs-keyword">public</span> QOpenGLWidget, QOpenGLFunctions_4_5_Core<br>&#123;<br>  Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">OpenGLWidget</span>(QWidget *parent);<br>  ~<span class="hljs-built_in">OpenGLWidget</span>();<br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeGL</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resizeGL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paintGL</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>  QOPenGLVertexArrayObject m_vao;<br>  QOpenGLBuffer m_vbo;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OpenGLWidget::initializeGL</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">initializeOpenGLFunctions</span>();<br>  <span class="hljs-built_in">glEnable</span>(GL_DEPTH_TEST);<br>  <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>  <br>  m_vao.<span class="hljs-built_in">create</span>();<br>  m_vbo.<span class="hljs-built_in">create</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>VAO 和 VBO 是相互对应的，如果希望创建第二个 VBO 用于绘制第二个物体，那也要再创建一个 VAO。</p><h3 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h3><p>如果把顶点数据通过缓存给了 OpenGL，OpenGL 需要通过 shader 来使用这些顶点数据，包括对坐标进行缩放、平移、旋转，给顶点染色等等。</p><p>在 Qt 中提供了 QOpenGLShaderProgram 类帮助用户使用 shader。</p><p>shader 目前有两个类型，一个类型是 vertex，用于处理顶点； 一个类型是 fragment，用于处理颜色。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_program = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QOpenGLShaderProgram</span>();<br>m_program-&gt;<span class="hljs-built_in">addShaderFromSourceFile</span>(QOpenGLShader::Vertex, <span class="hljs-string">&quot;:/shaders/shape.vert&quot;</span>);<br>m_program-&gt;<span class="hljs-built_in">addSHaderFromSourceFile</span>(QOpenGLShader::Fragment, <span class="hljs-string">&quot;:/shaders/shape.frag&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>处理顶点的时候需要定义输入的顶点，处理颜色的时候可以什么都不用定义</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#version 450 core</span><br>in vec3 vPos;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  gl_Position = vec4(vPos, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这是vertex shader，其中 in 表示 vPos 这个变量是输入的变量， 类型为 vec3 即三维向量。 gl_Position 表示最终输出的位置，是内置的，不需要我们定义，它是一个四维向量，即 X，Y，Z，W。</p><p>这个 shader 的含义就是将输入的三维向量最后加一个 1.0 的值变成四维向量，然后作为最终的输出位置。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta"># version 450 core</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  gl_FragColor = vec4(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>gl_FragColor 表示最终输出的颜色，是内置的，不需要我们定义，它是一个四维向量，即R，G，B，A。</p><p>这个 shader 的含义就是最终输出的颜色是 <code>(1.0, 1.0, 1.0, 1.0)</code>，即白色.</p><p>最终，链接一下这个 shader</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_program-&gt;<span class="hljs-built_in">link</span>();<br></code></pre></div></td></tr></table></figure><h3 id="使用缓存与-shader"><a href="#使用缓存与-shader" class="headerlink" title="使用缓存与 shader"></a>使用缓存与 shader</h3><p>准备好了缓存与 shader，下一步就是使用它们了。</p><p>OpenGL 想要画出一个三维对象，就必须要有顶点的输入。OpenGL 通过顶点缓存这个概念让用户可以输入顶点信息。所谓的顶点缓存，简单来说就是一个一维数组。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">float</span> _vertex[] = &#123;<br>  <span class="hljs-number">0.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>,<br>  <span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>, <span class="hljs-number">0.0</span>,<br>  <span class="hljs-number">0.5</span>,<span class="hljs-number">-0.5</span>,<span class="hljs-number">0.0</span>,<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这个数组存储了 9 个 float 值，可以将其看作三个点，按照 x, y, z, x, y, z, x, y, z 这个顺序排列。使用 VBO 告诉 OpenGL 如何使用这 9 个值，3 个点。</p><p>首先使用 VAO 和 VBO 的 <code>bind()</code>函数告诉 OpenGL 我们要使用缓存了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_vao.<span class="hljs-built_in">bind</span>();<br>m_vbo.<span class="hljs-built_in">bind</span>();<br></code></pre></div></td></tr></table></figure><p>然后将自己定义的 9 个值，3 个点绑定到 VBO 上，通过 <code>allocate()</code> 函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_vbo.<span class="hljs-built_in">allocate</span>(_vertex, <span class="hljs-number">9</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>));<br><span class="hljs-comment">// m_vbo.allocate(_vertex, sizeof(_vertex));</span><br></code></pre></div></td></tr></table></figure><p>这里和我们需要内存保存数据一样， VBO 也会创建一块和顶点信息相同大小的内存，顶点信息是 9 个 float，这里也就创建 9 个 float 大小的区域。为了方便也可以使用注释掉的方法。</p><p>为了让 OpenGL 能够知道缓存中的数据是怎么排列的，我们需要为 shader 绑定一些信息。此时使用 vPos 这个输入变量的名字来告诉 OpenGL，在顶点缓存中，是按照 vPos 这个变量的类型，即 vec3 的标准来保存顶点信息的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_program-&gt;<span class="hljs-built_in">bind</span>();<br>m_program-&gt;<span class="hljs-built_in">setAttributeBuffer</span>(<span class="hljs-string">&quot;vPos&quot;</span>, GL_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>m_program-&gt;<span class="hljs-built_in">enableAttributeArray</span>(<span class="hljs-string">&quot;vPos&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>一般的，当顶点缓存只有顶点信息的时候，<code>setAttributeBuffer()</code> 这个函数我们只需要关心前四个参数即可。即 shader 中的输入参数名称，顶点缓存中的数据类型， 顶点缓存中开始的位置，顶点缓存中一个点需要用几个数据表示，第五个参数一般取 0 。</p><p>至此，所有的准备工作都完成了。</p><p>然后做做一个清理工作，释放 VAO 和 shader。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_program-&gt;<span class="hljs-built_in">release</span>();<br>m_vao-&gt;<span class="hljs-built_in">release</span>();<br></code></pre></div></td></tr></table></figure><h3 id="开始绘制吧"><a href="#开始绘制吧" class="headerlink" title="开始绘制吧"></a>开始绘制吧</h3><p>绘制部分非常简单，几行代码就可以。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OpenGLWidget::paintGL</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  m_vao.<span class="hljs-built_in">bind</span>();<br>  m_program-&gt;<span class="hljs-built_in">bind</span>();<br>  <span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>  m_program-&gt;<span class="hljs-built_in">release</span>();<br>  m_vao.<span class="hljs-built_in">release</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码分别是启用 VAO，启用 shader，用三个点话一个三角形，释放 shader，释放 VAO。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt中使用OpenGL（一）</title>
    <link href="/2022/04/13/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/04/13/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Qt-中的-OpenGL"><a href="#Qt-中的-OpenGL" class="headerlink" title="Qt 中的 OpenGL"></a>Qt 中的 OpenGL</h2><p>Qt 中对 OpenGL 进行了封装，一般来说，是需要继承 <code>QOpenGLWidget</code> 和 <code>QOpenGLFunctions</code>。大致上，用于显示 OpenGL 的窗口应该是一个类，这个类包括以下特性：</p><ul><li>继承 <code>QOpenGLWidget</code> 和 <code>QOpenGLFunctions</code></li><li>重载 <code>void initializeGL()</code>,<code> void paintGL()</code> 和 <code>void resizeGL(int w, int h)</code>这三个函数</li><li>提供函数用于设置相机的位置与选择</li><li>提供函数用于设置需要显示内容的具体数据</li><li>提供函数用于设置显示内容的缩放、旋转、位移等</li></ul><p>当显示复杂的内容时，则需要编写额外的逻辑，如模型管理等。</p><h2 id="initializeGL"><a href="#initializeGL" class="headerlink" title="initializeGL"></a>initializeGL</h2><p><code>initializeGL</code> 函数负责对 OpenGL 进行一定的初始化：</p><ol><li><p>初始化函数指针</p><p><code>initializeOpenGLFunctions()</code></p></li><li><p>启用一些 flag</p><p>例如 <code>glEnable(GL_DEPTH_TEST)</code>，开启深度测试。深度测试可以在绘制三维图形的时候，产生近处物体遮挡远处物体的效果</p></li><li><p>创建缓存</p><p>OpenGL 使用的时候需要一些缓存对象，如顶点数组对象（VAO），顶点缓存对象（VBO），在进行绘制的时候，数据来源于这些缓存对象</p></li><li><p>初始化 shader 程序并链接</p><p>Qt 提供了一个类 <code>QOpenGLShaderProgram</code>，通过这个类的 <code>addShaderFromSourceCode</code> 或者 <code>addShaderFromSourceFile</code> 方法加载 shader，然后使用 link 函数链接</p></li><li><p>加载数据</p><p>如果要显示的数据是静态数据，如静态模型，就可以在初始化的时候加载数据。如果是动态数据，就要实时加载</p></li></ol><h2 id="paintGL"><a href="#paintGL" class="headerlink" title="paintGL"></a>paintGL</h2><p>在 paintGL 函数中进行主要的三维绘制逻辑，主要进行如下操作：</p><ol><li><p>清除之前绘制的内容，包括颜色与深度信息</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br></code></pre></div></td></tr></table></figure></li><li><p>启用 shader</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_shaderProgram-&gt;<span class="hljs-built_in">bind</span>();<br></code></pre></div></td></tr></table></figure></li><li><p>设置 shader 中的全局数据，例如模型矩阵、视图矩阵、投影矩阵等</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 设置视图矩阵</span><br>m_viewMatrix.<span class="hljs-built_in">setToIdentity</span>();<br>QVector3D _lookDir&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>QVector3D _up&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>_lookDir = _lookDir * m_cameraRotate;<br>_up = _up * m_cameraRotate;<br>m_viewMatrix.<span class="hljs-built_in">lookAt</span>(m_cameraPos, m_cameraPos + _lookDIr, _up);<br>m_shaderProgram-&gt;<span class="hljs-built_in">setUniformValue</span>(<span class="hljs-string">&quot;view&quot;</span>, m_viewMatrix);<br><span class="hljs-comment">// 设置投影矩阵</span><br>m_shaderProgram-&gt;<span class="hljs-built_in">setUniformValue</span>(<span class="hljs-string">&quot;projection&quot;</span>, m_projectionMatrix);<br><span class="hljs-comment">// 设置模型矩阵</span><br>m_modelMatrix.<span class="hljs-built_in">setToIdentity</span>();<br>m_modelMatrix *= m_scale;<br>m_modelMatrix *= m_rotate;<br>m_modelMatrix *= m_translate;<br>m_shaderProgram-&gt;<span class="hljs-built_in">setUniformValu</span>(<span class="hljs-string">&quot;model&quot;</span>, m_modelMatrix);<br></code></pre></div></td></tr></table></figure></li><li><p>启用顶点数组对象（VAO）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_VAO.<span class="hljs-built_in">bind</span>();<br></code></pre></div></td></tr></table></figure></li><li><p>启用并设置顶点缓存对象（VBO）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 绑定 VBO</span><br>m_VBO.<span class="hljs-built_in">bind</span>();<br>m_VBO.<span class="hljs-built_in">setUsagePattern</span>(QOpenGLBuffer::StaticDraw);<br>m_VBO.<span class="hljs-built_in">allocate</span>(m_vertices, m_verticesCount * <span class="hljs-number">3</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>));<br></code></pre></div></td></tr></table></figure></li><li><p>将 shader 与顶点缓存进行对应，告诉 OpenGL 如何将顶点缓存中的数据转化为 shader 中的顶点数据</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_shaderProgram-&gt;<span class="hljs-built_in">setAttributeBuffer</span>(<span class="hljs-number">0</span>, GL_FLOAT, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>m_shaderProgram-&gt;<span class="hljs-built_in">enableAttributeArray</span>(<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>调用绘制函数，绘制顶点缓存中的内容</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 绘制</span><br><span class="hljs-built_in">glDrawArrays</span>(GL_POINTS, <span class="hljs-number">0</span>, m_verticesCount);<br></code></pre></div></td></tr></table></figure></li><li><p>释放顶点数组对象</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_VAO.<span class="hljs-built_in">release</span>();<br></code></pre></div></td></tr></table></figure></li><li><p>释放 shader</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">m_shaderProgram.<span class="hljs-built_in">release</span>();<br></code></pre></div></td></tr></table></figure></li></ol><p>其中，第五、六步是动态加载数据的步骤，如果数据是静态的，则应该在初始化执行操作。初始化的时候也应该先启用 shader 和 VAO ，并在最后释放 shader 和 VAO。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h3><ul><li>初始化 OpenGL 函数</li><li>初始化各种 flag</li><li>创建各种缓存对象</li><li>创建并链接 shader</li><li>启用 shader 和 缓存</li><li>绑定缓存 （静态数据）</li><li>绑定 shader 的缓存数据 （告诉 OpenGL 如何从缓存中读取到 shader 中）</li><li>释放缓存</li><li>释放shader</li></ul><h3 id="绘制阶段"><a href="#绘制阶段" class="headerlink" title="绘制阶段"></a>绘制阶段</h3><ul><li>清空屏幕</li><li>启用 shader</li><li>绑定 shader  的全局数据（各种矩阵）</li><li>启用缓存</li><li>绑定缓存（加载动态数据）</li><li>绑定 shader 的缓存数据（告诉 OpenGL 如何从缓存中读取到 shader）</li><li>绘制（使用 shader 读取缓存中的数据，转换为顶点数据，按照命令基于顶点绘制单位数据）</li><li>释放缓存</li><li>释放 shader</li></ul><p>可以存在多个缓存，每个缓存可以保存不同的内容，根据需要，可以在绘制阶段重复 启用缓存到释放缓存 之间的步骤以达到绘制不同模型的目的。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt中使用OpenGL-Camera类</title>
    <link href="/2022/04/13/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL-Camera%E7%B1%BB/"/>
    <url>/2022/04/13/Qt%E4%B8%AD%E4%BD%BF%E7%94%A8OpenGL-Camera%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>在 Qt 中</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17_电话号码的字母组合</title>
    <link href="/2022/04/07/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2022/04/07/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：digits = “23”<br><strong>输出</strong>：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：digits = “”<br><strong>输出</strong>：[]</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：digits = “2”<br><strong>输出</strong>：[“a”,”b”,”c”]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>采用 DFS 思路，在 DFS 函数中，首先判断是否遍历结束，即<code>index == digits.length()</code>，遍历结束即将当前字符串加入答案列表。否则获取当前字符对应的全部字母，然后遍历字母。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">char</span> digit = digits.charAt(index);<br>String letter = chars[digit-<span class="hljs-string">&#x27;0&#x27;</span>-<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;letter.length(); i++)&#123;<br>  sb.append(letter.charAt(i));<br>  dfs(sb,digits,index+<span class="hljs-number">1</span>);<br>  sb.deleteCharAt(index);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从 index = 0 的位置开始，最后返回答案列表</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;String&gt; ans;<br>    <span class="hljs-keyword">static</span> String[] chars = &#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span></span>&#123;<br>        ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (digits.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        dfs(sb,digits,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(StringBuilder sb, String digits, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length())&#123;<br>            ans.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">char</span> digit = digits.charAt(index);<br>        <span class="hljs-comment">// 当前数字对应的全部字母</span><br>        String letter = chars[digit-<span class="hljs-string">&#x27;0&#x27;</span>-<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> letterCount = letter.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; letterCount; i++) &#123;<br>            <span class="hljs-comment">// 加入当前字母</span><br>            sb.append(letter.charAt(i));<br>            <span class="hljs-comment">// 去下个数字中搜索</span><br>            dfs(sb,digits,index+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 回溯，将当前字母删掉</span><br>            sb.deleteCharAt(index);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>765_情侣牵手</title>
    <link href="/2022/04/06/765-%E6%83%85%E4%BE%A3%E7%89%B5%E6%89%8B/"/>
    <url>/2022/04/06/765-%E6%83%85%E4%BE%A3%E7%89%B5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。</p><p>人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。</p><p>返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次交换可选择任意两人，让他们站起来交换座位。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>: row = [0,2,1,3]<br><strong>输出</strong>: 1<br><strong>解释</strong>: 只需要交换row[1]和row[2]的位置即可。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>: row = [3,2,0,1]<br><strong>输出</strong>: 0<br><strong>解释</strong>: 无需交换座位，所有的情侣都已经可以手牵手了。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>2n == row.length</code></li><li><code>2 &lt;= n &lt;= 30</code></li><li><code>n</code> 是偶数</li><li><code>0 &lt;= row[i] &lt; 2n</code></li><li><code>row</code> 中所有元素均<strong>无重复</strong></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>用贪心算法，从前往后处理，以两格为一步。先检查 0 的右边是不是情侣，如果不是，就讲 0 号位置的情侣换到 1，然后检查 2 号位置的右边是不是情侣。</p><p>在求某个数字 x 的情侣时，可以用 <code>x^1</code>:</p><ul><li>当 x 是偶数，则二进制末尾是 0 ，<code>x^1</code>将末尾改成了 1，则 x 的对象是 x+1</li><li>当 x 是奇数，则二进制末尾是 1， <code>x^1</code>将末尾改成了 0，则 x 的对象是 x-1</li></ul><p>可以用数组 cache 存储每个人对应的位置存储起来</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  cache[row[i]]=i;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>具体流程如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i+=<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-comment">// b 为 a 的情侣</span><br>  <span class="hljs-keyword">int</span> a = row[i], b=a^<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 当 a 的右边不是 b 时</span><br>  <span class="hljs-keyword">if</span> (row[i+<span class="hljs-number">1</span>]!=b)&#123;<br>    <span class="hljs-comment">// 将 b 的位置换到 a 的右边</span><br>    <span class="hljs-keyword">int</span> src = i+<span class="hljs-number">1</span>, target = cache[b];<br>    <span class="hljs-comment">// 更新 cache</span><br>    cache[row[target]] = src;<br>    cache[row[src]] = target;<br>    <span class="hljs-comment">// 交换位置</span><br>    swap(row,src,target);<br>    <span class="hljs-comment">// 记录操作次数</span><br>    ans++;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结合起来：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] row)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> n = row.length;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cache[row[i]]=i;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i+=<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">int</span> a = row[i], b=a^<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (row[i+<span class="hljs-number">1</span>]!=b)&#123;<br>      <span class="hljs-keyword">int</span> src = i+<span class="hljs-number">1</span>, target = cache[b];<br>      cache[row[target]] = src;<br>      cache[row[src]] = target;<br>      swap(row,src,target);<br>      ans++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> c = nums[a];<br>  nums[a] = nums[b];<br>  nums[b] = c;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>111_计算除法</title>
    <link href="/2022/04/01/111-%E8%AE%A1%E7%AE%97%E9%99%A4%E6%B3%95/"/>
    <url>/2022/04/01/111-%E8%AE%A1%E7%AE%97%E9%99%A4%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p><p>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：equations = [[“a”,”b”],[“b”,”c”]], values = [2.0,3.0], queries = [[“a”,”c”],[“b”,”a”],[“a”,”e”],[“a”,”a”],[“x”,”x”]]<br><strong>输出</strong>：[6.00000,0.50000,-1.00000,1.00000,-1.00000]<br><strong>解释</strong>：<br>条件：a / b = 2.0, b / c = 3.0<br>问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?<br>结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：equations = [[“a”,”b”],[“b”,”c”],[“bc”,”cd”]], values = [1.5,2.5,5.0], queries = [[“a”,”c”],[“c”,”b”],[“bc”,”cd”],[“cd”,”bc”]]<br><strong>输出</strong>：[3.75000,0.40000,5.00000,0.20000]</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：equations = [[“a”,”b”]], values = [0.5], queries = [[“a”,”b”],[“b”,”a”],[“a”,”c”],[“x”,”y”]]<br><strong>输出</strong>：[0.50000,2.00000,-1.00000,-1.00000]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= equations.length &lt;= 20</li><li>equations[i].length == 2</li><li>1 &lt;= Ai.length, Bi.length &lt;= 5</li><li>values.length == equations.length</li><li>0.0 &lt; values[i] &lt;= 20.0</li><li>1 &lt;= queries.length &lt;= 20</li><li>queries[i].length == 2</li><li>1 &lt;= Cj.length, Dj.length &lt;= 5</li><li>Ai, Bi, Cj, Dj 由小写英文字母与数字组成</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>创建一个用来表示边的类 Edge</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span></span>&#123;<br>  Map&lt;String, Double&gt; nexts;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">()</span></span>&#123;<br>    nexts = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = nexts.entrySet();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Set&lt;Map.Entry&lt;String, Double&gt;&gt; getNextsSet()&#123;<br>    <span class="hljs-keyword">return</span> nexts.entrySet();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(String next, <span class="hljs-keyword">double</span> cost)</span></span>&#123;<br>    nexts.put(next, cost);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canReach</span><span class="hljs-params">(String to)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> nexts.containsKey(to);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> nexts.get(key);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先对 equations 进行遍历，将 a/b 和 b/a 存储起来</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;<br>  List&lt;String&gt; list = equations.get(i);<br>  <span class="hljs-comment">// 如果 edgeMap 不包含当前 equation，则添加</span><br>  <span class="hljs-keyword">if</span> (!edgeMap.containsKey(list.get(<span class="hljs-number">0</span>)))&#123;<br>    edgeMap.put(list.get(<span class="hljs-number">0</span>),<span class="hljs-keyword">new</span> Edge());<br>  &#125;<br>  <span class="hljs-comment">// 添加 a-&gt;b    (a,[b,cost])</span><br>  edgeMap.get(list.get(<span class="hljs-number">0</span>)).addEdge(list.get(<span class="hljs-number">1</span>),values[i]);<br>  <span class="hljs-keyword">if</span> (!edgeMap.containsKey(list.get(<span class="hljs-number">1</span>)))&#123;<br>    edgeMap.put(list.get(<span class="hljs-number">1</span>),<span class="hljs-keyword">new</span> Edge());<br>  &#125;<br>  <span class="hljs-comment">// 添加 b-&gt;a    (b,[a,1/cost])</span><br>  edgeMap.get(list.get(<span class="hljs-number">1</span>)).addEdge(list.get(<span class="hljs-number">0</span>),<span class="hljs-number">1</span>/values[i]);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>定义 dfs 函数查找答案。flags用来记录是否访问过。</p><ol><li>如果 start 等于 end，表示 start / start，返回 1 </li><li>通过 Edge 的 canReach 方法判断是否可以直达<ol><li>如果可以，直接返回结果</li><li>不可以的话将所有结果列出来，如果已经访问过则跳过，没有访问过则向 flags 里添加当前结果，递归当前结果 <code>double res = dfs(entry.getKey(), end, flags, edgeMap);</code>，结果不为 -1 表示可达，在 edgeMap 里添加当前结果，当前结果表示为 res * entry.getValue()。从 flags 里移除当前访问项。</li></ol></li><li>如果都不符合直接返回 -1</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String start, String end, Set&lt;String&gt; flags, Map&lt;String, Edge&gt; edgeMap)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (start.equals(end)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  Edge edge = edgeMap.get(start);<br>  <span class="hljs-keyword">if</span> (edge.canReach(end))&#123;<br>    <span class="hljs-keyword">return</span> edge.get(end);<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Double&gt; entry: edge.getNextsSet())&#123;<br>      <span class="hljs-keyword">if</span> (flags.contains(entry.getKey())) <span class="hljs-keyword">continue</span>;<br>      flags.add(entry.getKey());<br>      <span class="hljs-keyword">double</span> res = dfs(entry.getKey(), end, flags, edgeMap);<br>      <span class="hljs-keyword">if</span>(res!=-<span class="hljs-number">1</span>)&#123;<br>        edge.addEdge(end, entry.getValue()*res);<br>        <span class="hljs-keyword">return</span> entry.getValue()*res;<br>      &#125;<br>      flags.remove(entry.getKey());<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终题解</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries)&#123;<br>        <span class="hljs-comment">// a, a 可达的点及距离</span><br>        Map&lt;String, Edge&gt; edgeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;<br>            List&lt;String&gt; list = equations.get(i);<br>            <span class="hljs-comment">// 如果 edgeMap 不包含当前 equation，则添加</span><br>            <span class="hljs-keyword">if</span> (!edgeMap.containsKey(list.get(<span class="hljs-number">0</span>)))&#123;<br>                edgeMap.put(list.get(<span class="hljs-number">0</span>),<span class="hljs-keyword">new</span> Edge());<br>            &#125;<br>            <span class="hljs-comment">// 添加 a-&gt;b    (a,[b,cost])</span><br>            edgeMap.get(list.get(<span class="hljs-number">0</span>)).addEdge(list.get(<span class="hljs-number">1</span>),values[i]);<br>            <span class="hljs-keyword">if</span> (!edgeMap.containsKey(list.get(<span class="hljs-number">1</span>)))&#123;<br>                edgeMap.put(list.get(<span class="hljs-number">1</span>),<span class="hljs-keyword">new</span> Edge());<br>            &#125;<br>            <span class="hljs-comment">// 添加 b-&gt;a    (b,[a,1/cost])</span><br>            edgeMap.get(list.get(<span class="hljs-number">1</span>)).addEdge(list.get(<span class="hljs-number">0</span>),<span class="hljs-number">1</span>/values[i]);<br>        &#125;<br>        <span class="hljs-keyword">double</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[queries.size()];<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; query: queries)&#123;<br>            <span class="hljs-keyword">if</span> (!edgeMap.containsKey(query.get(<span class="hljs-number">0</span>))) ans[i++]=-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> ans[i++] = dfs(query.get(<span class="hljs-number">0</span>),query.get(<span class="hljs-number">1</span>),<span class="hljs-keyword">new</span> HashSet&lt;&gt;(),edgeMap);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String start, String end, Set&lt;String&gt; flags, Map&lt;String, Edge&gt; edgeMap)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (start.equals(end)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        Edge edge = edgeMap.get(start);<br>        <span class="hljs-keyword">if</span> (edge.canReach(end))&#123;<br>            <span class="hljs-keyword">return</span> edge.get(end);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Double&gt; entry: edge.getNextsSet())&#123;<br>                <span class="hljs-keyword">if</span> (flags.contains(entry.getKey())) <span class="hljs-keyword">continue</span>;<br>                flags.add(entry.getKey());<br>                <span class="hljs-keyword">double</span> res = dfs(entry.getKey(), end, flags, edgeMap);<br>                <span class="hljs-keyword">if</span>(res!=-<span class="hljs-number">1</span>)&#123;<br>                    edge.addEdge(end, entry.getValue()*res);<br>                    <span class="hljs-keyword">return</span> entry.getValue()*res;<br>                &#125;<br>                flags.remove(entry.getKey());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span></span>&#123;<br>        Map&lt;String, Double&gt; nexts;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">()</span></span>&#123;<br>            nexts = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>            Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = nexts.entrySet();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Set&lt;Map.Entry&lt;String, Double&gt;&gt; getNextsSet()&#123;<br>            <span class="hljs-keyword">return</span> nexts.entrySet();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(String next, <span class="hljs-keyword">double</span> cost)</span></span>&#123;<br>            nexts.put(next, cost);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canReach</span><span class="hljs-params">(String to)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> nexts.containsKey(to);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> nexts.get(key);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024_考试的最大困扰度</title>
    <link href="/2022/03/29/2024-%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6/"/>
    <url>/2022/03/29/2024-%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一位老师正在出一场由 n 道判断题构成的考试，每道题的答案为 true （用 ‘T’ 表示）或者 false （用 ‘F’ 表示）。老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 true 或者连续出现 false）。</p><p>给你一个字符串 answerKey ，其中 answerKey[i] 是第 i 个问题的正确结果。除此以外，还给你一个整数 k ，表示你能进行以下操作的最多次数：</p><p>每次操作中，将问题的正确答案改为 ‘T’ 或者 ‘F’ （也就是将 answerKey[i] 改为 ‘T’ 或者 ‘F’ ）。<br>请你返回在不超过 k 次操作的情况下，最大 连续 ‘T’ 或者 ‘F’ 的数目。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：answerKey = “TTFF”, k = 2<br><strong>输出</strong>：4<br><strong>解释</strong>：我们可以将两个 ‘F’ 都变为 ‘T’ ，得到 answerKey = “TTTT” 。<br>总共有四个连续的 ‘T’ 。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：answerKey = “TFFT”, k = 1<br><strong>输出</strong>：3<br><strong>解释</strong>：我们可以将最前面的 ‘T’ 换成 ‘F’ ，得到 answerKey = “FFFT” 。<br>或者，我们可以将第二个 ‘T’ 换成 ‘F’ ，得到 answerKey = “TFFF” 。<br>两种情况下，都有三个连续的 ‘F’ 。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：answerKey = “TTFTTFTT”, k = 1<br><strong>输出</strong>：5<br><strong>解释</strong>：我们可以将第一个 ‘F’ 换成 ‘T’ ，得到 answerKey = “TTTTTFTT” 。<br>或者我们可以将第二个 ‘F’ 换成 ‘T’ ，得到 answerKey = “TTFTTTTT” 。<br>两种情况下，都有五个连续的 ‘T’ 。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>n == answerKey.length</li><li>$1 &lt;= n &lt;= 5 * 10^4$</li><li>answerKey[i] 要么是 ‘T’ ，要么是 ‘F’</li><li>1 &lt;= k &lt;= n</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>设计一个 getCount 函数，getCount 函数的实现可以使用「滑动窗口」：使用 j 和 i 分别代表窗口的左右端点，count 为区间 <code>[j, i]</code> 中字符 c 的数量，每次右端点 i 移动时，若满足 s[i] = c，让 count 自增，当 count &gt; k 时，使左端点 j 往右移动，同时更新 count，直到 <code>[j, i]</code> 区间恢复合法性（包含字符 c 的数量 count 不超过 k 个）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    String s;<br>    <span class="hljs-keyword">int</span> n,_k;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxConsecutiveAnswers</span><span class="hljs-params">(String answerKey, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        s = answerKey;<br>        n = s.length();<br>        _k = k;<br>        <span class="hljs-keyword">return</span> Math.max(getCount(<span class="hljs-string">&#x27;T&#x27;</span>),getCount(<span class="hljs-string">&#x27;F&#x27;</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>, count=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i)==c) count++;<br>            <span class="hljs-keyword">while</span> (count&gt;_k)&#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(j)==c)count--;<br>                j++;<br>            &#125;<br>            ans = Math.max(ans,i-j+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1123_最深叶节点的最近公共祖先</title>
    <link href="/2022/03/28/1123-%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/03/28/1123-%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个有根节点 root 的二叉树，返回它 最深的叶节点的最近公共祖先 。</p><p>回想一下：</p><ul><li>叶节点 是二叉树中没有子节点的节点</li><li>树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1</li><li>如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" alt="img"></p><blockquote><p><strong>输入</strong>：root = [3,5,1,6,2,0,8,null,null,7,4]<br><strong>输出</strong>：[2,7,4]<br><strong>解释</strong>：我们返回值为 2 的节点，在图中用黄色标记。<br>在图中用蓝色标记的是树的最深的节点。<br>注意，节点 6、0 和 8 也是叶节点，但是它们的深度是 2 ，而节点 7 和 4 的深度是 3 。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：root = [1]<br><strong>输出</strong>：[1]<br><strong>解释</strong>：根节点是树中最深的节点，它是它本身的最近公共祖先。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：root = [0,1,3,null,2]<br><strong>输出</strong>：[2]<br><strong>解释</strong>：树中最深的叶节点是 2 ，最近公共祖先是它自己。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>树中的节点数将在 <code>[1, 1000]</code> 的范围内。</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li>每个节点的值都是 <strong>独一无二</strong> 的。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>寻找最深叶子节点，如果最深叶子节点只有一个的话，那这个最深叶子节点的最近公共祖先就是它自己。</p><p>可以从深度的方面考虑，全局维护一个最大共同深度，当左节点深度等于右节点深度，则更新最大共同深度，更新结果。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> TreeNode ans = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lcaDeepestLeaves</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>dfs(root, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> level;<br>  <span class="hljs-keyword">int</span> left = dfs(root.left, level+<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">int</span> right = dfs(root.right,level+<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (left==right &amp;&amp; left&gt;=max)&#123;<br>    ans = root;<br>    max = left;<br>  &#125;<br>  <span class="hljs-keyword">return</span> Math.max(left,right);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>388_文件的最长绝对路径</title>
    <link href="/2022/03/24/388-%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/03/24/388-%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220324113857.jpg" alt="img"></p><p>这里将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext 。</p><p>在文本格式中，如下所示(⟶表示制表符)：</p><blockquote><p>dir<br>⟶ subdir1<br>⟶ ⟶ file1.ext<br>⟶ ⟶ subsubdir1<br>⟶ subdir2<br>⟶ ⟶ subsubdir2<br>⟶ ⟶ ⟶ file2.ext</p></blockquote><p>如果是代码表示，上面的文件系统可以写为 <code>&quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot;</code> 。<code>&#39;\n&#39;</code> 和 <code>&#39;\t&#39;</code> 分别是换行符和制表符。</p><p>文件系统中的每个文件和文件夹都有一个唯一的 绝对路径 ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 ‘/‘ 连接。上面例子中，指向 file2.ext 的 绝对路径 是 “dir/subdir2/subsubdir2/file2.ext” 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 name.extension 的格式，其中 name 和 extension由字母、数字和/或空格组成。</p><p>给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向 文件 的 最长绝对路径 的长度 。 如果系统中没有文件，返回 0。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220324114139.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：input = “dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext”<br><strong>输出</strong>：20<br><strong>解释</strong>：只有一个文件，绝对路径为 “dir/subdir2/file.ext” ，路径长度 20</p></blockquote><p>示例二：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220324114114.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：input = “dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext”<br><strong>输出</strong>：32<br><strong>解释</strong>：存在两个文件：<br>“dir/subdir1/file1.ext” ，路径长度 21<br>“dir/subdir2/subsubdir2/file2.ext” ，路径长度 32<br>返回 32 ，因为这是最长的路径</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：input = “a”<br><strong>输出</strong>：0<br><strong>解释</strong>：不存在任何文件</p></blockquote><p>示例四：</p><blockquote><p><strong>输入</strong>：input = “file1.txt\nfile2.txt\nlongfile.txt”<br><strong>输出</strong>：12<br><strong>解释</strong>：根目录下有 3 个文件。<br>因为根目录中任何东西的绝对路径只是名称本身，所以答案是 “longfile.txt” ，路径长度为 12</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$1 &lt;= input.length &lt;= 10^4$</li><li>input 可能包含小写或大写的英文字母，一个换行符 <code>&#39;\n&#39;</code>，一个制表符 <code>&#39;\t&#39;</code>，一个点 <code>&#39;.&#39;</code>，一个空格 <code>&#39; &#39;</code>，和数字。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>先用 <code>\n</code>将字符串切开，按行读取，然后用一个 栈 来存储每层的累积长度</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthLongestPath</span><span class="hljs-params">(String input)</span></span>&#123;<br>    String[] files = input.split(<span class="hljs-string">&quot;\n&quot;</span>);<br>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    stack.push(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (String file: files)&#123;<br>        <span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>, depth = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 计算层数</span><br>        <span class="hljs-keyword">while</span> (j&lt;file.length()&amp;&amp;file.charAt(j)==<span class="hljs-string">&#x27;\t&#x27;</span>)&#123;<br>            depth++;<br>            j++;<br>        &#125;<br>        <span class="hljs-comment">// 文件名长度</span><br>        <span class="hljs-keyword">int</span> length = file.length()-j;<br>        <span class="hljs-comment">// 清空多余层数</span><br>        <span class="hljs-keyword">while</span> (stack.size()&gt;depth)&#123;<br>            stack.pop();<br>        &#125;<br>        <span class="hljs-comment">// 如果是文件，则计算最大长度 stack.peek() + length</span><br>        <span class="hljs-keyword">if</span> (file.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>)&gt;=<span class="hljs-number">0</span>)&#123;<br>            ans = Math.max(ans,stack.peek()+length);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果不是文件，说明为目录，则推入当前层的累积长度 （上一层+本层+1）</span><br>            stack.push(stack.peek()+length+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>385_迷你语法分析器</title>
    <link href="/2022/03/24/385-%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <url>/2022/03/24/385-%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。</p><p>列表中的每个元素只可能是整数或整数嵌套列表</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：s = “324”,<br><strong>输出</strong>：324<br><strong>解释</strong>：你应该返回一个 NestedInteger 对象，其中只包含整数值 324。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：s = “[123,[456,[789]]]”,<br><strong>输出</strong>：[123,[456,[789]]]<br><strong>解释</strong>：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：</p><ol><li>一个 integer 包含值 123</li><li>一个包含两个元素的嵌套列表：<br> i.  一个 integer 包含值 456<br> ii. 一个包含一个元素的嵌套列表<div class="hljs code-wrapper"><pre><code class="hljs">  a. 一个 integer 包含值 789</code></pre></div></li></ol></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$1 &lt;= s.length &lt;= 5 * 10^4$</li><li>s 由数字、方括号 “[]”、负号 ‘-‘ 、逗号 ‘,’组成</li><li>用例保证 s 是可解析的 NestedInteger</li><li>输入中的所有值的范围是 $[-10^6, 10^6]$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>题目意思是解析字符串，还原成 NestedInteger 对象，NestedInteger 对象可以实例化成两类，要么是空或者数组，要么是数字</p><p>使用 start 来标记起始位置，用来截取一个完整的对象字符串，用 count 来标记层数，当 count 等于 0 时，说明当前字符串为数字，当字符大于 0 时，说明当前字符串为数组</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> NestedInteger <span class="hljs-title">deserialize</span><span class="hljs-params">(String s)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(s.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NestedInteger();<br>  <span class="hljs-keyword">if</span>(s.charAt(<span class="hljs-number">0</span>)!=<span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NestedInteger(Integer.valueOf(s));<br>  <span class="hljs-keyword">if</span>(s.length()&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NestedInteger();<br>  NestedInteger res = <span class="hljs-keyword">new</span> NestedInteger();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> start=<span class="hljs-number">1</span>, i=<span class="hljs-number">1</span>,count=<span class="hljs-number">0</span>; i&lt;s.length();i++)&#123;<br>    <span class="hljs-comment">// count == 0表示非List，遇到&#x27;,&#x27;则递归解析；</span><br>    <span class="hljs-comment">// count &gt; 0，表示已经进入List状态，这时不处理&#x27;,&#x27;，</span><br>    <span class="hljs-comment">// 这时的逗号是List里面的，属于子问题，由DFS处理</span><br>    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span> &amp;&amp; (s.charAt(i)==<span class="hljs-string">&#x27;,&#x27;</span>|| i==s.length()-<span class="hljs-number">1</span>))&#123;<br>      res.add(deserialize(s.substring(start,i)));<br>      start = i+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>      count++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>      count--;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>440_字典序的第K小数字</title>
    <link href="/2022/03/23/440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2022/03/23/440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定整数 <code>n</code> 和 <code>k</code>，返回 <code>[1, n]</code> 中字典序第 <code>k</code> 小的数字。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>: n = 13, k = 2<br><strong>输出</strong>: 10<br><strong>解释</strong>: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>: n = 1, k = 1<br><strong>输出</strong>: 1</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$1 &lt;= k &lt;= n &lt;= 10^9$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220323142951.png" alt="image.png"></p><p>可以参照上图来理解</p><ol><li>初始化前缀为 1，计算以 1 为前缀的所有子树节点树木，如果小于 k ，说明当前子树的节点数不够，向右移动变为 2，如果大于 k ，说明答案就在当前根节点的子树节点，向下移动 变为 10</li><li>k 减去已经遍历过的节点个数，以当前为根节点，直到 k=0</li></ol><blockquote><p>第一层节点数为： 1 = nextPrefix - prefix; | 2 - 1<br>第二层的节点数为10 = nextPrefix - prefix; | (2 * 10) - (1 * 10)<br>…</p><p>由于最后一层可能出现结点不满的情况，所以要取 总结点数 - prefix 与 nextPrefix - prefix的最小值，即：</p><p>第n层的节点数为：Math.min (k - prefix , nextPrefix - prefix); | k - (1 * 10^n) 、(n * 10^n) - (1 * 10^n)</p><p>于是对于每一层的节点数，直接用一个式子表示：Math.min (k - prefix , nextPrefix - prefix)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-comment">// 从根节点下面的第一个节点 1 开始遍历</span><br>    <span class="hljs-keyword">long</span> curr = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 从 1 出发后按字典序从小到大的顺序走 k-1 步就是 字典序第 k 小的数字</span><br>    k -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 得到以当前节点为根的所有子树节点数目</span><br>        <span class="hljs-keyword">int</span> node = getCount(n,curr);<br>        <span class="hljs-comment">// 如果 k 大于当前根节点下所有子树节点的数目，就向右侧移动 -&gt; 2 -&gt; 3 -&gt; 4 ...</span><br>        <span class="hljs-keyword">if</span> (k&gt;=node)&#123;<br>            <span class="hljs-comment">// 减去已经遍历的个数</span><br>            k-=node;<br>            <span class="hljs-comment">// 根节点右移</span><br>            curr++;<br>        &#125;<br>        <span class="hljs-comment">// 如果 k 小于当前根节点下子树节点数目，说明答案就在当前根节点的子树节点中</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 减去根节点的数量 1</span><br>            k -= <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 将根节点移动到下一层(每层有 10 个节点)</span><br>            curr *= <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最终 k=0 时,就找到了答案</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)curr;<br>&#125;<br><br><span class="hljs-comment">// 计算以 curr 为根的子树节点数目，所有节点值必须 &lt;= n</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">long</span> curr)</span></span>&#123;<br>    <span class="hljs-comment">// 记录子树中的全部节点数目</span><br>    <span class="hljs-keyword">long</span> totalCounts = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 当前节点右侧节点的值</span><br>    <span class="hljs-keyword">long</span> next = curr + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (curr&lt;=n)&#123;<br>        <span class="hljs-comment">// 取整行节点的个数，可能全满，也可能是叶子节点，没有满</span><br>        totalCounts += Math.min(n-curr+<span class="hljs-number">1</span>, next - curr);<br>        next *=<span class="hljs-number">10</span>;<br>        curr *=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)totalCounts;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>386_字典序排数</title>
    <link href="/2022/03/23/386-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0/"/>
    <url>/2022/03/23/386-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> ，按字典序返回范围 <code>[1, n]</code> 内所有整数。</p><p>你必须设计一个时间复杂度为 <code>O(n)</code> 且使用 <code>O(1)</code> 额外空间的算法。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：n = 13<br><strong>输出</strong>：[1,10,11,12,13,2,3,4,5,6,7,8,9]</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：n = 2<br><strong>输出</strong>：[1,2]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$1 &lt;= n &lt;= 5 * 10^4$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>base 从 0 开始，当 base 小于 n 时，计算 num = base + i，（i 从 start 到 9 递增，一般来说是从 0 开始，但第一个数应该是从 1 开始），然后递归 dfs（num*10, 0, n, ans）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">lexicalOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  dfs(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,n,ans);<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">// 以 base 为基数，从 start 开始添加个位数， &lt;=n 的结果添加到 ans 中</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> n, List&lt;Integer&gt; ans)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(base&gt;n)<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>    <span class="hljs-keyword">int</span> num = i+base;<br>    <span class="hljs-keyword">if</span>(num&lt;=n)&#123;<br>      ans.add(num);<br>      dfs(num*<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,n,ans);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>443_压缩字符串</title>
    <link href="/2022/03/22/443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/03/22/443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符数组 chars ，请使用下述算法压缩：</p><p>从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：</p><ul><li>如果这一组长度为 1 ，则将字符追加到 s 中。</li><li>否则，需要向 s 追加字符，后跟这一组的长度。</li></ul><p>压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。</p><p>请在 修改完输入数组后 ，返回该数组的新长度。</p><p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：chars = [“a”,”a”,”b”,”b”,”c”,”c”,”c”]<br><strong>输出</strong>：返回 6 ，输入数组的前 6 个字符应该是：[“a”,”2”,”b”,”2”,”c”,”3”]<br><strong>解释</strong>：”aa” 被 “a2” 替代。”bb” 被 “b2” 替代。”ccc” 被 “c3” 替代。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：chars = [“a”]<br><strong>输出</strong>：返回 1 ，输入数组的前 1 个字符应该是：[“a”]<br><strong>解释</strong>：唯一的组是“a”，它保持未压缩，因为它是一个字符。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：chars = [“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”]<br><strong>输出</strong>：返回 4 ，输入数组的前 4 个字符应该是：[“a”,”b”,”1”,”2”]。<br><strong>解释</strong>：由于字符 “a” 不重复，所以不会被压缩。”bbbbbbbbbbbb” 被 “b12” 替代。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= chars.length &lt;= 2000</code></li><li><code>chars[i]</code> 可以是小写英文字母、大写英文字母、数字或符号</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>采用双指针来遍历 char 数组，定义一个 write 和 read 值，write 用来存储写的位置，read 表示读的位置，定义 left 用来存储每个不同字符的起始位置</p><p>当当前字符与下个字符不同时，先向 write 位置写入当前字符，write 移动到下一个位置，然后计算相同连续字符长度 read - left + 1，当长度大于 1 时，需要向 write 位置写入数值，用短除法写入后再反转。left 的位置变为 read + 1</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(read==n-<span class="hljs-number">1</span> || chars[read] != chars[read+<span class="hljs-number">1</span>])&#123;<br>  chars[write++] = chars[read];<br>  <span class="hljs-keyword">int</span> num = read-left+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (num&gt;<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">int</span> anchor = write;<br>    <span class="hljs-comment">// 将 num 转化为 char</span><br>    <span class="hljs-keyword">while</span> (num&gt;<span class="hljs-number">0</span>)&#123;<br>      chars[write++] = (<span class="hljs-keyword">char</span>)(num%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>      num/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 反转一下</span><br>    reverse(chars, anchor, write-<span class="hljs-number">1</span>);<br>  &#125;<br>  left = read+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终题解为：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compress</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = chars.length;<br>    <span class="hljs-keyword">int</span> write = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> read = <span class="hljs-number">0</span>; read&lt;n; read++)&#123;<br>        <span class="hljs-keyword">if</span>(read==n-<span class="hljs-number">1</span> || chars[read] != chars[read+<span class="hljs-number">1</span>])&#123;<br>            chars[write++] = chars[read];<br>            <span class="hljs-keyword">int</span> num = read-left+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (num&gt;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">int</span> anchor = write;<br>                <span class="hljs-comment">// 将 num 转化为 char</span><br>                <span class="hljs-keyword">while</span> (num&gt;<span class="hljs-number">0</span>)&#123;<br>                    chars[write++] = (<span class="hljs-keyword">char</span>)(num%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>                    num/=<span class="hljs-number">10</span>;<br>                &#125;<br>                <span class="hljs-comment">// 反转一下</span><br>                reverse(chars, anchor, write-<span class="hljs-number">1</span>);<br>            &#125;<br>            left = read+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> write;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>        <span class="hljs-keyword">char</span> temp = chars[left];<br>        chars[left] = chars[right];<br>        chars[right] = temp;<br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>166_分数到小数</title>
    <link href="/2022/03/22/166-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/"/>
    <url>/2022/03/22/166-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。</p><p>如果小数部分为循环小数，则将循环的部分括在括号内。</p><p>如果存在多个答案，只需返回 任意一个 。</p><p>对于所有给定的输入，保证 答案字符串的长度小于 $10^4$ 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：numerator = 1, denominator = 2<br><strong>输出</strong>：”0.5”</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：numerator = 2, denominator = 1<br><strong>输出</strong>：”2”</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：numerator = 2, denominator = 3<br><strong>输出</strong>：”0.(6)”</p></blockquote><p>示例四：</p><blockquote><p><strong>输入</strong>：numerator = 4, denominator = 333<br><strong>输出</strong>：”0.(012)”</p></blockquote><p>示例五：</p><blockquote><p><strong>输入</strong>：numerator = 1, denominator = 5<br><strong>输出</strong>：”0.2”</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$-2^{31} &lt;= numerator, denominator &lt;= 2^{31} - 1$</li><li><code>denominator != 0</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><ul><li>如果本身两数能够整除，直接返回即可</li><li>如果两个数有一个为“负数”，则最终答案为“负数”</li><li>两者范围为 <code>int</code>，但计算结果可以会超过 <code>int</code> 范围,所以先用 <code>long</code> 对两个参数进行格式转换</li></ul><p>从人工模拟除法运算的过程，就可以知道「为什么不会出现“无限不循环小数”」，因为始终是对余数进行补零操作，再往下进行运算，而余数个数具有明确的上限（有限集）。所以根据抽屉原理，一直接着往下计算，最终结果要么是「出现相同余数」，要么是「余数为 0，运算结束」。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fractionToDecimal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numerator, <span class="hljs-keyword">int</span> denominator)</span></span>&#123;<br>    <span class="hljs-comment">// 转 long 计算，防止溢出</span><br>    <span class="hljs-keyword">long</span> a = numerator, b = denominator;<br>    <span class="hljs-keyword">if</span> (a%b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> String.valueOf(a/b);<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">// 处理正负号</span><br>    <span class="hljs-keyword">if</span> (a*b&lt;<span class="hljs-number">0</span>) sb.append(<span class="hljs-string">&#x27;-&#x27;</span>);<br>    a = Math.abs(a);<br>    b = Math.abs(b);<br>    <span class="hljs-comment">// 添加小数点前的部分</span><br>    sb.append(String.valueOf(a/b)+<span class="hljs-string">&quot;.&quot;</span>);<br>    a %=b;<br>    Map&lt;Long, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (a!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 记录当前余数所在位置</span><br>        map.put(a,sb.length());<br>        a*=<span class="hljs-number">10</span>;<br>        sb.append(a/b);<br>        a%=b;<br>        <span class="hljs-comment">// 如果余数出现过，则将出现位置到当前位置提取出来</span><br>        <span class="hljs-keyword">if</span> (map.containsKey(a))&#123;<br>            <span class="hljs-keyword">int</span> u = map.get(a);<br>            <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s(%s)&quot;</span>,sb.substring(<span class="hljs-number">0</span>,u),sb.substring(u));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8_字符串转换整数（atoi）</title>
    <link href="/2022/03/22/8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%EF%BC%88atoi%EF%BC%89/"/>
    <url>/2022/03/22/8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%EF%BC%88atoi%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p><p>函数 myAtoi(string s) 的算法如下：</p><ol><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</li><li>返回整数作为最终结果。</li></ol><p>注意：</p><p>​    本题中的空白字符只包括空格字符 ‘ ‘ 。<br>​    除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：s = “42”<br><strong>输出</strong>：42<br><strong>解释</strong>：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。<br>第 1 步：”42”（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 2 步：”42”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’）<br>         ^<br>第 3 步：”42”（读入 “42”）<br>           ^<br>解析得到整数 42 。<br>由于 “42” 在范围 [-231, 231 - 1] 内，最终结果为 42 。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：s = “   -42”<br><strong>输出</strong>：-42<br><strong>解释</strong>：<br>第 1 步：”   -42”（读入前导空格，但忽视掉）<br>            ^<br>第 2 步：”   -42”（读入 ‘-‘ 字符，所以结果应该是负数）<br>             ^<br>第 3 步：”   -42”（读入 “42”）<br>               ^<br>解析得到整数 -42 。<br>由于 “-42” 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：s = “4193 with words”<br><strong>输出</strong>：4193<br><strong>解释</strong>：<br>第 1 步：”4193 with words”（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 2 步：”4193 with words”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’）<br>         ^<br>第 3 步：”4193 with words”（读入 “4193”；由于下一个字符不是一个数字，所以读入停止）<br>             ^<br>解析得到整数 4193 。<br>由于 “4193” 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>使用 trim() 函数去空格会产生新的变量，所以尽量不使用。</p><p>使用一个变量 <code>index</code> 去做遍历，并且在计算数值时，因为要求在整数范围内，所以要先判断乘以 10 之后是否会溢出，只要溢出就退出循环。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String s)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> len = s.length();<br>  <span class="hljs-keyword">char</span>[] charArray = s.toCharArray();<br>  <span class="hljs-comment">// 去除前导空格</span><br>  <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (index&lt;len &amp;&amp; charArray[index]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>    index++;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (index==len)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 符号</span><br>  <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">char</span> firstChar = charArray[index];<br>  <span class="hljs-keyword">if</span> (firstChar == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>    index++;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstChar == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>    index++;<br>    sign = -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 数字</span><br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (index&lt;len)&#123;<br>    <span class="hljs-keyword">char</span> currChar = charArray[index];<br>    <span class="hljs-keyword">if</span> (currChar&gt;<span class="hljs-string">&#x27;9&#x27;</span>||currChar&lt;<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断乘10以后是否越界</span><br>    <span class="hljs-keyword">if</span> (ans &gt; Integer.MAX_VALUE /<span class="hljs-number">10</span> || (ans==Integer.MAX_VALUE/<span class="hljs-number">10</span> &amp;&amp; (currChar - <span class="hljs-string">&#x27;0&#x27;</span>)&gt;Integer.MAX_VALUE%<span class="hljs-number">10</span>))&#123;<br>      <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ans &lt; Integer.MIN_VALUE / <span class="hljs-number">10</span> || (ans==Integer.MIN_VALUE/<span class="hljs-number">10</span> &amp;&amp; (currChar - <span class="hljs-string">&#x27;0&#x27;</span>)&gt;-(Integer.MIN_VALUE%<span class="hljs-number">10</span>)))&#123;<br>      <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>    &#125;<br>    <span class="hljs-comment">// 合法情况下，每一步都把符号为乘进去</span><br>    ans = ans*<span class="hljs-number">10</span> + sign * (currChar - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    index++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2039_网络空闲的时刻</title>
    <link href="/2022/03/20/2039-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB/"/>
    <url>/2022/03/20/2039-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示服务器 ui 和 vi 之间有一条信息线路，在 <strong>一秒</strong> 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 patience 。</p><p>题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p><p>编号为 <strong>0</strong> 的服务器是 <strong>主</strong> 服务器，其他服务器为 <strong>数据</strong> 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 <strong>最优</strong> 线路传输，也就是说每个信息都会以 <strong>最少时间</strong> 到达主服务器。主服务器会处理 <strong>所有</strong> 新到达的信息并 立即 按照每条信息来时的路线 <strong>反方向</strong> 发送回复信息。</p><p>在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，<strong>每</strong> 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p><p>如果还没收到任何回复信息，那么该服务器会周期性 <strong>重发</strong> 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。<br>否则，该数据服务器 不会重发 信息。<br><strong>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。</strong></p><p>请返回计算机网络变为 <strong>空闲</strong> 状态的 <strong>最早秒数</strong> 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220320113444.png" alt="example 1"></p><blockquote><p><strong>输入</strong>：edges = [[0,1],[1,2]], patience = [0,2,1]<br><strong>输出</strong>：8<br><strong>解释</strong>：<br>0 秒最开始时，</p><ul><li>数据服务器 1 给主服务器发出信息（用 1A 表示）。</li><li>数据服务器 2 给主服务器发出信息（用 2A 表示）。</li></ul><p>1 秒时，</p><ul><li>信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。</li><li>数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。</li><li>数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。</li></ul><p>2 秒时，</p><ul><li>回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。</li><li>信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。</li><li>服务器 2 重发一条信息（用 2C 表示）。<br>…<br>4 秒时，</li><li>回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。<br>…<br>7 秒时，回复信息 2D 到达服务器 2 。</li></ul><p>从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。<br>所以第 8 秒是网络变空闲的最早时刻。</p></blockquote><p>示例二：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220320113408.png" alt="example 2"></p><blockquote><p><strong>输入</strong>：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]<br><strong>输出</strong>：3<br><strong>解释</strong>：数据服务器 1 和 2 第 2 秒初收到回复信息。<br>从第 3 秒开始，网络变空闲。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>n == patience.length</li><li>2 &lt;= n &lt;= 105</li><li>patience[0] == 0</li><li>对于 1 &lt;= i &lt; n ，满足 1 &lt;= patience[i] &lt;= 105</li><li>1 &lt;= edges.length &lt;= min(105, n * (n - 1) / 2)</li><li>edges[i].length == 2</li><li>0 &lt;= ui, vi &lt; n</li><li>ui != vi</li><li>不会有重边。</li><li>每个服务器都直接或间接与别的服务器相连。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>选择最短距离到达主服务器，可以考虑广度优点算法，网络的最早空闲时间为各个节点中最晚的空闲时间</p><p>先用 List 数组存储无向图，同时用一个 boolean 数组记录访问状态，防止重复访问</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = patience.length;<br>List&lt;Integer&gt;[] adj = <span class="hljs-keyword">new</span> List[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  adj[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>&#125;<br><span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge:edges)&#123;<br>  adj[edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>  adj[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行广度优先算法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>queue.offer(<span class="hljs-number">0</span>);<br>visited[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">int</span> dist = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>  <span class="hljs-keyword">int</span> size = queue.size();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>    <span class="hljs-keyword">int</span> curr = queue.poll();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v:adj[curr])&#123;<br>      <span class="hljs-comment">// 遍历每个节点的可达节点</span><br>      <span class="hljs-keyword">if</span> (visited[v])&#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      queue.offer(v);<br>    &#125;<br>  &#125;<br>  dist++;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>当每个节点和主服务器的距离 dist 符合 $2 * dist &lt;= patience[i]$ 时，此节点还未发送第二条消息就收到了回复，所以空闲时间为 $2 * dist + 1$</li><li>当节点与主服务器的距离符合 $2*dist&gt;patience[i]$ 时，还未收到第一条消息的回复就要发送第二条消息，在收到第一条回复前会发送 $\lfloor \frac{2\times dist -1}{patience[i]} \rfloor$ 次消息，最后一次发送消息的时间为 $patience[v]\times\lfloor \frac{2\times dist -1}{patience[v]} \rfloor$ ，节点每次发送消息会经过 $2 \times dist$ 的时间收到回复，所以节点最后一次收到回复的时间为 $patience[v]\times\lfloor \frac{2\times dist -1}{patience[v]} \rfloor + 2 \times dist$ ，所以空闲时间为 $patience[v]\times\lfloor \frac{2\times dist -1}{patience[v]} \rfloor + 2 \times dist + 1$ </li></ul><p>可以对结果进行合并，当 $2\times dist \le patience[i]$ 时，$\lfloor \frac{2\times dist -1}{patience[i]} \rfloor$ 刚好为 0 ，所以变为空闲的时间为 $patience[v]\times\lfloor \frac{2\times dist -1}{patience[v]} \rfloor + 2 \times dist + 1$</p><p>最终解答如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">networkBecomesIdle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] edges, <span class="hljs-keyword">int</span>[] patience)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> n = patience.length;<br>  List&lt;Integer&gt;[] adj = <span class="hljs-keyword">new</span> List[n];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    adj[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  &#125;<br>  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge:edges)&#123;<br>    adj[edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>    adj[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>  &#125;<br>  Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>  queue.offer(<span class="hljs-number">0</span>);<br>  visited[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">int</span> dist = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>    <span class="hljs-keyword">int</span> size = queue.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>      <span class="hljs-keyword">int</span> curr = queue.poll();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v:adj[curr])&#123;<br>        <span class="hljs-keyword">if</span> (visited[v])&#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        queue.offer(v);<br>        <span class="hljs-comment">// 合并后的结果</span><br>        <span class="hljs-keyword">int</span> time = patience[v]*((<span class="hljs-number">2</span>*dist-<span class="hljs-number">1</span>)/patience[v])+<span class="hljs-number">2</span>*dist+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 取最大值返回</span><br>        ans = Math.max(ans,time);<br>        <span class="hljs-comment">// 更新访问状态</span><br>        visited[v] = <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 更新当前距离</span><br>    dist++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1028_从先序遍历还原二叉树</title>
    <link href="/2022/03/19/1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/03/19/1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们从二叉树的根节点 root 开始进行深度优先搜索。</p><p>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。</p><p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p><p>给出遍历输出 S，还原树并返回其根节点 root。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220319180127.png" alt="img"></p><blockquote><p><strong>输入</strong>：”1-2–3–4-5–6–7”<br><strong>输出</strong>：[1,2,5,3,4,6,7]</p></blockquote><p>示例二：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220319180110.png" alt="img"></p><blockquote><p><strong>输入</strong>：”1-2–3—4-5–6—7”<br><strong>输出</strong>：[1,2,5,3,null,6,null,4,null,7]</p></blockquote><p>示例三：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220319180058.png" alt="img"></p><blockquote><p><strong>输入</strong>：”1-401–349—90–88”<br><strong>输出</strong>：[1,401,null,349,88,90]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>原始树中的节点数介于 <code>1</code> 和 <code>1000</code> 之间。</li><li>每个节点的值介于 <code>1</code> 和 <code>10 ^ 9</code> 之间。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>基本思路是按照先序遍历的顺序创建二叉树，每次都判断深度，当深度不一致时，就回溯</p><p>寻找连续的 - 和连续数字：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>, nextlevel=<span class="hljs-number">0</span>,index;<br>  TreeNode node = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// 从 start 开始遍历字符串</span><br>  <span class="hljs-keyword">for</span>(index = start; index&lt;traversal.length();index++)&#123;<br>    <span class="hljs-comment">// 遇到 - ，则 nextlevel增加1</span><br>    <span class="hljs-keyword">if</span>(traversal.charAt(index)==<span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>      nextlevel++;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-comment">// 遇到字符则将值存储起来</span><br>      <span class="hljs-keyword">while</span>(index&lt;traversal.length() &amp;&amp; traversal.charAt(index)!=<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>        val = val*<span class="hljs-number">10</span>+traversal.charAt(index)-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        index++;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>当当前 level 等于 nextlevel 时，说明此时处理的内容为本层节点</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(level == nextlevel)&#123;<br>    node = <span class="hljs-keyword">new</span> TreeNode();<br>    node.val = val;<br>    start = index;<br>  <span class="hljs-comment">// 先左后右</span><br>    node.left = dfs(level+<span class="hljs-number">1</span>, traversal);<br>    node.right = dfs(level+<span class="hljs-number">1</span>, traversal);<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>组合起来</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 记录当前访问到字符串的位置</span><br><span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">recoverFromPreorder</span><span class="hljs-params">(String traversal)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,traversal);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, String traversal)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>, nextlevel=<span class="hljs-number">0</span>,index;<br>  TreeNode node = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">for</span>(index = start; index&lt;traversal.length();index++)&#123;<br>    <span class="hljs-keyword">if</span>(traversal.charAt(index)==<span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>      nextlevel++;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">while</span>(index&lt;traversal.length() &amp;&amp; traversal.charAt(index)!=<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>        val = val*<span class="hljs-number">10</span>+traversal.charAt(index)-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        index++;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 与当前深度不一致时，回溯</span><br>  <span class="hljs-keyword">if</span>(level == nextlevel)&#123;<br>    node = <span class="hljs-keyword">new</span> TreeNode();<br>    node.val = val;<br>    start = index;<br>    node.left = dfs(level+<span class="hljs-number">1</span>, traversal);<br>    node.right = dfs(level+<span class="hljs-number">1</span>, traversal);<br>  &#125;<br>  <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>827_最大人工岛</title>
    <link href="/2022/03/19/827-%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/"/>
    <url>/2022/03/19/827-%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。</p><p>返回执行此操作后，grid 中最大的岛屿面积是多少？</p><p>岛屿 由一组上、下、左、右四个方向相连的 1 形成。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>: grid = [[1, 0], [0, 1]]<br><strong>输出</strong>: 3<br><strong>解释</strong>: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>: grid = [[1, 1], [1, 0]]<br><strong>输出</strong>: 4<br><strong>解释</strong>: 将一格0变成1，岛屿的面积扩大为 4。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>: grid = [[1, 1], [1, 1]]<br><strong>输出</strong>: 4<br><strong>解释</strong>: 没有0可以让我们变成1，面积依然为 4。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>基本思路是先计算出所有岛屿的面积，在所有的格子上标记出岛屿的面积。然后搜索哪个海洋格子相邻的两个岛屿面积最大，但是为了防止同一片陆地被计算多次，所以给每个陆地打上不同的标记。</p><p>先 DFS 求出各陆地面积，同时用不同标号标记不同的陆地</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!isArea(grid,i,j) || grid[i][j]!=<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  grid[i][j] = index;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    +dfs(grid,i-<span class="hljs-number">1</span>,j,index)<br>    +dfs(grid,i+<span class="hljs-number">1</span>,j,index)<br>    +dfs(grid,i,j-<span class="hljs-number">1</span>,index)<br>    +dfs(grid,i,j+<span class="hljs-number">1</span>,index);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后遍历海洋，求出与其相连的最大陆地面积之和</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">plusArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, Map&lt;Integer,Integer&gt; map)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!isArea(grid,i,j) || grid[i][j]!=<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 用 set 去重，防止出现同一块陆地</span><br>  Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>  <span class="hljs-keyword">if</span> (isArea(grid,i-<span class="hljs-number">1</span>,j)&amp;&amp; grid[i-<span class="hljs-number">1</span>][j]&gt;=<span class="hljs-number">2</span>)&#123;<br>    set.add(grid[i-<span class="hljs-number">1</span>][j]);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (isArea(grid,i+<span class="hljs-number">1</span>,j)&amp;&amp; grid[i+<span class="hljs-number">1</span>][j]&gt;=<span class="hljs-number">2</span>)&#123;<br>    set.add(grid[i+<span class="hljs-number">1</span>][j]);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (isArea(grid,i,j-<span class="hljs-number">1</span>)&amp;&amp; grid[i][j-<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">2</span>)&#123;<br>    set.add(grid[i][j-<span class="hljs-number">1</span>]);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (isArea(grid,i,j+<span class="hljs-number">1</span>)&amp;&amp; grid[i][j+<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">2</span>)&#123;<br>    set.add(grid[i][j+<span class="hljs-number">1</span>]);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:set)&#123;<br>    size += map.get(num);<br>  &#125;<br>  <span class="hljs-comment">// 加上自身这块</span><br>  size +=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> size;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将代码组合起来</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestIsland</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> index = <span class="hljs-number">2</span>;<br>  Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>  <span class="hljs-comment">// 遍历求陆地面积</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">int</span> size = dfs(grid,i,j,index);<br>        maxSize = Math.max(maxSize,size);<br>        map.put(index,size);<br>        index+=<span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 遍历海洋，求相邻陆地面积最大的海洋</span><br>  <span class="hljs-keyword">int</span> maxSea = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">int</span> sea = plusArea(grid,i,j,map);<br>        maxSea = Math.max(sea,maxSea);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 可能没有海洋，返回最大值</span><br>  ans = Math.max(maxSize,maxSea);<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!isArea(grid,i,j) || grid[i][j]!=<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  grid[i][j] = index;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    +dfs(grid,i-<span class="hljs-number">1</span>,j,index)<br>    +dfs(grid,i+<span class="hljs-number">1</span>,j,index)<br>    +dfs(grid,i,j-<span class="hljs-number">1</span>,index)<br>    +dfs(grid,i,j+<span class="hljs-number">1</span>,index);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">plusArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, Map&lt;Integer,Integer&gt; map)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!isArea(grid,i,j) || grid[i][j]!=<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 用 set 去重，防止出现同一块陆地</span><br>  Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>  <span class="hljs-keyword">if</span> (isArea(grid,i-<span class="hljs-number">1</span>,j)&amp;&amp; grid[i-<span class="hljs-number">1</span>][j]&gt;=<span class="hljs-number">2</span>)&#123;<br>    set.add(grid[i-<span class="hljs-number">1</span>][j]);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (isArea(grid,i+<span class="hljs-number">1</span>,j)&amp;&amp; grid[i+<span class="hljs-number">1</span>][j]&gt;=<span class="hljs-number">2</span>)&#123;<br>    set.add(grid[i+<span class="hljs-number">1</span>][j]);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (isArea(grid,i,j-<span class="hljs-number">1</span>)&amp;&amp; grid[i][j-<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">2</span>)&#123;<br>    set.add(grid[i][j-<span class="hljs-number">1</span>]);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (isArea(grid,i,j+<span class="hljs-number">1</span>)&amp;&amp; grid[i][j+<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">2</span>)&#123;<br>    set.add(grid[i][j+<span class="hljs-number">1</span>]);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:set)&#123;<br>    size += map.get(num);<br>  &#125;<br>  <span class="hljs-comment">// 加上自身这块</span><br>  size +=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;grid.length &amp;&amp; j&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;grid[<span class="hljs-number">0</span>].length;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>432_全O_1_的数据结构</title>
    <link href="/2022/03/16/432-%E5%85%A8O-1-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/03/16/432-%E5%85%A8O-1-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。</p><p>实现 AllOne 类：</p><ul><li>AllOne() 初始化数据结构的对象。</li><li>inc(String key) 字符串 key 的计数增加 1 。如果数据结构中尚不存在 key ，那么插入计数为 1 的 key 。</li><li>dec(String key) 字符串 key 的计数减少 1 。如果 key 的计数在减少后为 0 ，那么需要将这个 key 从数据结构中删除。测试用例保证：在减少计数前，key 存在于数据结构中。</li><li>getMaxKey() 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 “” 。</li><li>getMinKey() 返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串 “” 。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong><br>[“AllOne”, “inc”, “inc”, “getMaxKey”, “getMinKey”, “inc”, “getMaxKey”, “getMinKey”]<br>[[], [“hello”], [“hello”], [], [], [“leet”], [], []]<br><strong>输出</strong><br>[null, null, null, “hello”, “hello”, null, “hello”, “leet”]</p><p><strong>解释</strong><br>AllOne allOne = new AllOne();<br>allOne.inc(“hello”);<br>allOne.inc(“hello”);<br>allOne.getMaxKey(); // 返回 “hello”<br>allOne.getMinKey(); // 返回 “hello”<br>allOne.inc(“leet”);<br>allOne.getMaxKey(); // 返回 “hello”<br>allOne.getMinKey(); // 返回 “leet”</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= key.length &lt;= 10</li><li>key 由小写英文字母组成</li><li>测试用例保证：在每次调用 dec 时，数据结构中总存在 key</li><li>最多调用 inc、dec、getMaxKey 和 getMinKey 方法 $5 * 10^4$ 次</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>采用双链表的形式存储，保证每次查询都是 O(1)</p><p>插入值时先从哈希表中查询，如果没有则创建插入到头节点后，如果存在则向后移动该节点的位置</p><p>删除值时从哈希表中取出要删除的节点，断开节点与前后的连接并减一，如果 value 变为0，则从 HashMap中删除，否则向前移动该节点的位置</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllOne</span> </span>&#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span></span>&#123;<br>        <span class="hljs-keyword">int</span> value;<br>        String str;<br>        ListNode pre;<br>        ListNode next;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value, String str)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.str = str;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span></span>&#123;<br>            value = value+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">()</span></span>&#123;<br>            value = value - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    ListNode head, tail;<br>    Map&lt;String, ListNode&gt; map;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AllOne</span><span class="hljs-params">()</span> </span>&#123;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        tail = <span class="hljs-keyword">new</span> ListNode(Integer.MAX_VALUE, <span class="hljs-string">&quot;&quot;</span>);<br>        tail.pre = head;<br>        head.next = tail;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(key))&#123;<br>            ListNode curNode = map.get(key);<br>            <span class="hljs-comment">// 将 curNode 删除</span><br>            curNode.next.pre = curNode.pre;<br>            curNode.pre.next = curNode.next;<br>            <span class="hljs-comment">// 加一</span><br>            curNode.inc();<br><br>            <span class="hljs-comment">// 寻找插入位置</span><br>            ListNode tempNode = curNode.next;<br>            <span class="hljs-comment">// 找到下一个等于 curNode.value 的位置</span><br>            <span class="hljs-keyword">while</span> (tempNode.value&lt;curNode.value)&#123;<br>                tempNode = tempNode.next;<br>            &#125;<br>            <span class="hljs-comment">// 插入到 tempNode 前面</span><br>            tempNode.pre.next = curNode;<br>            curNode.pre = tempNode.pre;<br>            curNode.next = tempNode;<br>            tempNode.pre = curNode;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            ListNode newNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>,key);<br>            <span class="hljs-comment">// 将 newNode 和前后连接</span><br>            newNode.pre = head;<br>            newNode.next = head.next;<br>            <span class="hljs-comment">// 将前后与 newNode 连接</span><br>            newNode.next.pre = newNode;<br>            head.next = newNode;<br>            <span class="hljs-comment">// 放入哈希表</span><br>            map.put(key,newNode);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        ListNode curNode = map.get(key);<br>        <span class="hljs-comment">// 将 curNode 删除</span><br>        curNode.pre.next = curNode.next;<br>        curNode.next.pre = curNode.pre;<br>        <span class="hljs-comment">// 减一</span><br>        curNode.dec();<br>        <span class="hljs-keyword">if</span> (curNode.value==<span class="hljs-number">0</span>)&#123;<br>            map.remove(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 寻找插入位置</span><br>        ListNode tempNode = curNode.pre;<br>        <span class="hljs-keyword">while</span> (tempNode.value&gt;curNode.value)&#123;<br>            tempNode = tempNode.pre;<br>        &#125;<br>        <span class="hljs-comment">// 插入到 tempNode 后面</span><br>        tempNode.next.pre = curNode;<br>        curNode.next = tempNode.next;<br>        curNode.pre = tempNode;<br>        tempNode.next = curNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMaxKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tail.pre==head)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tail.pre.str;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMinKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head.next==tail)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next.str;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>310_最小高度树</title>
    <link href="/2022/03/15/310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"/>
    <url>/2022/03/15/310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</p><p>给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。</p><p>可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。</p><p>请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。</p><p>树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220315142115.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：n = 4, edges = [[1,0],[1,2],[1,3]]<br><strong>输出</strong>：[1]<br><strong>解释</strong>：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。</p></blockquote><p>示例二：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220315142044.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]<br><strong>输出</strong>：[3,4]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= n &lt;= 2 * 104</li><li>edges.length == n - 1</li><li>0 &lt;= ai, bi &lt; n</li><li>ai != bi</li><li>所有 (ai, bi) 互不相同</li><li>给定的输入 保证 是一棵树，并且 不会有重复的边</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>直觉上，一棵树越靠「外面」的结点，越不可能把它作为根结点，如果这样做的话，可能树的高度是很高的，所以使用「剔除边缘结点」的策略。</p><p>对于小于 2 个节点的树，可以直接返回结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    ans.add(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>统计入度情况，生成连接图</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 入度数组</span><br><span class="hljs-keyword">int</span>[] inDegre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><span class="hljs-comment">// 存储edges</span><br>Set&lt;Integer&gt;[] adjs = <span class="hljs-keyword">new</span> Set[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  adjs[i] = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge:edges)&#123;<br>  adjs[edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>  adjs[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>  inDegre[edge[<span class="hljs-number">0</span>]]++;<br>  inDegre[edge[<span class="hljs-number">1</span>]]++;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>用队列记录入度为 1 的点</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 记录入度为1的点</span><br>Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  <span class="hljs-keyword">if</span> (inDegre[i]==<span class="hljs-number">1</span>)&#123;<br>    queue.add(i);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后迭代，直至节点数小于等于2</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-keyword">int</span> size = queue.size();<br>  <span class="hljs-comment">// 减小 n</span><br>  n-=size;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>    <span class="hljs-keyword">int</span> top = queue.poll();<br>    <span class="hljs-comment">// 将当前点标记为删除</span><br>    result[top] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// 把它和它的邻接节点入度减一</span><br>    inDegre[top] -=<span class="hljs-number">1</span>;<br>    Set&lt;Integer&gt; set = adjs[top];<br>    <span class="hljs-keyword">for</span> (Integer s:set)&#123;<br>      inDegre[s]-=<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (inDegre[s]==<span class="hljs-number">1</span>)&#123;<br>        queue.offer(s);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后遍历结果记录数组</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; result.length; i++) &#123;<br>  <span class="hljs-keyword">if</span> (!result[i])&#123;<br>    ans.add(i);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将解组合起来</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] edges)</span></span>&#123;<br>  List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      ans.add(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>  <span class="hljs-comment">// 入度数组</span><br>  <span class="hljs-keyword">int</span>[] inDegre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  <span class="hljs-comment">// 记录是否被 pass,如果 pass，则为 true</span><br>  <span class="hljs-keyword">boolean</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>  <span class="hljs-comment">// 存储edges</span><br>  Set&lt;Integer&gt;[] adjs = <span class="hljs-keyword">new</span> Set[n];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    adjs[i] = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge:edges)&#123;<br>    adjs[edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>    adjs[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>    inDegre[edge[<span class="hljs-number">0</span>]]++;<br>    inDegre[edge[<span class="hljs-number">1</span>]]++;<br>  &#125;<br>  <span class="hljs-comment">// 记录入度为1的点</span><br>  Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (inDegre[i]==<span class="hljs-number">1</span>)&#123;<br>      queue.add(i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">int</span> size = queue.size();<br>    n-=size;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>      <span class="hljs-keyword">int</span> top = queue.poll();<br>      result[top] = <span class="hljs-keyword">true</span>;<br>      <span class="hljs-comment">// 把它和它的邻接节点入度减一</span><br>      inDegre[top] -=<span class="hljs-number">1</span>;<br>      Set&lt;Integer&gt; set = adjs[top];<br>      <span class="hljs-keyword">for</span> (Integer s:set)&#123;<br>        inDegre[s]-=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (inDegre[s]==<span class="hljs-number">1</span>)&#123;<br>          queue.offer(s);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; result.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!result[i])&#123;<br>      ans.add(i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2044_统计按位或能得到最大值的子集数目</title>
    <link href="/2022/03/15/2044-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/03/15/2044-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。</p><p>如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。</p><p>对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR … OR a[a.length - 1]（下标从 0 开始）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：nums = [3,1]<br><strong>输出</strong>：2<br><strong>解释</strong>：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：</p><ul><li>[3]</li><li>[3,1]</li></ul></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：nums = [2,2,2]<br><strong>输出</strong>：7<br><strong>解释</strong>：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：nums = [3,2,1,5]<br><strong>输出</strong>：6<br><strong>解释</strong>：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：</p><ul><li>[3,5]</li><li>[3,1,5]</li><li>[3,2,5]</li><li>[3,2,1,5]</li><li>[2,5]</li><li>[2,1,5]</li></ul></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= nums.length &lt;= 16</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>所有元素做或运算的结果肯定是最大值，所以预先计算最大值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num:nums)&#123;<br>  max |= num;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因为每个位置都可选可不选，所以利用回溯来求解</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curIndex, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> curValue, <span class="hljs-keyword">int</span> max)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (curIndex==nums.length)&#123;<br>    <span class="hljs-keyword">return</span> curValue==max?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 返回选与不选当前项的结果之和</span><br>  <span class="hljs-keyword">return</span> dfs(curIndex+<span class="hljs-number">1</span>,nums,curValue|nums[curIndex],max) + dfs(curIndex+<span class="hljs-number">1</span>,nums,curValue,max);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以进行优化，比如当我们搜索到某个下标 i 时，如果计算结果等于最大值了，就没有必要继续往下搜索了，这时候后面的元素不管选还是不选，最终的结果一定是等于最大值的</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> or, <span class="hljs-keyword">int</span> max)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (or == max) &#123;<br>    <span class="hljs-comment">// 等于最大值了，没有继续搜索的必要，直接计算有多少种方案</span><br>    ans += <span class="hljs-number">1</span> &lt;&lt; (nums.length - i);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (i == nums.length) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 当前元素选或者不选</span><br>  dfs(nums, i + <span class="hljs-number">1</span>, or | nums[i], max);<br>  dfs(nums, i + <span class="hljs-number">1</span>, or, max);<br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>297_二叉树的序列化与反序列化</title>
    <link href="/2022/03/15/297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/03/15/297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220315095311.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：root = [1,2,3,null,null,4,5]<br><strong>输出</strong>：[1,2,3,null,null,4,5]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>树中结点数在范围 <code>[0, 10^4]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>可以对节点进行遍历，只要采用同一种遍历方式，就能保证序列化与反序列化一致</p><p>通过传递同一个 StringBuilder 对象来进行遍历，遇到 null 节点则 append <code>null,</code>,否则添加 <code>node.val,</code>。使用逗号分隔。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Encodes a tree to a single string.</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>  StringBuilder res = ser_help(root, <span class="hljs-keyword">new</span> StringBuilder());<br>  <span class="hljs-keyword">return</span> res.toString();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">ser_help</span><span class="hljs-params">(TreeNode root, StringBuilder str)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<br>    str.append(<span class="hljs-string">&quot;null,&quot;</span>);<br>    <span class="hljs-keyword">return</span> str;<br>  &#125;<br>  str.append(root.val);<br>  str.append(<span class="hljs-string">&quot;,&quot;</span>);<br>  str = ser_help(root.left,str);<br>  str = ser_help(root.right,str);<br>  <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>反序列化时，先将 String 转化为 List</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String[] str_word = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>List&lt;String&gt; list_word = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(str_word));<br></code></pre></div></td></tr></table></figure><p>然后按照先序遍历的顺序进行遍历，每次访问完都将访问过的元素移除，防止出错</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deser_help</span><span class="hljs-params">(List&lt;String&gt; li)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (li.get(<span class="hljs-number">0</span>).equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>    li.remove(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br>  TreeNode res = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(li.get(<span class="hljs-number">0</span>)));<br>  li.remove(<span class="hljs-number">0</span>);<br>  res.left = deser_help(li);<br>  res.right = deser_help(li);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>211_添加与搜索单词-数据结构设计</title>
    <link href="/2022/03/14/211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/03/14/211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p><p>实现词典类 WordDictionary ：</p><ul><li>WordDictionary() 初始化词典对象</li><li>void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配</li><li>bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 ‘.’ ，每个 . 都可以表示任何一个字母。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：<br>[“WordDictionary”,”addWord”,”addWord”,”addWord”,”search”,”search”,”search”,”search”]<br>[[],[“bad”],[“dad”],[“mad”],[“pad”],[“bad”],[“.ad”],[“b..”]]<br><strong>输出</strong>：<br>[null,null,null,null,false,true,true,true]</p><p><strong>解释</strong>：<br>WordDictionary wordDictionary = new WordDictionary();<br>wordDictionary.addWord(“bad”);<br>wordDictionary.addWord(“dad”);<br>wordDictionary.addWord(“mad”);<br>wordDictionary.search(“pad”); // return False<br>wordDictionary.search(“bad”); // return True<br>wordDictionary.search(“.ad”); // return True<br>wordDictionary.search(“b..”); // return True</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= word.length &lt;= 500</li><li>addWord 中的 word 由小写英文字母组成</li><li>search 中的 word 由 ‘.’ 或小写英文字母组成</li><li>最多调用 50000 次 addWord 和 search</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>本题要进行插入和搜索，可以使用前缀树来实现，前缀树类实现如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Trie[] children;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>&#123;<br>        children = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span></span>&#123;<br>        Trie node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;word.length();i++)&#123;<br>            <span class="hljs-keyword">char</span> ch = word.charAt(i);<br>            <span class="hljs-keyword">int</span> index = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index]==<span class="hljs-keyword">null</span>)&#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> Trie();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Trie[] getChildren()&#123;<br>        <span class="hljs-keyword">return</span> children;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> isEnd;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>深度优先遍历字符</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 参数分别为 单词、当前下标、当前前缀节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String word, <span class="hljs-keyword">int</span> index, Trie node)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (index==word.length())&#123;<br>    <span class="hljs-keyword">return</span> node.isEnd();<br>  &#125;<br>  <span class="hljs-keyword">char</span> ch = word.charAt(index);<br>  <span class="hljs-keyword">if</span> (Character.isLetter(ch))&#123;<br>    <span class="hljs-keyword">int</span> childIndex = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    Trie child = node.getChildren()[childIndex];<br>    <span class="hljs-keyword">if</span> (child!=<span class="hljs-keyword">null</span> &amp;&amp; dfs(word,index+<span class="hljs-number">1</span>,child))&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>      Trie child = node.getChildren()[i];<br>      <span class="hljs-keyword">if</span> (child!=<span class="hljs-keyword">null</span>&amp;&amp;dfs(word,index+<span class="hljs-number">1</span>,child))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>组合起来：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordDictionary</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Trie root;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WordDictionary</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> Trie();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWord</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        root.insert(word);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dfs(word, <span class="hljs-number">0</span>, root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String word, <span class="hljs-keyword">int</span> index, Trie node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (index==word.length())&#123;<br>            <span class="hljs-keyword">return</span> node.isEnd();<br>        &#125;<br>        <span class="hljs-keyword">char</span> ch = word.charAt(index);<br>        <span class="hljs-keyword">if</span> (Character.isLetter(ch))&#123;<br>            <span class="hljs-keyword">int</span> childIndex = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            Trie child = node.getChildren()[childIndex];<br>            <span class="hljs-keyword">if</span> (child!=<span class="hljs-keyword">null</span> &amp;&amp; dfs(word,index+<span class="hljs-number">1</span>,child))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                Trie child = node.getChildren()[i];<br>                <span class="hljs-keyword">if</span> (child!=<span class="hljs-keyword">null</span>&amp;&amp;dfs(word,index+<span class="hljs-number">1</span>,child))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Trie[] children;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>&#123;<br>        children = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];<br>        isEnd = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span></span>&#123;<br>        Trie node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;word.length();i++)&#123;<br>            <span class="hljs-keyword">char</span> ch = word.charAt(i);<br>            <span class="hljs-keyword">int</span> index = ch - <span class="hljs-string">&#x27;&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index]==<span class="hljs-keyword">null</span>)&#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> Trie();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Trie[] getChildren()&#123;<br>        <span class="hljs-keyword">return</span> children;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> isEnd;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1462_课程表IV</title>
    <link href="/2022/03/14/1462-%E8%AF%BE%E7%A8%8B%E8%A1%A8IV/"/>
    <url>/2022/03/14/1462-%E8%AF%BE%E7%A8%8B%E8%A1%A8IV/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你总共需要上 n 门课，课程编号依次为 0 到 n-1 。</p><p>有的课会有直接的先修课程，比如如果想上课程 0 ，你必须先上课程 1 ，那么会以 [1,0] 数对的形式给出先修课程数对。</p><p>给你课程总数 n 和一个直接先修课程数对列表 prerequisite 和一个查询对列表 queries 。</p><p>对于每个查询对 queries[i] ，请判断 queries[i][0] 是否是 queries[i][1] 的先修课程。</p><p>请返回一个布尔值列表，列表中每个元素依次分别对应 queries 每个查询对的判断结果。</p><p>注意：如果课程 a 是课程 b 的先修课程且课程 b 是课程 c 的先修课程，那么课程 a 也是课程 c 的先修课程。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：n = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]<br><strong>输出</strong>：[false,true]<br><strong>解释</strong>：课程 0 不是课程 1 的先修课程，但课程 1 是课程 0 的先修课程。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：n = 2, prerequisites = [], queries = [[1,0],[0,1]]<br><strong>输出</strong>：[false,false]<br><strong>解释</strong>：没有先修课程对，所以每门课程之间是独立的。</p></blockquote><p>示例三：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220314104651.png" alt="img"></p><blockquote><p><strong>输入</strong>：n = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]<br><strong>输出</strong>：[true,true]</p></blockquote><p>示例四：</p><blockquote><p><strong>输入</strong>：n = 3, prerequisites = [[1,0],[2,0]], queries = [[0,1],[2,0]]<br><strong>输出</strong>：[false,true]</p></blockquote><p>示例五：</p><blockquote><p><strong>输入</strong>：n = 5, prerequisites = [[0,1],[1,2],[2,3],[3,4]], queries = [[0,4],[4,0],[1,3],[3,0]]<br><strong>输出</strong>：[true,false,true,false]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$2 &lt;= n &lt;= 100$</li><li>$0 &lt;= prerequisite.length &lt;= (n * (n - 1) / 2)$</li><li>$0 &lt;= prerequisite[i][0], prerequisite[i][1] &lt; n$</li><li>$prerequisite[i][0] != prerequisite[i][1]$</li><li>先修课程图中没有环。</li><li>先修课程图中没有重复的边。</li><li>$1 &lt;= queries.length &lt;= 10^4$</li><li>$queries[i][0] != queries[i][1]$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>用 floyd 算法构建连接图，刷新每个中转点的入度点和出度点的连通性</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span>[][] isConnected = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[numCourses][numCourses];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] pre:prerequisites)&#123;<br>  isConnected[pre[<span class="hljs-number">0</span>]][pre[<span class="hljs-number">1</span>]] = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m&lt;numCourses; m++)&#123; <span class="hljs-comment">// 中间节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>; s&lt;numCourses; s++)&#123; <span class="hljs-comment">// 开始节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> e = <span class="hljs-number">0</span>; e&lt;numCourses; e++) &#123; <span class="hljs-comment">//结束节点</span><br>      <span class="hljs-keyword">if</span> (isConnected[s][e]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (isConnected[s][m] &amp;&amp; isConnected[m][e]) isConnected[s][e] = <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后遍历查询数组，输出结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title">checkIfPrerequisite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites, <span class="hljs-keyword">int</span>[][] queries)</span></span>&#123;<br>  <span class="hljs-keyword">boolean</span>[][] isConnected = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[numCourses][numCourses];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] pre:prerequisites)&#123;<br>    isConnected[pre[<span class="hljs-number">0</span>]][pre[<span class="hljs-number">1</span>]] = <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m&lt;numCourses; m++)&#123; <span class="hljs-comment">// 中间节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>; s&lt;numCourses; s++)&#123; <span class="hljs-comment">// 开始节点</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> e = <span class="hljs-number">0</span>; e&lt;numCourses; e++) &#123; <span class="hljs-comment">//结束节点</span><br>        <span class="hljs-keyword">if</span> (isConnected[s][e]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (isConnected[s][m] &amp;&amp; isConnected[m][e]) isConnected[s][e] = <span class="hljs-keyword">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  List&lt;Boolean&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] query:queries)&#123;<br>    ans.add(isConnected[query[<span class="hljs-number">0</span>]][query[<span class="hljs-number">1</span>]]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>630_课程表III</title>
    <link href="/2022/03/14/630-%E8%AF%BE%E7%A8%8B%E8%A1%A8III/"/>
    <url>/2022/03/14/630-%E8%AF%BE%E7%A8%8B%E8%A1%A8III/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>这里有 n 门不同的在线课程，按从 1 到 n 编号。给你一个数组 courses ，其中 courses[i] = [durationi, lastDayi] 表示第 i 门课将会 持续 上 durationi 天课，并且必须在不晚于 lastDayi 的时候完成。</p><p>你的学期从第 1 天开始。且不能同时修读两门及两门以上的课程。</p><p>返回你最多可以修读的课程数目。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]<br><strong>输出</strong>：3<br><strong>解释</strong>：<br>这里一共有 4 门课程，但是你最多可以修 3 门：<br>首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。<br>第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。<br>第三，修第 2 门课，耗时 200 天，在第 1300 天完成。<br>第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：courses = [[1,2]]<br><strong>输出</strong>：1</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：courses = [[3,2],[4,3]]<br><strong>输出</strong>：0</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$1 &lt;= courses.length &lt;= 10^4$</li><li>$1 &lt;= duration_i, lastDay_i &lt;= 10^4$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>整体思路就是： <strong>优先修读dll近的 放弃的时候则放弃修读时间长的</strong> 给之后的课程留更多的时间</p><p>可以用优先队列模拟这个过程；堆顶放修读时间最长的课程；按照ddl升序排列依次修读。<br>如果可以修读，更新总修读时间。<br>如果不可修读，看花费最长时间的课程是哪门，我们把它替换掉即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">scheduleCourse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] courses)</span></span>&#123;<br>  <span class="hljs-comment">// 按照截止时间排序，然后按照持续时间排序</span><br>  <span class="hljs-comment">// 优先截止时间早，持续时间短的</span><br>  Arrays.sort(courses,(arr1, arr2)-&gt;arr1[<span class="hljs-number">1</span>]==arr2[<span class="hljs-number">1</span>]?arr1[<span class="hljs-number">0</span>]-arr2[<span class="hljs-number">0</span>]:arr1[<span class="hljs-number">1</span>]-arr2[<span class="hljs-number">1</span>]);<br>  <span class="hljs-comment">// 优先队列</span><br>  PriorityQueue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b-a);<br>  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] course:courses) &#123;<br>    <span class="hljs-keyword">int</span> time = course[<span class="hljs-number">0</span>], end = course[<span class="hljs-number">1</span>];<br>    sum+=time;<br>    q.add(time);<br>    <span class="hljs-keyword">if</span> (sum&gt;end) sum-=q.poll();<br>  &#125;<br>  <span class="hljs-keyword">return</span> q.size();<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>393_UTF8编码验证</title>
    <link href="/2022/03/13/393-UTF8%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/"/>
    <url>/2022/03/13/393-UTF8%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个表示数据的整数数组 data ，返回它是否为有效的 UTF-8 编码。</p><p>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：</p><p>对于 1 字节 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。<br>对于 n 字节 的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。<br>这是 UTF-8 编码的工作方式：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220313150000.png" alt="image-20220313150000496"></p><p>注意：输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：data = [197,130,1]<br><strong>输出</strong>：true<br><strong>解释</strong>：数据表示字节序列:11000101 10000010 00000001。<br>这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：data = [235,140,4]<br><strong>输出</strong>：false<br><strong>解释</strong>：数据表示 8 位的序列: 11101011 10001100 00000100.<br>前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。<br>下一个字节是开头为 10 的延续字节，这是正确的。<br>但第二个延续字节不以 10 开头，所以是不符合规则的。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= data.length &lt;= 2 * 10^4</code></li><li><code>0 &lt;= data[i] &lt;= 255</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题只要找到符合编码规则的值范围即可</p><p>1 字节字符：0xxxxxxx （0-127）</p><p>2 字节字符：110xxxxx （192-223）10xxxxxx （128-191）</p><p>3 字节字符：1110xxxx （224-239）10xxxxxx （128-191） 10xxxxxx （128-191）</p><p>4 字节字符：11110xxx （240-247） 10xxxxxx （128-191） 10xxxxxx （128-191） 10xxxxxx （128-191）</p><p>然后对数组进行遍历判断即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validUtf8</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] data)</span></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (data[i]&lt;<span class="hljs-number">128</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (data[i]&lt;<span class="hljs-number">192</span>||data[i]&gt;<span class="hljs-number">247</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (data[i]&lt;<span class="hljs-number">224</span>)&#123;<br>      <span class="hljs-keyword">if</span> (i+<span class="hljs-number">2</span>&gt;data.length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">if</span> (data[i+<span class="hljs-number">1</span>]&lt;<span class="hljs-number">128</span>||data[i+<span class="hljs-number">1</span>]&gt;<span class="hljs-number">192</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      i++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i]&lt;<span class="hljs-number">240</span>)&#123;<br>      <span class="hljs-keyword">if</span> (i+<span class="hljs-number">3</span>&gt;data.length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (data[i+j]&lt;<span class="hljs-number">128</span>||data[i+j]&gt;<span class="hljs-number">192</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<br>      i+=<span class="hljs-number">2</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (i+<span class="hljs-number">4</span>&gt;data.length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">3</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (data[i+j]&lt;<span class="hljs-number">128</span>||data[i+j]&gt;<span class="hljs-number">192</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<br>      i+=<span class="hljs-number">3</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>210_课程表II</title>
    <link href="/2022/03/12/210-%E8%AF%BE%E7%A8%8B%E8%A1%A8II/"/>
    <url>/2022/03/12/210-%E8%AF%BE%E7%A8%8B%E8%A1%A8II/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。</p><ul><li>例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。</li></ul><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：numCourses = 2, prerequisites = [[1,0]]<br><strong>输出</strong>：[0,1]<br><strong>解释</strong>：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]<br><strong>输出</strong>：[0,2,1,3]<br><strong>解释</strong>：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。<br>因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：numCourses = 1, prerequisites = []<br><strong>输出</strong>：[0]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= numCourses &lt;= 2000</li><li>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</li><li>prerequisites[i].length == 2</li><li>0 &lt;= ai, bi &lt; numCourses</li><li>ai != bi</li><li>所有[ai, bi] 互不相同</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>将每门课看成一个节点。如果想要学习课程 A 之前必须完成课程 B，那么从 B 到 A 连接一条有向边。</p><p>所以先构建一个有向图，用栈来存储所有已经搜索完成的节点。</p><p>在每一轮的搜索搜索开始时，任取一个「未搜索」的节点开始进行深度优先搜索：</p><ul><li>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</li><li>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</li><li>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u, v) 之前的拓扑关系，以及不用进行任何操作。</li></ul><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// 存储有向图</span><br>    List&lt;List&lt;Integer&gt;&gt; edges;<br>    <span class="hljs-comment">// 标记每个节点的状态 0：未搜索 1：搜索中 2：已完成</span><br>    <span class="hljs-keyword">int</span>[] visited;<br>    <span class="hljs-comment">// 用数组模拟栈，下标0为栈顶</span><br>    <span class="hljs-keyword">int</span>[] result;<br>    <span class="hljs-comment">// 栈下标</span><br>    <span class="hljs-keyword">int</span> index;<br>    <span class="hljs-comment">// 判断是否有环</span><br>    <span class="hljs-keyword">boolean</span> valid = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findOrder(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites) &#123;<br>        edges = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            edges.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());<br>        &#125;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>        result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>        index = numCourses-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] prereq: prerequisites)&#123;<br>            edges.get(prereq[<span class="hljs-number">1</span>]).add(prereq[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 每次挑选一个 未搜索 节点，开始深度优先搜索</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;numCourses &amp;&amp; valid; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visited[i]==<span class="hljs-number">0</span>)&#123;<br>                dfs(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!valid)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">// 如果没有环，那么存在排序</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br>        <span class="hljs-comment">// 将节点标记为搜索中</span><br>        visited[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 搜索相邻节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v: edges.get(u))&#123;<br>            <span class="hljs-comment">// 如果未搜索 那么搜索相邻节点</span><br>            <span class="hljs-keyword">if</span> (visited[v]==<span class="hljs-number">0</span>)&#123;<br>                dfs(v);<br>                <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果搜索中 说明找到了环</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (visited[v]==<span class="hljs-number">1</span>)&#123;<br>                valid = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将节点标记为已完成</span><br>        visited[u] = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 将节点入栈</span><br>        result[index--] = u;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>133_克隆图</title>
    <link href="/2022/03/12/133-%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <url>/2022/03/12/133-%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 <code>val (int)</code> 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">public</span> List&lt;Node&gt; neighbors;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220312150045.png" alt="img"></p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>节点数不超过 100 。</li><li>每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。</li><li>无向图是一个简单图，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>使用深度优先搜索的方式进行拷贝，为了防止重复添加同一个节点，用 HashMap 来存储，key 为节点，value 为深拷贝的节点。</p><ol><li>从给定节点开始遍历图。如果某个节点已经被访问过，则返回其克隆图中的对应节点</li><li>如果当前访问的节点不在哈希表中，则创建它的克隆节点并存储在哈希表中</li><li>递归调用每个节点的邻接点。每个节点递归调用的次数等于邻接点的数量，每一次调用返回其对应邻接点的克隆节点，最终返回这些克隆邻接点的列表，将其放入对应克隆节点的邻接表中</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">HashMap&lt;Node, Node&gt; visited = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node node)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> node;<br>  <span class="hljs-comment">// 如果该节点已经被访问过，则直接从哈希表中取出对应的克隆节点返回</span><br>  <span class="hljs-keyword">if</span> (visited.containsKey(node))&#123;<br>    <span class="hljs-keyword">return</span> visited.get(node);<br>  &#125;<br>  <span class="hljs-comment">// 克隆节点</span><br>  Node cloneNode = <span class="hljs-keyword">new</span> Node(node.val, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>  visited.put(node, cloneNode);<br>  <span class="hljs-comment">// 遍历节点的邻居并更新克隆节点的邻居列表</span><br>  <span class="hljs-keyword">for</span> (Node neighbor: node.neighbors)&#123;<br>    cloneNode.neighbors.add(cloneGraph(neighbor));<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneNode;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>130_被围绕的区域</title>
    <link href="/2022/03/11/130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <url>/2022/03/11/130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220311162355.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：board = [[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”X”,”X”]]<br><strong>输出</strong>：[[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]]<br><strong>解释</strong>：被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：board = [[“X”]]<br><strong>输出</strong>：[[“X”]]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>解题思路：先深度优先遍历所有在边缘且为 O 的点，将 O 改成 -，然后再遍历所有点，将 O 改成 X ，将 - 改成 O。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> row, col;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (board == <span class="hljs-keyword">null</span> || board.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>  row = board.length;<br>  col = board[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>    dfs(board,i,<span class="hljs-number">0</span>);<br>    dfs(board,i,col-<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; col; i++) &#123;<br>    dfs(board,<span class="hljs-number">0</span>,i);<br>    dfs(board,row-<span class="hljs-number">1</span>,i);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>      <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>        board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= row || j &gt;= col || board[i][j] != <span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-keyword">return</span>;<br>  board[i][j] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>  dfs(board, i - <span class="hljs-number">1</span>, j);<br>  dfs(board, i + <span class="hljs-number">1</span>, j);<br>  dfs(board, i, j - <span class="hljs-number">1</span>);<br>  dfs(board, i, j + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2049_统计最高分的节点数目</title>
    <link href="/2022/03/11/2049-%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/03/11/2049-%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 <strong>parents[i] 是节点 i 的父节点</strong>。由于节点 0 是根，所以 <strong>parents[0] == -1</strong> 。</p><p>一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。</p><p>请你返回有 <strong>最高得分</strong> 节点的 <strong>数目</strong> 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220311101544.png" alt="example-1"></p><blockquote><p><strong>输入</strong>：parents = [-1,2,0,2,0]<br><strong>输出</strong>：3<br><strong>解释</strong>：</p><ul><li>节点 0 的分数为：3 * 1 = 3</li><li>节点 1 的分数为：4 = 4</li><li>节点 2 的分数为：1 * 1 * 2 = 2</li><li>节点 3 的分数为：4 = 4</li><li>节点 4 的分数为：4 = 4<br>最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。</li></ul></blockquote><p>示例二：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220311101506.png" alt="example-2"></p><blockquote><p><strong>输入</strong>：parents = [-1,2,0]<br><strong>输出</strong>：2<br><strong>解释</strong>：</p><ul><li>节点 0 的分数为：2 = 2</li><li>节点 1 的分数为：2 = 2</li><li>节点 2 的分数为：1 * 1 = 1<br>最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。</li></ul></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>n == parents.length</li><li>2 &lt;= n &lt;= 105</li><li>parents[0] == -1</li><li>对于 i != 0 ，有 0 &lt;= parents[i] &lt;= n - 1</li><li>parents 表示一棵二叉树。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>可以先用 $parents$ 数组统计出每个节点的子节点，然后使用深度优先搜索来计算以每个节点为根结点的子树的大小，同时计算每个节点的大小，作为深度优先搜索的返回值，最后统计最大分数出现的次数。</p><p>统计每个节点的子节点：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt;[] children;<br><br>children = <span class="hljs-keyword">new</span> List[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  children[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  <span class="hljs-keyword">int</span> p = parents[i];<br>  <span class="hljs-keyword">if</span> (p != -<span class="hljs-number">1</span>) &#123;<br>    children[p].add(i);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用深度优先搜索子树：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>  <span class="hljs-keyword">long</span> score = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 遍历node的子节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : children[node]) &#123;<br>    <span class="hljs-keyword">int</span> t = dfs(num);<br>    <span class="hljs-comment">// 分数 = 子树节点数乘积</span><br>    score *= t;<br>    <span class="hljs-comment">// 统计已计算节点数</span><br>    sum += t;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (node != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 非根节点需要乘以非子树节点个数</span><br>    <span class="hljs-comment">// 即 根节点 = 左子树*右子树</span><br>    <span class="hljs-comment">// 非根节点= 左子树 * 右子树 * 非此树</span><br>    score *= n - sum;<br>  &#125;<br>  <span class="hljs-comment">// 统计最高分数</span><br>  <span class="hljs-keyword">if</span> (maxScore == score) &#123;<br>    count++;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; maxScore) &#123;<br>    maxScore = score;<br>    count = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 返回当前子树的节点数</span><br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1314_矩阵区域和</title>
    <link href="/2022/03/10/1314-%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C/"/>
    <url>/2022/03/10/1314-%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和： </p><ul><li>i - k &lt;= r &lt;= i + k,</li><li>j - k &lt;= c &lt;= j + k 且</li><li>(r, c) 在矩阵内。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1<br><strong>输出</strong>：[[12,21,16],[27,45,33],[24,39,28]]</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2<br><strong>输出</strong>：[[45,45,45],[45,45,45],[45,45,45]]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>1 &lt;= m, n, k &lt;= 100</code></li><li><code>1 &lt;= mat[i][j] &lt;= 100</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>用前缀和的方法可以减少重复计算</p><p>首先计算前缀和 sum 数组， <code>sum[i, j] = sum[i-1][j]+sum[i][j-1]+mat[i-1][j-1]-sum[i-1][j-1]</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>    sum[i][j] = sum[i-<span class="hljs-number">1</span>][j]+sum[i][j-<span class="hljs-number">1</span>]-sum[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+mat[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后对每个位置计算和，区域 <code>[(x1,y1),(x2,y2)]</code>的和为 <code>sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1]</code></p><p>注意边界处理</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    <span class="hljs-keyword">int</span> x1 = Math.max(<span class="hljs-number">0</span>,i-k), y1 = Math.max(<span class="hljs-number">0</span>,j-k);<br>    <span class="hljs-keyword">int</span> x2 = Math.min(m,i+k+<span class="hljs-number">1</span>), y2 = Math.min(n,j+k+<span class="hljs-number">1</span>);<br>    ans[i][j] = sum[x2][y2] - sum[x2][y1] - sum[x1][y2] + sum[x1][y1];<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>组合起来</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] matrixBlockSum(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span> k)&#123;<br>  <span class="hljs-keyword">int</span> m = mat.length, n = mat[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>  <span class="hljs-keyword">int</span>[][] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>      sum[i][j] = sum[i-<span class="hljs-number">1</span>][j]+sum[i][j-<span class="hljs-number">1</span>]-sum[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+mat[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      <span class="hljs-keyword">int</span> x1 = Math.max(<span class="hljs-number">0</span>,i-k), y1 = Math.max(<span class="hljs-number">0</span>,j-k);<br>      <span class="hljs-keyword">int</span> x2 = Math.min(m,i+k+<span class="hljs-number">1</span>), y2 = Math.min(n,j+k+<span class="hljs-number">1</span>);<br>      ans[i][j] = sum[x2][y2] - sum[x2][y1] - sum[x1][y2] + sum[x1][y1];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1248_统计「优美子数组」</title>
    <link href="/2022/03/10/1248-%E7%BB%9F%E8%AE%A1%E3%80%8C%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%8D/"/>
    <url>/2022/03/10/1248-%E7%BB%9F%E8%AE%A1%E3%80%8C%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。</p><p>请返回这个数组中 「优美子数组」 的数目。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：nums = [1,1,2,1,1], k = 3<br><strong>输出</strong>：2<br><strong>解释</strong>：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：nums = [2,4,6], k = 1<br><strong>输出</strong>：0<br><strong>解释</strong>：数列中不包含任何奇数，所以不存在优美子数组。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：nums = [2,2,2,1,2,2,1,2,2,2], k = 2<br><strong>输出</strong>：16</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= nums.length &lt;= 50000</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>可以用滑动窗口的方法</p><ul><li><p>当 odd 不等于 k 的时候，移动右边界；</p></li><li><p>当 odd 等于 k 的时候，记录右边界位置，然后寻找右边界右边偶数的数量，移动左边界，寻找左边界右边偶数的数量，结果 += 右边界*左边界。然后左边界右移一位，odd减一，继续循环</p></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfSubarrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, odd = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right&lt;nums.length)&#123;<br>            <span class="hljs-keyword">if</span> (nums[right++]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>                odd++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (odd==k)&#123;<br>                <span class="hljs-keyword">int</span> temp = right;<br>                <span class="hljs-keyword">while</span> (right&lt;nums.length&amp;&amp;(nums[right]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>))&#123;<br>                    right++;<br>                &#125;<br>                <span class="hljs-keyword">int</span> rightCount = right - temp;<br>                <span class="hljs-keyword">int</span> leftCount  = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (nums[left]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                    leftCount++;<br>                    left++;<br>                &#125;<br>                ans += (leftCount+<span class="hljs-number">1</span>)*(rightCount+<span class="hljs-number">1</span>);<br>                left++;<br>                odd--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也可以采用前缀和的方法，可大大降低时间复杂度</p><p>计算前缀和数组 count，对于每个元素，计算当前的前缀和（到当前元素位置，数组中有多少个奇数）。然后双重循环统计 count[j] - count[i] ==  k 的个数。此时时间复杂度为 $O(N^2)$</p><p>可以利用 HashMap 降低时间复杂度，key 是 前缀和，value 是前缀和的个数，遍历原数组，每遍历一个数组，计算前缀和 sum，然后结果累加前缀和为 sum - k 的个数。（这里使用数组来记录，数组下标为前缀和，值为前缀和的个数）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfSubarrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>      <span class="hljs-comment">// 下标为前缀和（奇数的个数）, 值为此前缀和出现的次数</span><br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len+<span class="hljs-number">1</span>];<br>      <span class="hljs-comment">// 处理前缀和刚好等于 k 的情况</span><br>        count[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>          <span class="hljs-comment">// 计算前缀和更新到数组中</span><br>            sum+=num&amp;<span class="hljs-number">1</span>;<br>            count[sum]++;<br>          <span class="hljs-comment">// 符合条件 就在结果中累加</span><br>            <span class="hljs-keyword">if</span>(sum&gt;=k)&#123;<br>                ans+=count[sum-k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>798_得分最高的最小轮调</title>
    <link href="/2022/03/09/798-%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BD%AE%E8%B0%83/"/>
    <url>/2022/03/09/798-%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BD%AE%E8%B0%83/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 nums，我们可以将它按一个非负整数 k 进行轮调，这样可以使数组变为 <code>nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]] </code>的形式。此后，任何值小于或等于其索引的项都可以记作一分。</p><ul><li>例如，数组为 nums = [2,4,1,3,0]，我们按 k = 2 进行轮调后，它将变成 [1,3,0,2,4]。这将记为 3 分，因为 1 &gt; 0 [不计分]、3 &gt; 1 [不计分]、0 &lt;= 2 [计 1 分]、2 &lt;= 3 [计 1 分]，4 &lt;= 4 [计 1 分]。</li></ul><p>在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最小的下标 k 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：nums = [2,3,1,4,0]<br><strong>输出</strong>：3<br><strong>解释</strong>：<br>下面列出了每个 k 的得分：<br>k = 0,  nums = [2,3,1,4,0],    score 2<br>k = 1,  nums = [3,1,4,0,2],    score 3<br>k = 2,  nums = [1,4,0,2,3],    score 3<br>k = 3,  nums = [4,0,2,3,1],    score 4<br>k = 4,  nums = [0,2,3,1,4],    score 3<br>所以我们应当选择 k = 3，得分最高。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：nums = [1,3,0,2,4]<br><strong>输出</strong>：0<br><strong>解释</strong>：<br>nums 无论怎么变化总是有 3 分。<br>所以我们将选择最小的 k，即 0。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$1 &lt;= nums.length &lt;= 10^5$</li><li>$0 &lt;= nums[i] &lt; nums.length$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p><strong>当数字下标大于值时得分。</strong></p><p>对于给定的 nums[i]，能使得其得分的下标区间是明确的。基本上是位于右半边能得分，位于左半边不得分。</p><p>这意味着，能使其得分的「 k 区间 」也是明确的。只要计算出，在 k 从 0 到 n-1 的过程中，什么时候从得分变成失分，什么时候从失分变成得分。</p><ul><li>如果一开始就在得分圈，那么随着 k 的增加，（元素逐渐左移），会先失分，然后在轮回后得分，直到最后<ul><li>一开始得分，此时的次数为 0 </li><li>随着下标变小，对于某个nums[i]&lt;=i的数字而言，左移到下标为nums[i]的时候，仍然还可以得分；再多移动一格则不可得分，此时的次数为 <code>i - nums[i] + 1</code></li><li>轮回后会一直得分，此时的次数为 <code>i+1</code></li></ul></li><li>如果一开始在失分圈，那么随着 k 的增加，会在大轮回后得分，然后进入失分圈，直到最后<ul><li>从0开始到下标i的每个位置都不可得分</li><li>下标为<code>num[i]-i</code>时，不得分，此时的次数为 <code>n - (nums[i] - i) + 1</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>  <span class="hljs-keyword">if</span> (nums[i]&lt;=i)&#123;<br>    <span class="hljs-comment">// 在得分圈</span><br>    diff[<span class="hljs-number">0</span>]++;<span class="hljs-comment">// 不移动时 nums[i] 就产生贡献</span><br>    diff[(i-nums[i]+<span class="hljs-number">1</span>)%n]--;<span class="hljs-comment">// 左移 i-nums[i]+1 是，首次变为正，贡献取消</span><br>    diff[(i+<span class="hljs-number">1</span>)%n]++;<span class="hljs-comment">// 直到移动到坐标小于 0 的位置，变成移动到最右边，贡献产生</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 在失分圈</span><br>    diff[(i+<span class="hljs-number">1</span>)%n]++;<span class="hljs-comment">// 移动到最右边，贡献产生</span><br>    diff[(n-(nums[i]-i)+<span class="hljs-number">1</span>)%n]--;<span class="hljs-comment">// 值和下标相同的临界点，继续左移则贡献取消</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>整体思路就是遍历一遍每个数，通过直接计算得到产生分数贡献变化的分界点，将对应的移动值和变化记录下来。最后求总分的时候再遍历累计求和即可；相当于用积分恢复差分对应的原始值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bestRotation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> n = nums.length;<br>  <span class="hljs-keyword">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i]&lt;=i)&#123;<br>      <span class="hljs-comment">// nums[i] 初始位置可以得分</span><br>      diff[<span class="hljs-number">0</span>]++; <span class="hljs-comment">// 不移动时 nums[i】就产生贡献</span><br>      diff[(i-nums[i]+<span class="hljs-number">1</span>)%n]--; <span class="hljs-comment">// 左移 i-nums[i]+1 则差首次为正，贡献取消，继续左移也不会产生新贡献</span><br>      diff[(i+<span class="hljs-number">1</span>)%n]++; <span class="hljs-comment">// 直到移动到坐标小于0的位置，变成移动到最右边，贡献产生</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 一开始所在的位置不得分，左移没有用，只有移动到边界才会产生变化</span><br>      diff[(i+<span class="hljs-number">1</span>)%n]++;<br>      <span class="hljs-comment">// 继续向左移动，则会再次到达值和下标相同的临界点，继续左移一位则得分取消</span><br>      diff[(n-(nums[i]-i)+<span class="hljs-number">1</span>)%n]--;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m&lt;n; m++)&#123;<br>    score+=diff[m];<br>    <span class="hljs-keyword">if</span> (score&gt;max)&#123;<br>      max = score;<br>      ans = m;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1109_航班预订统计</title>
    <link href="/2022/03/09/1109-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/"/>
    <url>/2022/03/09/1109-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = $[first_i, last_i, seats_i]$ 意味着在从 $first_i$ 到 $last_i$ （包含 $first_i$ 和 $last_i$ ）的 每个航班 上预订了 $seats_i$ 个座位。</p><p>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5<br><strong>输出</strong>：[10,55,45,25,25]<br><strong>解释</strong>：<br>航班编号        1   2   3   4   5<br>预订记录 1 ：   10  10<br>预订记录 2 ：       20  20<br>预订记录 3 ：       25  25  25  25<br>总座位数：      10  55  45  25  25<br>因此，answer = [10,55,45,25,25]</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：bookings = [[1,2,10],[2,2,15]], n = 2<br><strong>输出</strong>：[10,25]<br><strong>解释</strong>：<br>航班编号        1   2<br>预订记录 1 ：   10  10<br>预订记录 2 ：       15<br>总座位数：      10  25<br>因此，answer = [10,25]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$1 &lt;= n &lt;= 2 * 10^4$</li><li>$1 &lt;= bookings.length &lt;= 2 * 10^4$</li><li>$bookings[i].length == 3$</li><li>$1 &lt;= first_i &lt;= last_i &lt;= n$</li><li>$1 &lt;= seats_i &lt;= 10^4$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题按照暴力解法可以解，但是时间比较久</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220309102623.png" alt="image-20220309102623532"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] corpFlightBookings(<span class="hljs-keyword">int</span>[][] bookings, <span class="hljs-keyword">int</span> n) &#123;<br>  <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] booking: bookings)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = booking[<span class="hljs-number">0</span>]; i &lt;=booking[<span class="hljs-number">1</span>]; i++) &#123;<br>      ans[i-<span class="hljs-number">1</span>] += booking[<span class="hljs-number">2</span>];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因为每次更新 ans 数组都要更新 booking[1]-booking[0]+1 次，所以考虑使用差分的方式减少更新次数，每次只修改变化的数，即每次只更新两个位置（<code>ans[booking[0]-1]</code> 和 <code>ans[booking[1]]</code>）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] corpFlightBookings(<span class="hljs-keyword">int</span>[][] bookings, <span class="hljs-keyword">int</span> n) &#123;<br>  <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] booking: bookings)&#123;<br>    ans[booking[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>]+=booking[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// 对右边界进行判断，越界则无需处理</span><br>    <span class="hljs-keyword">if</span> (booking[<span class="hljs-number">1</span>]&lt;n)&#123;<br>      ans[booking[<span class="hljs-number">1</span>]]-=booking[<span class="hljs-number">2</span>];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    ans[i]+=ans[i-<span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220309103008.png" alt="image-20220309103008049"></p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1588_所有奇数长度子数组的和</title>
    <link href="/2022/03/08/1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/"/>
    <url>/2022/03/08/1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。</p><p>子数组 定义为原数组中的一个连续子序列。</p><p>请你返回 arr 中 所有奇数长度子数组的和 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：arr = [1,4,2,5,3]<br><strong>输出</strong>：58<br><strong>解释</strong>：所有奇数长度子数组和它们的和为：<br>[1] = 1<br>[4] = 4<br>[2] = 2<br>[5] = 5<br>[3] = 3<br>[1,4,2] = 7<br>[4,2,5] = 11<br>[2,5,3] = 10<br>[1,4,2,5,3] = 15<br>我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：arr = [1,2]<br><strong>输出</strong>：3<br><strong>解释</strong>：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：arr = [10,11,12]<br><strong>输出</strong>：66</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= arr.length &lt;= 100</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>先求出前缀和</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; i++) &#123;<br>    sum[i] = sum[i-<span class="hljs-number">1</span>]+arr[i-<span class="hljs-number">1</span>];<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>然后遍历奇数长度的子数组，将结果加起来即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>; len&lt;=n; len+=<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l+len-<span class="hljs-number">1</span>&lt;n;l++)&#123;<br>    <span class="hljs-keyword">int</span> r = l+len-<span class="hljs-number">1</span>;<br>    ans += sum[r+<span class="hljs-number">1</span>] - sum[l];<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终题解</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumOddLengthSubarrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> n = arr.length;<br>  <span class="hljs-keyword">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; i++) &#123;<br>    sum[i] = sum[i-<span class="hljs-number">1</span>]+arr[i-<span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>; len&lt;=n; len+=<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l+len-<span class="hljs-number">1</span>&lt;n;l++)&#123;<br>      <span class="hljs-keyword">int</span> r = l+len-<span class="hljs-number">1</span>;<br>      ans += sum[r+<span class="hljs-number">1</span>] - sum[l];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>885_螺旋矩阵III</title>
    <link href="/2022/03/07/885-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5III/"/>
    <url>/2022/03/07/885-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5III/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始</p><p>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。</p><p>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 R * C 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：R = 1, C = 4, r0 = 0, c0 = 0<br><strong>输出</strong>：[[0,0],[0,1],[0,2],[0,3]]</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220307134618.png"></p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：R = 5, C = 6, r0 = 1, c0 = 4<br><strong>输出</strong>：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220307134547.png"></p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= R &lt;= 100</code></li><li><code>1 &lt;= C &lt;= 100</code></li><li><code>0 &lt;= r0 &lt; R</code></li><li><code>0 &lt;= c0 &lt; C</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>思路与螺旋矩阵II基本一致，只不过此题螺旋是由内向外，所以定义了最大边界，Left，Right，Upper，Bottom。</p><ul><li>向右到达右边界时，转向下，右边界扩大</li><li>向下到达下边界时，转向左，下边界扩大</li><li>向左到达左边界时，转向上，左边界扩大</li><li>向上到达上边界时，转向右，上边界扩大</li></ul><p>初始边界为初始位置上下左右加一</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] spiralMatrixIII(<span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span> rStart, <span class="hljs-keyword">int</span> cStart) &#123;<br>  <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rows*cols][<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>  <span class="hljs-keyword">int</span> row = rStart, col = cStart,num=<span class="hljs-number">1</span>,dirIndex = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> Left = cStart-<span class="hljs-number">1</span>, Right = cStart+<span class="hljs-number">1</span>, Upper = rStart-<span class="hljs-number">1</span>, Bottom = rStart+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (num&lt;=rows*cols)&#123;<br>    <span class="hljs-keyword">if</span> (row&gt;=<span class="hljs-number">0</span> &amp;&amp; row&lt;rows &amp;&amp; col&gt;=<span class="hljs-number">0</span> &amp;&amp; col&lt;cols)&#123;<br>      ans[num-<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;row,col&#125;;<br>      num++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dirIndex==<span class="hljs-number">0</span> &amp;&amp; col==Right)&#123; <span class="hljs-comment">// 到右边界</span><br>      dirIndex +=<span class="hljs-number">1</span>; <span class="hljs-comment">// 方向向右转为向下</span><br>      Right+=<span class="hljs-number">1</span>; <span class="hljs-comment">// 右边界右移</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (dirIndex==<span class="hljs-number">1</span>&amp;&amp; row==Bottom)&#123; <span class="hljs-comment">// 到下边界</span><br>      dirIndex +=<span class="hljs-number">1</span>; <span class="hljs-comment">// 方向由下转为向左</span><br>      Bottom+=<span class="hljs-number">1</span>;  <span class="hljs-comment">// 下边界下移</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (dirIndex==<span class="hljs-number">2</span> &amp;&amp; col==Left)&#123;  <span class="hljs-comment">// 到左边界</span><br>      dirIndex +=<span class="hljs-number">1</span>; <span class="hljs-comment">// 方向由向左转为向上</span><br>      Left-=<span class="hljs-number">1</span>;    <span class="hljs-comment">// 左边界左移</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (dirIndex==<span class="hljs-number">3</span> &amp;&amp; row==Upper) &#123; <span class="hljs-comment">// 到上边界</span><br>      dirIndex = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 方向由向上转为向右</span><br>      Upper -=<span class="hljs-number">1</span>;  <span class="hljs-comment">// 上边界上移</span><br>    &#125;<br>    row += directions[dirIndex][<span class="hljs-number">0</span>];<br>    col += directions[dirIndex][<span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>289_生命游戏</title>
    <link href="/2022/03/04/289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
    <url>/2022/03/04/289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><ol><li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li><li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li><li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li><li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li></ol><p>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220304142918.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]<br><strong>输出</strong>：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]</p></blockquote><p>示例二：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220304142855.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：board = [[1,1],[1,0]]<br><strong>输出</strong>：[[1,1],[1,1]]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 25</code></li><li><code>board[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>在解题过程中要注意不能修改原值，否则会对下一次的结果产生影响。这里通过复制 board 来解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> m = board.length, n = board[<span class="hljs-number">0</span>].length;<br><span class="hljs-keyword">int</span>[][] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>    copy[i][j] = board[i][j];<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于每个节点，都要遍历周围邻居，只处理符合条件的邻居，数出邻居数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] neighbors = &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">int</span> liveNeighbors = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; <span class="hljs-number">3</span>; l++) &#123;<br>    <span class="hljs-comment">// 排除自身</span><br>    <span class="hljs-keyword">if</span> (!(neighbors[k]==<span class="hljs-number">0</span> &amp;&amp; neighbors[l]==<span class="hljs-number">0</span>))&#123;<br>      <span class="hljs-keyword">int</span> r = i+neighbors[k];<br>      <span class="hljs-keyword">int</span> c = j+neighbors[l];<br>      <span class="hljs-comment">// 只处理符合条件的</span><br>      <span class="hljs-keyword">if</span> (r&lt;m&amp;&amp;r&gt;=<span class="hljs-number">0</span> &amp;&amp; c&lt;n&amp;&amp;c&gt;=<span class="hljs-number">0</span> &amp;&amp;copy[r][c]==<span class="hljs-number">1</span>)&#123;<br>        liveNeighbors+=<span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后根据规则修改原值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 规则 1 或 3</span><br><span class="hljs-keyword">if</span> (copy[i][j]==<span class="hljs-number">1</span>&amp;&amp;(liveNeighbors&lt;<span class="hljs-number">2</span>||liveNeighbors&gt;<span class="hljs-number">3</span>))&#123;<br>  board[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 规则 4</span><br><span class="hljs-keyword">if</span> (copy[i][j] == <span class="hljs-number">0</span> &amp;&amp; liveNeighbors==<span class="hljs-number">3</span>)&#123;<br>  board[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结合起来</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gameOfLife</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] board)</span></span>&#123;<br>  <span class="hljs-keyword">int</span>[] neighbors = &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-keyword">int</span> m = board.length, n = board[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-keyword">int</span>[][] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      copy[i][j] = board[i][j];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      <span class="hljs-keyword">int</span> liveNeighbors = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; <span class="hljs-number">3</span>; l++) &#123;<br>          <span class="hljs-keyword">if</span> (!(neighbors[k]==<span class="hljs-number">0</span> &amp;&amp; neighbors[l]==<span class="hljs-number">0</span>))&#123;<br>            <span class="hljs-keyword">int</span> r = i+neighbors[k];<br>            <span class="hljs-keyword">int</span> c = j+neighbors[l];<br>            <span class="hljs-keyword">if</span> (r&lt;m&amp;&amp;r&gt;=<span class="hljs-number">0</span> &amp;&amp; c&lt;n&amp;&amp;c&gt;=<span class="hljs-number">0</span> &amp;&amp;copy[r][c]==<span class="hljs-number">1</span>)&#123;<br>              liveNeighbors+=<span class="hljs-number">1</span>;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 规则 1 或 3</span><br>      <span class="hljs-keyword">if</span> (copy[i][j]==<span class="hljs-number">1</span>&amp;&amp;(liveNeighbors&lt;<span class="hljs-number">2</span>||liveNeighbors&gt;<span class="hljs-number">3</span>))&#123;<br>        board[i][j] = <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-comment">// 规则 4</span><br>      <span class="hljs-keyword">if</span> (copy[i][j] == <span class="hljs-number">0</span> &amp;&amp; liveNeighbors==<span class="hljs-number">3</span>)&#123;<br>        board[i][j] = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>59_螺旋矩阵II</title>
    <link href="/2022/03/04/59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
    <url>/2022/03/04/59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220304132350.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：n = 3<br><strong>输出</strong>：[[1,2,3],[8,9,4],[7,6,5]]</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：n = 1<br><strong>输出</strong>：[[1]]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>模拟矩阵，初始位置为左上角，初始方向为向右，超出边界或者到已访问过的位置时修改方向，按照右下左上的顺序改变方向。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n)&#123;<br>  <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>  <span class="hljs-keyword">int</span> max = n * n;<br>  <span class="hljs-keyword">int</span> curr = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 右、下、左、上方向</span><br>  <span class="hljs-keyword">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>  <span class="hljs-keyword">int</span> directionIndex = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (curr&lt;=max)&#123;<br>    ans[row][col] = curr;<br>    curr++;<br>    <span class="hljs-keyword">int</span> nextRow = row + directions[directionIndex][<span class="hljs-number">0</span>], nextCol = col + directions[directionIndex][<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 超出边界或者到已访问过的地方</span><br>    <span class="hljs-keyword">if</span> (nextRow&lt;<span class="hljs-number">0</span>||nextRow&gt;=n||nextCol&lt;<span class="hljs-number">0</span>||nextCol&gt;=n||ans[nextRow][nextCol]!=<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// 改变方向</span><br>      directionIndex = (directionIndex+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>    &#125;<br>    row = row + directions[directionIndex][<span class="hljs-number">0</span>];<br>    col = col + directions[directionIndex][<span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1409_查询带键的排列</title>
    <link href="/2022/03/04/1409-%E6%9F%A5%E8%AF%A2%E5%B8%A6%E9%94%AE%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2022/03/04/1409-%E6%9F%A5%E8%AF%A2%E5%B8%A6%E9%94%AE%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你根据以下规则处理所有待查项 queries[i]（从 i=0 到 i=queries.length-1）：</p><ul><li>一开始，排列 P=[1,2,3,…,m]。</li><li>对于当前的 i ，请你找出待查项 queries[i] 在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列 P 的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是 queries[i] 的查询结果。</li></ul><p>请你以数组形式返回待查数组  queries 的查询结果。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：queries = [3,1,2,1], m = 5<br><strong>输出</strong>：[2,1,2,1]<br><strong>解释</strong>：待查数组 queries 处理如下：<br>对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 2，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。<br>对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。<br>对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 2，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。<br>对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。<br>因此，返回的结果数组为 [2,1,2,1] 。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：queries = [4,1,2,2], m = 4<br><strong>输出</strong>：[3,1,2,0]</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：queries = [7,5,5,8,3], m = 8<br><strong>输出</strong>：[6,5,0,7,5]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= m &lt;= 10^3</code></li><li><code>1 &lt;= queries.length &lt;= m</code></li><li><code>1 &lt;= queries[i] &lt;= m</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>容易想到的方法就是对于每一个查询项，先在排列 P 中找到查询项的位置，将其加入答案，然后将其删除，再添加到头部。</p><p>具体的，可以用 List 实现。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] processQueries(<span class="hljs-keyword">int</span>[] queries, <span class="hljs-keyword">int</span> m)&#123;<br>  List&lt;Integer&gt; p = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    p.add(i);<br>  &#125;<br>  <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[queries.length];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;<br>    <span class="hljs-keyword">int</span> query = queries[i];<br>    <span class="hljs-keyword">int</span> pos = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>      <span class="hljs-keyword">if</span> (p.get(j)==query)&#123;<br>        pos = j;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    ans[i] = pos;<br>    p.remove(pos);<br>    p.add(<span class="hljs-number">0</span>,query);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>564_寻找最近的回文数</title>
    <link href="/2022/03/02/564-%E5%AF%BB%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2022/03/02/564-%E5%AF%BB%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个表示整数的字符串 <code>n</code> ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。</p><p>“最近的”定义为两个整数<strong>差的绝对值</strong>最小。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>: n = “123”<br><strong>输出</strong>: “121”</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>: n = “1”<br><strong>输出</strong>: “0”<br><strong>解释</strong>: 0 和 2是最近的回文，但我们返回最小的，也就是 0。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= n.length &lt;= 18</code></li><li><code>n</code> 只由数字组成</li><li><code>n</code> 不含前导 0</li><li><code>n</code> 代表在 <code>[1, 10^18 - 1]</code> 范围内的整数</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>寻找最近的回文数，最直观的想法就是将字符串的前半段复制到后半段<code>12345 =&gt; 12321  </code>，但是考虑到有的前半段复制过来不一定是最近的回文数，比如 <code>12499 =&gt; 12421 12499 =&gt;12521</code>, 很明显 12521 比 12421 离 12499 更近，所以将前半段加一或者减一的结果也考虑进来。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> t = Long.parseLong(n.substring(<span class="hljs-number">0</span>,(len+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> i = t-<span class="hljs-number">1</span>; i&lt;=t+<span class="hljs-number">1</span>; i++)&#123;<br>  <span class="hljs-keyword">long</span> temp = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(len%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 偶数长度的情况</span><br>    temp = getNum(i, <span class="hljs-keyword">true</span>);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 奇数长度的情况</span><br>    temp = getNum(i, <span class="hljs-keyword">false</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(temp!=curr)&#123;<br>    set.add(temp);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将前半段复制到后半段的函数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-keyword">long</span> k, <span class="hljs-keyword">boolean</span> isEven)</span></span>&#123;<br>  StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>  sb.append(k);<br>  <span class="hljs-keyword">int</span> index = isEven? sb.length()-<span class="hljs-number">1</span>:sb.length()-<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">while</span> (index&gt;=<span class="hljs-number">0</span>)&#123;<br>    sb.append(sb.charAt(index--));<br>  &#125;<br>  <span class="hljs-keyword">return</span> Long.parseLong(sb.toString());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于边界值也需要进行处理，如 99999 和 100001 也是回文数，可以单独进行检测</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> len = n.length();<br>Set&lt;Long&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>set.add((<span class="hljs-keyword">long</span>)Math.pow(<span class="hljs-number">10</span>,len-<span class="hljs-number">1</span>)-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 99999</span><br>set.add((<span class="hljs-keyword">long</span>)Math.pow(<span class="hljs-number">10</span>,len)+<span class="hljs-number">1</span>);      <span class="hljs-comment">// 100001</span><br></code></pre></div></td></tr></table></figure><p>最终代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">nearestPalindromic</span><span class="hljs-params">(String n)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> len = n.length();<br>  <span class="hljs-keyword">long</span> curr = Long.parseLong(n);<br>  Set&lt;Long&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>  set.add((<span class="hljs-keyword">long</span>)Math.pow(<span class="hljs-number">10</span>,len-<span class="hljs-number">1</span>)-<span class="hljs-number">1</span>); <br>  set.add((<span class="hljs-keyword">long</span>)Math.pow(<span class="hljs-number">10</span>,len)+<span class="hljs-number">1</span>);  <br>  <span class="hljs-keyword">long</span> t = Long.parseLong(n.substring(<span class="hljs-number">0</span>,(len+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = t-<span class="hljs-number">1</span>; i&lt;= t+<span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-keyword">long</span> temp = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (len%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// 如果为偶数长度</span><br>      temp = getNum(i,<span class="hljs-keyword">true</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      temp = getNum(i,<span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (temp!=curr) set.add(temp);<br>  &#125;<br><br>  <span class="hljs-keyword">long</span> ans = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i:set)&#123;<br>    <span class="hljs-keyword">if</span> (ans == -<span class="hljs-number">1</span>) ans = i;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Math.abs(i-curr)&lt;Math.abs(ans-curr)) ans = i;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Math.abs(i-curr)==Math.abs(ans-curr)&amp;&amp; i&lt;ans) ans = i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> String.valueOf(ans);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-keyword">long</span> k, <span class="hljs-keyword">boolean</span> isEven)</span></span>&#123;<br>  StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>  sb.append(k);<br>  <span class="hljs-keyword">int</span> index = isEven? sb.length()-<span class="hljs-number">1</span>:sb.length()-<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">while</span> (index&gt;=<span class="hljs-number">0</span>)&#123;<br>    sb.append(sb.charAt(index--));<br>  &#125;<br>  <span class="hljs-keyword">return</span> Long.parseLong(sb.toString());<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6_Z字型变换</title>
    <link href="/2022/03/01/6-Z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/"/>
    <url>/2022/03/01/6-Z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><p>​    P      A      H      N<br>​    A  P  L  S   I   I   G<br>​    Y      I       R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>​    <code>string convert(string s, int numRows);</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：s = “PAYPALISHIRING”, numRows = 3<br><strong>输出</strong>：”PAHNAPLSIIGYIR”</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：s = “PAYPALISHIRING”, numRows = 4<br><strong>输出</strong>：”PINALSIGYAHRPI”<br><strong>解释</strong>：<br>P        I        N<br>A    L  S    I  G<br>Y A     H R<br>P        I</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：s = “A”, numRows = 1<br><strong>输出</strong>：”A”</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由英文字母（小写和大写）、<code>&#39;,&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li><li><code>1 &lt;= numRows &lt;= 1000</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>采用模拟的办法</p><p>可以看到随着字符串的遍历，行号是先向下，到达行数后再向上，到 0 后再向下</p><p>于是采用了 <code>List&lt;StringBuilder&gt;</code>的结构来存储</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;StringBuilder&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>  list.add(<span class="hljs-keyword">new</span> StringBuilder());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>为了保证可以自行向下向上，使用 flag 来记录行数前进的方向。当 flag 遇到行数为 0 或者 numRows - 1 时，flag</p><p>反转。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>, flag = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: s.toCharArray())&#123;<br>  list.get(index).append(c);<br>  <span class="hljs-keyword">if</span> (index==<span class="hljs-number">0</span> || index== numRows-<span class="hljs-number">1</span>)&#123;<br>    flag = -flag;<br>  &#125;<br>  index+=flag;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">convert</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> numRows)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (numRows&lt;<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br>  List&lt;StringBuilder&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>    list.add(<span class="hljs-keyword">new</span> StringBuilder());<br>  &#125;<br>  <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>, flag = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: s.toCharArray())&#123;<br>    list.get(index).append(c);<br>    <span class="hljs-keyword">if</span> (index==<span class="hljs-number">0</span> || index== numRows-<span class="hljs-number">1</span>)&#123;<br>      flag = -flag;<br>    &#125;<br>    index+=flag;<br>  &#125;<br>  StringBuilder ans = <span class="hljs-keyword">new</span> StringBuilder();<br>  <span class="hljs-keyword">for</span> (StringBuilder sb: list) ans.append(sb);<br>  <span class="hljs-keyword">return</span> ans.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1601_最多可达成的换楼请求数目</title>
    <link href="/2022/02/28/1601-%E6%9C%80%E5%A4%9A%E5%8F%AF%E8%BE%BE%E6%88%90%E7%9A%84%E6%8D%A2%E6%A5%BC%E8%AF%B7%E6%B1%82%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/02/28/1601-%E6%9C%80%E5%A4%9A%E5%8F%AF%E8%BE%BE%E6%88%90%E7%9A%84%E6%8D%A2%E6%A5%BC%E8%AF%B7%E6%B1%82%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。</p><p>给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。</p><p>一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。</p><p>请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220228210549.jpg" alt="img"></p><blockquote><p>输入：n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]<br>输出：5<br>解释：请求列表如下：<br>从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。<br>从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。<br>从楼 2 离开的员工为 z ，且他想要搬到楼 0 。<br>从楼 3 离开的员工为 c ，且他想要搬到楼 4 。<br>没有员工从楼 4 离开。<br>我们可以让 x 和 b 交换他们的楼，以满足他们的请求。<br>我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。<br>所以最多可以满足 5 个请求。</p></blockquote><p>示例二：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220228210527.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：n = 3, requests = [[0,0],[1,2],[2,1]]<br><strong>输出</strong>：3<br><strong>解释</strong>：请求列表如下：<br>从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。<br>从楼 1 离开的员工为 y ，且他想要搬到楼 2 。<br>从楼 2 离开的员工为 z ，且他想要搬到楼 1 。<br>我们可以满足所有的请求。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]<br><strong>输出</strong>：4</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= n &lt;= 20</li><li>1 &lt;= requests.length &lt;= 16</li><li>requests[i].length == 2</li><li>0 &lt;= fromi, toi &lt; n</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>采用回溯的方法枚举每一个选项</p><p>用数组 delta 记录每一栋楼的变化量，用整数 count 记录被选择的请求数，用 zero 维护变化量中 0 的个数</p><p>对于第 pos 个请求<code>[x, y]</code>，如果选择该请求，那么 count 数加一，<code>delta[x]</code>减一，<code>delta[y]</code>加一。如果不选择，则不进行任何操作。然后调用 <code>dfd(pos + 1)</code>处理下一个请求</p><p>如果枚举了所有请求，则判断是否满足 delta 里全是 0，如果满足，则更新答案的最大值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] delta;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, zero, n;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumRequests</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] requests)</span></span>&#123;<br>  delta = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  zero = n;<br>  <span class="hljs-keyword">this</span>.n = n;<br>  dfs(requests, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] requests, <span class="hljs-keyword">int</span> pos)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (pos == requests.length)&#123;<br>    <span class="hljs-keyword">if</span> (zero == n)&#123;<br>      ans = Math.max(ans, count);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 不选 requests[pos]</span><br>  dfs(requests, pos+<span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">// 选 requests[pos]</span><br>  <span class="hljs-keyword">int</span> z = zero;<br>  count++;<br>  <span class="hljs-keyword">int</span>[] r = requests[pos];<br>  <span class="hljs-keyword">int</span> x = r[<span class="hljs-number">0</span>], y = r[<span class="hljs-number">1</span>];<br>  zero -= delta[x] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>  delta[x]--;<br>  zero += delta[x] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><br>  zero -= delta[y] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>  delta[y]++;<br>  zero += delta[y] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>  dfs(requests, pos+<span class="hljs-number">1</span>);<br>  delta[y]--;<br>  delta[x]++;<br>  count--;<br>  zero = z;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15_三数之和</title>
    <link href="/2022/02/27/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/02/27/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：<strong>答案中不可以包含重复的三元组</strong>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：nums = [-1,0,1,2,-1,-4]<br><strong>输出</strong>：[[-1,-1,2],[-1,0,1]]</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：nums = []<br><strong>输出</strong>：[]</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：nums = [0]<br><strong>输出</strong>：[]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>题目最关键的就是如何去除重复的三元组，可以通过排序的方法解决这个问题，将数组排序后，如果遇到重复的元素，跳过即可。</p><ol><li><p>首先对数组进行排序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> len = nums.length;<br><span class="hljs-keyword">if</span> (nums==<span class="hljs-keyword">null</span>|| len&lt;<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> ans;<br>Arrays.sort(nums); <span class="hljs-comment">// 排序</span><br></code></pre></div></td></tr></table></figure></li><li><p>固定一个数 <code>nums[i]</code>, 定义左右指针分别指向 <code>nums[i]</code> 之后的两端，分别为 <code>nums[L]</code> 和 <code>nums[R]</code>, 判断和是否为 0</p><p><code>int L = i + 1; int R = len - 1;</code></p></li><li><p>如果 <code>nums[i]</code> 大于 0 ，说明它和它后面的元素全部大于 0，肯定不符合条件，结束循环</p></li><li><p>如果 <code>nums[i] = nums[i-1]</code>,说明该数字重复，应该跳过</p></li><li><p>当和为 0 时，如果 <code>nums[L] = nums[L++]</code>, 说明该数字重复，应该 L++</p></li><li><p>当和为 0 时，如果 <code>nums[R] = nums[R--]</code>, 说明该数字重复，应该R–</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums)&#123;<br>  List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">int</span> len = nums.length;<br>  <span class="hljs-keyword">if</span> (nums==<span class="hljs-keyword">null</span>|| len&lt;<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> ans;<br>  Arrays.sort(nums); <span class="hljs-comment">// 排序</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果当前数字大于0，则和一定大于0，结束循环</span><br>    <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">int</span> L = i+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> R = len-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (L&lt;R)&#123;<br>      <span class="hljs-keyword">int</span> sum = nums[i] + nums[L] + nums[R];<br>      <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>)&#123;<br>        ans.add(Arrays.asList(nums[i],nums[L],nums[R]));<br>        <span class="hljs-keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="hljs-number">1</span>]) L++;<br>        <span class="hljs-keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="hljs-number">1</span>]) R--;<br>        L++;<br>        R--;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&lt;<span class="hljs-number">0</span>) L++; <span class="hljs-comment">// 增大sum</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&gt;<span class="hljs-number">0</span>) R--; <span class="hljs-comment">// 减小sum</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>343_整数拆分（剪绳子）</title>
    <link href="/2022/02/26/343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88%E5%89%AA%E7%BB%B3%E5%AD%90%EF%BC%89/"/>
    <url>/2022/02/26/343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88%E5%89%AA%E7%BB%B3%E5%AD%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>: 2<br><strong>输出</strong>: 1<br><strong>解释</strong>: 2 = 1 + 1, 1 × 1 = 1</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>: 10<br><strong>输出</strong>: 36<br><strong>解释</strong>: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>要求剪下绳子长度乘积的最大值，可以用动态规划的方法。</p><p>用一个 dp 数组记录绳子长度为 n 的时候乘积的最大值，初始情况：当绳子长度为 2 时，最大乘积为 1 （最少要减一次）<code>int[] dp = new int[n+1]; dp[2] = 1;</code></p><p>剪下一段后，可以选择继续剪或者不剪。不剪的话长度乘积为 剪下长度 <code>j</code> * 剩余长度  <code>i-j</code> ；剪的话长度乘积为 剪下长度 <code>j</code> * dp[剩余长度] <code>dp[i-j]</code></p><p><code>Math.max(j*(i-j), j*dp[i-j])</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>  dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;=n; i++) &#123;<br>    <span class="hljs-comment">// 剪 1 没有意义，故从 2 开始循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; i; j++) &#123;<br>      dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1706_球会落何处</title>
    <link href="/2022/02/24/1706-%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84/"/>
    <url>/2022/02/24/1706-%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。</p><p>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。</p><ul><li>将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。</li><li>将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。</li></ul><p>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。</p><p>返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><strong><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220224105305.jpg" alt="img"></strong></p><blockquote><p><strong>输入</strong>：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]<br><strong>输出</strong>：[1,-1,-1,-1,-1]<br><strong>解释</strong>：示例如图：<br>b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。<br>b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 “V” 形里。<br>b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 “V” 形里。<br>b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 “V” 形里。<br>b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 “V” 形里。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：grid = [[-1]]<br><strong>输出</strong>：[-1]<br><strong>解释</strong>：球被卡在箱子左侧边上。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]<br><strong>输出</strong>：[0,1,2,3,4,-1]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>grid[i][j]</code> 为 <code>1</code> 或 <code>-1</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>按照题目模拟每一行小球的位置</p><p>初始位置设置为下标</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;<br><span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  ans[i] = i;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后按行模拟，行内遍历每一列，如果位置已经是 -1 ，则跳过。</p><p>记录当前位置以及前后的方向，墙壁记为 0</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> cur = grid[i][ans[j]];<br><span class="hljs-keyword">int</span> before = ans[j]==<span class="hljs-number">0</span> ? <span class="hljs-number">0</span>: grid[i][ans[j]-<span class="hljs-number">1</span>];<br><span class="hljs-keyword">int</span> after = ans[j]==n-<span class="hljs-number">1</span>? <span class="hljs-number">0</span>: grid[i][ans[j]+<span class="hljs-number">1</span>];<br></code></pre></div></td></tr></table></figure><p>如果是向右，即 <code>cur == 1</code>,则比较 after 的值，如果向左，则比较 before 的值，成 V 字型或贴墙，则设置 <code>ans[j] = -1</code></p><p>否则 <code>ans[j] += cur;</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (cur==<span class="hljs-number">1</span> &amp;&amp; (after==<span class="hljs-number">0</span>||after==-<span class="hljs-number">1</span>))&#123;<br>  ans[j] = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (cur==-<span class="hljs-number">1</span> &amp;&amp; (before==<span class="hljs-number">0</span>||before==<span class="hljs-number">1</span>))&#123;<br>  ans[j] = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br>ans[j]+=cur;<br></code></pre></div></td></tr></table></figure><p>最终题解：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findBall(<span class="hljs-keyword">int</span>[][] grid) &#123;<br>  <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    ans[i] = i;<br>  &#125;<br>  <span class="hljs-comment">// 记录每一次的位置</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      <span class="hljs-comment">// 如果已经被卡住 就跳过</span><br>      <span class="hljs-keyword">if</span> (ans[j]==-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">int</span> cur = grid[i][ans[j]];<br>      <span class="hljs-keyword">int</span> before = ans[j]==<span class="hljs-number">0</span> ? <span class="hljs-number">0</span>: grid[i][ans[j]-<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">int</span> after = ans[j]==n-<span class="hljs-number">1</span>? <span class="hljs-number">0</span>: grid[i][ans[j]+<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">if</span> (cur==<span class="hljs-number">1</span> &amp;&amp; (after==<span class="hljs-number">0</span>||after==-<span class="hljs-number">1</span>))&#123;<br>        ans[j] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (cur==-<span class="hljs-number">1</span> &amp;&amp; (before==<span class="hljs-number">0</span>||before==<span class="hljs-number">1</span>))&#123;<br>        ans[j] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      ans[j]+=cur;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>748_最短补全词</title>
    <link href="/2022/02/23/748-%E6%9C%80%E7%9F%AD%E8%A1%A5%E5%85%A8%E8%AF%8D/"/>
    <url>/2022/02/23/748-%E6%9C%80%E7%9F%AD%E8%A1%A5%E5%85%A8%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出 words 中的 最短补全词 。</p><p>补全词 是一个包含 licensePlate 中所有字母的单词。忽略 licensePlate 中的 数字和空格 。不区分大小写。如果某个字母在 licensePlate 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。</p><p>例如：licensePlate = “aBc 12c”，那么它的补全词应当包含字母 ‘a’、’b’ （忽略大写）和两个 ‘c’ 。可能的 补全词 有 “abccdef”、”caaacab” 以及 “cbca” 。</p><p>请返回 words 中的 最短补全词 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 words 中 第一个 出现的那个。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：licensePlate = “1s3 PSt”, words = [“step”, “steps”, “stripe”, “stepple”]<br><strong>输出</strong>：”steps”<br><strong>解释</strong>：最短补全词应该包括 “s”、”p”、”s”（忽略大小写） 以及 “t”。<br>“step” 包含 “t”、”p”，但只包含一个 “s”，所以它不符合条件。<br>“steps” 包含 “t”、”p” 和两个 “s”。<br>“stripe” 缺一个 “s”。<br>“stepple” 缺一个 “s”。<br>因此，”steps” 是唯一一个包含所有字母的单词，也是本例的答案。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：licensePlate = “1s3 456”, words = [“looks”, “pest”, “stew”, “show”]<br><strong>输出</strong>：”pest”<br><strong>解释</strong>：licensePlate 只包含字母 “s” 。所有的单词都包含字母 “s” ，其中 “pest”、”stew”、和 “show” 三者最短。答案是 “pest” ，因为它是三个单词中在 words 里最靠前的那个。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= licensePlate.length &lt;= 7</li><li>licensePlate 由数字、大小写字母或空格 ‘ ‘ 组成</li><li>1 &lt;= words.length &lt;= 1000</li><li>1 &lt;= words[i].length &lt;= 15</li><li>words[i] 由小写英文字母组成</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>题目最关键的部分是是 <strong>忽略数字和空格 ，不区分大小写</strong>。如果某个字母在 licensePlate 中出现不止一次，那么<strong>该字母在补全词中的出现次数应当一致或者更多。</strong></p><p>所以首先统计 licensePlate 中每个字母出现的次数，用一个 int 数组记录</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br><span class="hljs-comment">// 统计句子中的字母个数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;licensePlate.length();i++)&#123;<br>  <span class="hljs-keyword">char</span> ch = licensePlate.charAt(i);<br>  <span class="hljs-keyword">if</span> (Character.isLetter(ch))&#123;<br>    count[Character.toLowerCase(ch)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后遍历每个单词，同时记录一个 index 用来标记上一个符合条件的 word 下标</p><p>遍历单词时，先统计每个单词字母出现的个数，然后与句子中的比较，符合条件后，再比较当前单词与 index 下标单词的长度，选择长度更小的</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">shortestCompletingWord</span><span class="hljs-params">(String licensePlate, String[] words)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> index= -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>  <span class="hljs-comment">// 统计句子中的字母个数</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;licensePlate.length();i++)&#123;<br>    <span class="hljs-keyword">char</span> ch = licensePlate.charAt(i);<br>    <span class="hljs-keyword">if</span> (Character.isLetter(ch))&#123;<br>      count[Character.toLowerCase(ch)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 遍历单词</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>    <span class="hljs-keyword">int</span>[] word = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">boolean</span> ok = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; words[i].length(); j++) &#123;<br>      <span class="hljs-keyword">char</span> ch = words[i].charAt(j);<br>      word[ch-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;<span class="hljs-number">26</span> ; j++) &#123;<br>      <span class="hljs-keyword">if</span> (word[j]&lt;count[j])&#123;<br>        ok = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ok &amp;&amp;(index&lt;<span class="hljs-number">0</span> || words[i].length()&lt;words[index].length()))&#123;<br>      index = i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> words[index];<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25_K个一组翻转链表</title>
    <link href="/2022/02/23/25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/02/23/25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><ul><li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li><li>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220223141639.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：head = [1,2,3,4,5], k = 2<br><strong>输出</strong>：[2,1,4,3,5]</p></blockquote><p>示例二：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220223141621.jpg" alt="img"></p><blockquote><p><strong>输入</strong>：head = [1,2,3,4,5], k = 3<br><strong>输出</strong>：[3,2,1,4,5]</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：head = [1,2,3,4,5], k = 1<br><strong>输出</strong>：[1,2,3,4,5]</p></blockquote><p>示例四：</p><blockquote><p><strong>输入</strong>：head = [1], k = 1<br><strong>输出</strong>：[1]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>列表中节点的数量在范围 <code>sz</code> 内</li><li><code>1 &lt;= sz &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= sz</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>提到翻转首先想到 stack 的特点，入栈再出栈即可实现翻转。</p><p>这题也是一样，循环 k 次，先入栈，如果不足 k 次，则不反转，原链表顺序不变。</p><p>重新定义一个链表 dummy，定义一个链表尾 <code>ListNode p = dummy</code></p><p>每轮循环记录一个 head，这个 head 作为小组的头节点，然后定义临时变量 <code>ListNode temp = head</code>，入栈后 <code>temp = temp.next</code> , 当剩余不足 k 个时，链表尾直接接小组头 <code>p.next = head</code> ,如果足够 k 个，则开始出栈，<code>p.next = stack.pollLast()； p = p.next</code>，出栈结束后更新下小组的头节点<code>head = temp</code></p><p>最后返回链表头节点</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123; <br>  Deque&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>  <span class="hljs-comment">// 链表头</span><br>  ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 链表尾</span><br>  ListNode p = dummy;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    ListNode temp = head;<br>    <span class="hljs-comment">// 向 stack 里推入 k 个</span><br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-keyword">null</span> &amp;&amp; count &lt; k)&#123;<br>      stack.add(temp);<br>      temp = temp.next;<br>      count++;<br>    &#125;<br>    <span class="hljs-comment">// 不足 k 个，直接连在 p 后面</span><br>    <span class="hljs-keyword">if</span> (count != k)&#123;<br>      p.next = head;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>      p.next = stack.pollLast();<br>      p = p.next;<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    head = temp;<br>  &#125;<br>  <span class="hljs-comment">// 返回链表头的下一个</span><br>  <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeTop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3_无重复字符的最长字串</title>
    <link href="/2022/02/23/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <url>/2022/02/23/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>: s = “abcabcbb”<br><strong>输出</strong>: 3<br><strong>解释</strong>: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>: s = “bbbbb”<br><strong>输出</strong>: 1<br><strong>解释</strong>: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>: s = “pwwkew”<br><strong>输出</strong>: 3<br><strong>解释</strong>: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>滑动窗口解法</p><p>用一个 HashMap 存储字符和出现的位置，然后遍历字符串。</p><p>遇到一个字符们首先判断是否存在于 map 中，如果不存在，将字符添加到 map 中，然后记录最大长度，最大长度就是当前位置下标 - 起点位置下标 + 1；如果存在，就更新起点位置下标。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> maxLen = -<span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// map 存储字符和出现的位置</span><br>  HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (map.containsKey(s.charAt(i))) &#123;<br>      left = Math.max(left, map.get(s.charAt(i)) + <span class="hljs-number">1</span>);<br>    &#125;<br>    map.put(s.charAt(i), i);<br>    maxLen = Math.max(maxLen, i - left + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxLen;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeTop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146_LRU缓存</title>
    <link href="/2022/02/23/146-LRU%E7%BC%93%E5%AD%98/"/>
    <url>/2022/02/23/146-LRU%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以 <strong>正整数</strong> 作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong><br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br><strong>输出</strong><br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p><p><strong>解释</strong><br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 10^5</code></li><li><code>最多调用 2 * 10^5 次 get 和 put</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>用一个 LinkedHashMap 存储数据</p><p>执行 get 方法时，先检查是否在 keySet 中，存在则获取值，然后先 remove 再 put，保证查询后的数据在末尾，再返回值。</p><p>执行 put 方法时， 先检查是否在 keySet 中，如果存在，就先移除，如果不存在，就检查 map 的 size 和 capacity 是否相同，如果相同，则遍历 map，将第一个删除。最后再调用 map.put(key, value) 方法将数据添加到末尾。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.cap = capacity;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (map.keySet().contains(key))&#123;<br>            <span class="hljs-keyword">int</span> value = map.get(key);<br>            map.remove(key);<br>            <span class="hljs-comment">// 保证每次查询后都在末尾</span><br>            map.put(key,value);<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (map.keySet().contains(key))&#123;<br>            map.remove(key);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.size()==cap)&#123;<br>            Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = map.entrySet().iterator();<br>            <span class="hljs-comment">// 移除首个</span><br>            iterator.next();<br>            iterator.remove();<br>        &#125;<br>        map.put(key, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeTop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>838_推多米诺</title>
    <link href="/2022/02/21/838-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/"/>
    <url>/2022/02/21/838-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。</p><p>每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。</p><p>如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。</p><p>就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。</p><p>给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中：</p><ul><li>dominoes[i] = ‘L’，表示第 i 张多米诺骨牌被推向左侧，</li><li>dominoes[i] = ‘R’，表示第 i 张多米诺骨牌被推向右侧，</li><li>dominoes[i] = ‘.’，表示没有推动第 i 张多米诺骨牌。</li></ul><p>返回表示最终状态的字符串。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：dominoes = “RR.L”<br><strong>输出</strong>：”RR.L”<br><strong>解释</strong>：第一张多米诺骨牌没有给第二张施加额外的力。</p></blockquote><p>示例二：</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220221104642.png" alt="img"></p><blockquote><p><strong>输入</strong>：dominoes = “.L.R…LR..L..”<br><strong>输出</strong>：”LL.RR.LLRRLL..”</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>n == dominoes.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>dominoes[i]</code> 为 <code>&#39;L&#39;</code>、<code>&#39;R&#39;</code> 或 <code>&#39;.&#39;</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>最直观的想法就是找到每个状态为直立的骨牌，然后比较它前后两块的状态</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">char</span> cur = sb.charAt(i);<br><span class="hljs-keyword">if</span> (cur != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>  pre = cur;<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>如果前后都为 L，则它会变成 L</li><li>如果前后都是 R，则它会变成 R</li><li>如果前为 R，后为 . ，则它会变成 R</li><li>如果后为 L，前为 . ，则它会变成 L</li></ul><p>如果为边界，则认为是直立状态。如左边界前一个为直立，右边界后一个位直立。</p><p><code>char next = i==n-1?&#39;.&#39;:sb.charAt(i+1);</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (pre==<span class="hljs-string">&#x27;R&#x27;</span>&amp;&amp;next!=<span class="hljs-string">&#x27;L&#x27;</span>)&#123;<br>  <span class="hljs-comment">// 左侧 R，右侧为 R 或者 . 向右倒</span><br>  hasChange = <span class="hljs-keyword">true</span>;<br>  sb.setCharAt(i,<span class="hljs-string">&#x27;R&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next==<span class="hljs-string">&#x27;L&#x27;</span>&amp;&amp;pre!=<span class="hljs-string">&#x27;R&#x27;</span>)&#123;<br>  <span class="hljs-comment">// 右侧为 L，左侧为 L 或者 . 向左倒</span><br>  hasChange = <span class="hljs-keyword">true</span>;<br>  sb.setCharAt(i,<span class="hljs-string">&#x27;L&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>每次循环所有骨牌，直至该轮循环无变化。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pushDominoes</span><span class="hljs-params">(String dominoes)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = dominoes.length();<br>  StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(dominoes);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>    <span class="hljs-keyword">boolean</span> hasChange = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">char</span> pre = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>      <span class="hljs-comment">// 当前位置</span><br>      <span class="hljs-keyword">char</span> cur = sb.charAt(i);<br>      <span class="hljs-keyword">if</span> (cur != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>        pre = cur;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-comment">// 下一个位置</span><br>      <span class="hljs-keyword">char</span> next = i==n-<span class="hljs-number">1</span>?<span class="hljs-string">&#x27;.&#x27;</span>:sb.charAt(i+<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (pre==<span class="hljs-string">&#x27;R&#x27;</span>&amp;&amp;next!=<span class="hljs-string">&#x27;L&#x27;</span>)&#123;<br>        <span class="hljs-comment">// 左侧 R，右侧为 R 或者 . 向右倒</span><br>        hasChange = <span class="hljs-keyword">true</span>;<br>        sb.setCharAt(i,<span class="hljs-string">&#x27;R&#x27;</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next==<span class="hljs-string">&#x27;L&#x27;</span>&amp;&amp;pre!=<span class="hljs-string">&#x27;R&#x27;</span>)&#123;<br>        <span class="hljs-comment">// 右侧为 L，左侧为 L 或者 . 向左倒</span><br>        hasChange = <span class="hljs-keyword">true</span>;<br>        sb.setCharAt(i,<span class="hljs-string">&#x27;L&#x27;</span>);<br>      &#125;<br>      pre = cur;<br>    &#125;<br>    <span class="hljs-comment">// 每次迭代如果没有变化，则说明稳定，结束</span><br>    <span class="hljs-keyword">if</span> (!hasChange)&#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>717_1比特与2比特字符</title>
    <link href="/2022/02/20/717-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/"/>
    <url>/2022/02/20/717-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有两种特殊字符：</p><ul><li>第一种字符可以用一个比特 0 来表示</li><li>第二种字符可以用两个比特(10 或 11)来表示、</li></ul><p>给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>: bits = [1, 0, 0]<br><strong>输出</strong>: true<br><strong>解释</strong>: 唯一的编码方式是一个两比特字符和一个一比特字符。<br>所以最后一个字符是一比特字符。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>: bits = [1, 1, 1, 0]<br><strong>输出</strong>: false<br><strong>解释</strong>: 唯一的编码方式是两比特字符和两比特字符。<br>所以最后一个字符不是一比特字符。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= bits.length &lt;= 1000</code></li><li><code>bits[i] == 0 or 1</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>遍历数组，遇到 1 的时候，下一个无论是 0 还是 1，都会与当前这个 1 组合成一个字符。所以可以从头遍历数组，如果遇到 0 ，就跳到下一位，如果遇到 1 ，就跳到下两位，直至遍历结束，结束的位置如果等于数组长度（下标为数组长度 -1），即正确。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOneBitCharacter</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] bits)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, n = bits.length;<br>  <span class="hljs-keyword">while</span> (start&lt;n-<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span> (bits[start]==<span class="hljs-number">0</span>)&#123;<br>      start++;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      start+=<span class="hljs-number">2</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> start==n-<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>969_煎饼排序</title>
    <link href="/2022/02/19/969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/02/19/969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。</p><p>一次煎饼翻转的执行过程如下：</p><ul><li>选择一个整数 k ，1 &lt;= k &lt;= arr.length</li><li>反转子数组 arr[0…k-1]（下标从 0 开始）</li></ul><p>例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。</p><p>以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：[3,2,4,1]<br><strong>输出</strong>：[4,2,4,3]<br><strong>解释</strong>：<br>我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。<br>初始状态 arr = [3, 2, 4, 1]<br>第一次翻转后（k = 4）：arr = [1, 4, 2, 3]<br>第二次翻转后（k = 2）：arr = [4, 1, 2, 3]<br>第三次翻转后（k = 4）：arr = [3, 2, 1, 4]<br>第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。 </p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：[1,2,3]<br><strong>输出</strong>：[]<br><strong>解释</strong>：<br>输入已经排序，因此不需要翻转任何内容。<br>请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= arr.length &lt;= 100</li><li>1 &lt;= arr[i] &lt;= arr.length</li><li>arr 中的所有整数互不相同（即，arr 是从 1 到 arr.length 整数的一个排列）</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>因为煎饼排序的规则是选择一个整数 k，然后反转数组 arr[0]～arr[k-1]，可以看到每次排序都影响前 k 个元素，所以考虑每轮循环将最大元素放到数组最后面，因此循环从数组最长开始 <code>for (int n=arr.length; n&gt;1;n--)</code>。</p><p>每次循环先找当前的最大值下标，如果下标是数组最后一个，就跳过，此轮不用排序。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n;i++)&#123;<br>  <span class="hljs-keyword">if</span> (arr[i]&gt;arr[index])&#123;<br>    index = i;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (index == n-<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后先翻转 0-index 的元素，使最大元素翻转到数组首</p><p>然后在翻转当前数组的元素，使最大元素翻转到数组尾</p><p>分别记录操作</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 反转 0-index，index 换到首位</span><br>reverse(arr,index);<br><span class="hljs-comment">// 然后反转整个数组，index 换到末尾</span><br>reverse(arr,n-<span class="hljs-number">1</span>);<br>ans.add(index+<span class="hljs-number">1</span>);<br>ans.add(n);<br></code></pre></div></td></tr></table></figure><p>翻转前 index 个元素</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=index; i&lt;j; i++,j--)&#123;<br>    <span class="hljs-keyword">int</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">pancakeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>  List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n=arr.length; n&gt;<span class="hljs-number">1</span>;n--)&#123;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n;i++)&#123;<br>      <span class="hljs-keyword">if</span> (arr[i]&gt;arr[index])&#123;<br>        index = i;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index == n-<span class="hljs-number">1</span>)&#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// 反转 0-index，index 换到首位</span><br>    reverse(arr,index);<br>    <span class="hljs-comment">// 然后反转整个数组，index 换到末尾</span><br>    reverse(arr,n-<span class="hljs-number">1</span>);<br>    ans.add(index+<span class="hljs-number">1</span>);<br>    ans.add(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=index; i&lt;j; i++,j--)&#123;<br>    <span class="hljs-keyword">int</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>809_情感丰富的文字</title>
    <link href="/2022/02/19/809-%E6%83%85%E6%84%9F%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%96%87%E5%AD%97/"/>
    <url>/2022/02/19/809-%E6%83%85%E6%84%9F%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%96%87%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有时候人们会用重复写一些字母来表示额外的感受，比如 <code>&quot;hello&quot; -&gt; &quot;heeellooo&quot;</code>,<code> &quot;hi&quot; -&gt; &quot;hiii&quot;</code>。我们将相邻字母都相同的一串字符定义为相同字母组，例如：<code>&quot;h&quot;</code>, <code>&quot;eee&quot;</code>, <code>&quot;ll&quot;</code>, <code>&quot;ooo&quot;</code>。</p><p>对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 c ），然后往其中添加相同的字母 c 使其长度达到 3 或以上。</p><p>例如，以 <code>&quot;hello&quot;</code> 为例，我们可以对字母组 <code>&quot;o&quot;</code> 扩张得到 <code>&quot;hellooo&quot;</code>，但是无法以同样的方法得到 <code>&quot;helloo&quot;</code> 因为字母组 <code>&quot;oo&quot;</code> 长度小于 3。此外，我们可以进行另一种扩张 <code>&quot;ll&quot; -&gt; &quot;lllll&quot;</code> 以获得 <code>&quot;helllllooo&quot;</code>。如果 S = <code>&quot;helllllooo&quot;</code>，那么查询词 <code>&quot;hello&quot;</code> 是可扩张的，因为可以对它执行这两种扩张操作使得 <code>query = &quot;hello&quot; -&gt; &quot;hellooo&quot; -&gt; &quot;helllllooo&quot; = S</code>。</p><p>输入一组查询单词，输出其中可扩张的单词数量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：<br>S = “heeellooo”<br>words = [“hello”, “hi”, “helo”]<br><strong>输出</strong>：1<br><strong>解释</strong>：<br>我们能通过扩张 “hello” 的 “e” 和 “o” 来得到 “heeellooo”。<br>我们不能通过扩张 “helo” 来得到 “heeellooo” 因为 “ll” 的长度小于 3 。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>0 &lt;= len(S) &lt;= 100。</li><li>0 &lt;= len(words) &lt;= 100。</li><li>0 &lt;= len(words[i]) &lt;= 100。</li><li>S 和所有在 words 中的单词都只由小写字母组成。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>根据题目意思，判断为可扩张的条件是扩张后字母数量需要大于等于三个</p><p>所以可以先对 S 进行统计，按顺序记录出现的字母和出现的个数，如 heeellooo 可以记录为 helo-1323，即 h 出现 1 次，e 出现 3 次，l 出现 2 次， o 出现 3 次。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">temp</span></span>&#123;<br>    String key;<br>    List&lt;Integer&gt; counts;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">temp</span><span class="hljs-params">(String s)</span></span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        counts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-keyword">int</span> n = chars.length;<br>        <span class="hljs-keyword">int</span> prev = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (i==n-<span class="hljs-number">1</span> || chars[i]!=chars[i+<span class="hljs-number">1</span>])&#123;<br>                sb.append(chars[i]);<br>                counts.add(i-prev);<br>                prev = i;<br>            &#125;<br>        &#125;<br>        key = sb.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后对每个单词进行统计，首先判断出现的字母是否相同，不相同直接跳过。出现的字母相同后，比较每个字母出现的次数，这里需要满足：如果出现次数小于 3 次，那么单词里和句子里的次数都要相同；如果出现的次数大于 3 次，那么句子里的次数要超过单词里的次数，否则跳过该单词。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">f (!S.key.equals(T.key)) &#123;<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S.counts.size(); i++) &#123;<br>  <span class="hljs-keyword">int</span> count1 = S.counts.get(i);<br>  <span class="hljs-keyword">int</span> count2 = T.counts.get(i);<br>  <span class="hljs-keyword">if</span> (count1 &lt; <span class="hljs-number">3</span> &amp;&amp; count1 != count2 || count1 &lt; count2) &#123;<br>    <span class="hljs-keyword">continue</span> search;<br>  &#125;<br>&#125;<br>ans++;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expressiveWords</span><span class="hljs-params">(String s, String[] words)</span> </span>&#123;<br>        temp S = <span class="hljs-keyword">new</span> temp(s);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        search: <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            temp T = <span class="hljs-keyword">new</span> temp(word);<br>            <span class="hljs-keyword">if</span> (!S.key.equals(T.key)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S.counts.size(); i++) &#123;<br>                <span class="hljs-keyword">int</span> count1 = S.counts.get(i);<br>                <span class="hljs-keyword">int</span> count2 = T.counts.get(i);<br>                <span class="hljs-keyword">if</span> (count1 &lt; <span class="hljs-number">3</span> &amp;&amp; count1 != count2 || count1 &lt; count2) &#123;<br>                    <span class="hljs-keyword">continue</span> search;<br>                &#125;<br>            &#125;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">temp</span></span>&#123;<br>    String key;<br>    List&lt;Integer&gt; counts;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">temp</span><span class="hljs-params">(String s)</span></span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        counts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-keyword">int</span> n = chars.length;<br>        <span class="hljs-keyword">int</span> prev = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (i==n-<span class="hljs-number">1</span> || chars[i]!=chars[i+<span class="hljs-number">1</span>])&#123;<br>                sb.append(chars[i]);<br>                counts.add(i-prev);<br>                prev = i;<br>            &#125;<br>        &#125;<br>        key = sb.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1195_交替打印字符串</title>
    <link href="/2022/02/16/1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/02/16/1195-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p><ul><li>如果这个数字可以被 3 整除，输出 “fizz”。</li><li>如果这个数字可以被 5 整除，输出 “buzz”。</li><li>如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。</li></ul><p>例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。</p><p>假设有这么一个类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FizzBuzz</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123; ... &#125;               <span class="hljs-comment">// constructor</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fizz</span><span class="hljs-params">(printFizz)</span> </span>&#123; ... &#125;          <span class="hljs-comment">// only output &quot;fizz&quot;</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buzz</span><span class="hljs-params">(printBuzz)</span> </span>&#123; ... &#125;          <span class="hljs-comment">// only output &quot;buzz&quot;</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fizzbuzz</span><span class="hljs-params">(printFizzBuzz)</span> </span>&#123; ... &#125;  <span class="hljs-comment">// only output &quot;fizzbuzz&quot;</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">number</span><span class="hljs-params">(printNumber)</span> </span>&#123; ... &#125;      <span class="hljs-comment">// only output the numbers</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>请你实现一个有四个线程的多线程版  FizzBuzz， 同一个 FizzBuzz 实例会被如下四个线程使用：</p><ol><li>线程A将调用 fizz() 来判断是否能被 3 整除，如果可以，则输出 fizz。</li><li>线程B将调用 buzz() 来判断是否能被 5 整除，如果可以，则输出 buzz。</li><li>线程C将调用 fizzbuzz() 来判断是否同时能被 3 和 5 整除，如果可以，则输出 fizzbuzz。</li><li>线程D将调用 number() 来实现输出既不能被 3 整除也不能被 5 整除的数字。</li></ol><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>本题已经提供了打印字符串的相关方法，如 <code>printFizz()</code> 等，具体方法名请参考答题模板中的注释部分</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>本题与 1116 类似，使用 4 个信号量来对输出进行控制，分别是打印 fizz，打印 buzz，打印 fizzbuzz 和打印数字。每个线程都从 1 到 n 进行遍历，以 number 为主进行输出，符合哪个条件，就释放哪个信号量，各线程执行一次之后，释放信号量给 number 让它继续遍历。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FizzBuzz</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">private</span> Semaphore number;<br>    <span class="hljs-keyword">private</span> Semaphore fizz;<br>    <span class="hljs-keyword">private</span> Semaphore buzz;<br>    <span class="hljs-keyword">private</span> Semaphore fizzbuzz;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>        <span class="hljs-keyword">this</span>.number = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">this</span>.fizz = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">this</span>.buzz = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">this</span>.fizzbuzz = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// printFizz.run() outputs &quot;fizz&quot;.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fizz</span><span class="hljs-params">(Runnable printFizz)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span> &amp;&amp; i%<span class="hljs-number">5</span>!=<span class="hljs-number">0</span>)&#123;<br>                fizz.acquire();<br>                printFizz.run();<br>                number.release();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// printBuzz.run() outputs &quot;buzz&quot;.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buzz</span><span class="hljs-params">(Runnable printBuzz)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">3</span>!=<span class="hljs-number">0</span> &amp;&amp; i%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>                buzz.acquire();<br>                printBuzz.run();<br>                number.release();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// printFizzBuzz.run() outputs &quot;fizzbuzz&quot;.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fizzbuzz</span><span class="hljs-params">(Runnable printFizzBuzz)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span> &amp;&amp; i%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>                fizzbuzz.acquire();<br>                printFizzBuzz.run();<br>                number.release();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">number</span><span class="hljs-params">(IntConsumer printNumber)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">3</span>!=<span class="hljs-number">0</span>&amp;&amp;i%<span class="hljs-number">5</span>!=<span class="hljs-number">0</span>)&#123;<br>                printNumber.accept(i);<br>                number.release();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i%<span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; i%<span class="hljs-number">5</span> != <span class="hljs-number">0</span>)&#123;<br>                fizz.release();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i%<span class="hljs-number">3</span> != <span class="hljs-number">0</span> &amp;&amp; i%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>)&#123;<br>                buzz.release();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i%<span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; i%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>)&#123;<br>                fizzbuzz.release();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1116_打印零与奇偶数</title>
    <link href="/2022/02/16/1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0/"/>
    <url>/2022/02/16/1116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现有函数 printNumber 可以用一个整数参数调用，并输出该整数到控制台。</p><p>例如，调用 printNumber(7) 将会输出 7 到控制台。<br>给你类 ZeroEvenOdd 的一个实例，该类中有三个函数：zero、even 和 odd 。ZeroEvenOdd 的相同实例将会传递给三个不同线程：</p><ul><li><strong>线程 A</strong>：调用 zero() ，只输出 0</li><li><strong>线程 B</strong>：调用 even() ，只输出偶数</li><li><strong>线程 C</strong>：调用 odd() ，只输出奇数</li></ul><p>修改给出的类，以输出序列 “010203040506…” ，其中序列的长度必须为 2n 。</p><p>实现 ZeroEvenOdd 类：</p><ul><li>ZeroEvenOdd(int n) 用数字 n 初始化对象，表示需要输出的数。</li><li>void zero(printNumber) 调用 printNumber 以输出一个 0 。</li><li>void even(printNumber) 调用printNumber 以输出偶数。</li><li>void odd(printNumber) 调用 printNumber 以输出奇数。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：n = 2<br><strong>输出</strong>：”0102”<br><strong>解释</strong>：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 “0102”。</p></blockquote><p>示例一：</p><blockquote><p><strong>输入</strong>：n = 5<br><strong>输出</strong>：”0102030405”</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="Java-信号量"><a href="#Java-信号量" class="headerlink" title="Java 信号量"></a>Java 信号量</h3><p>Semaphore(信号量)：是一种计数器，用来保护一个或者多个共享资源的访问。如果线程要访问一个资源就必须先获得信号量。如果信号量内部计数器大于0，信号量减1，然后允许共享这个资源；否则，如果信号量的计数器等于0，信号量将会把线程置入休眠直至计数器大于0.当信号量使用完时，必须释放。</p><p><strong>主要方法</strong>：</p><ul><li>void acquire() ：从信号量获取一个许可，如果无可用许可前将一直阻塞等待</li><li>boolean tryAcquire()：从信号量尝试获取一个许可，如果无可用许可，直接返回false，不会阻塞</li><li>void release()： 释放一个许可。注意：多次调用该方法，会使信号量的许可数增加，达到动态扩展的效果</li><li>int availablePermits()： 获取当前信号量可用的许可</li></ul><p>在多线程中，通常会使用 Semaphore 信号量来进行资源共享。</p><p>每当线程需要执行时，就调用 acquire 方法获取一个许可，等待获取到资源后执行，执行完成后调用 release 方法是放一个许可。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>在此题中，三个线程开始遍历 n，zero 线程首先获得一个许可，打印 0 后，从 1 到 n 进行遍历，奇数对 odd 信号量释放一个许可，偶数则对 even 信号量释放一个许可，odd 线程从 1 到 n 每隔一位进行遍历，等待获取许可，获取许可后打印当前奇数，然后对 zero 信号量释放一个许可，even 线程同样，从 2 到 n 没隔一位进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZeroEvenOdd</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>    Semaphore zero;<br>    Semaphore even;<br>    Semaphore odd;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZeroEvenOdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>        zero = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">1</span>);<br>        even = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">0</span>);<br>        odd = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zero</span><span class="hljs-params">(IntConsumer printNumber)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            zero.acquire();<br>            printNumber.accept(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                even.release();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                odd.release();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">even</span><span class="hljs-params">(IntConsumer printNumber)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i += <span class="hljs-number">2</span>) &#123;<br>            even.acquire();<br>            printNumber.accept(i);<br>            zero.release();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">odd</span><span class="hljs-params">(IntConsumer printNumber)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i += <span class="hljs-number">2</span>) &#123;<br>            odd.acquire();<br>            printNumber.accept(i);<br>            zero.release();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1296_划分数组为连续数字的集合</title>
    <link href="/2022/02/15/1296-%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E7%9A%84%E9%9B%86%E5%90%88/"/>
    <url>/2022/02/15/1296-%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E7%9A%84%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums 和一个正整数 k，请你判断是否可以把这个数组划分成一些由 k 个连续数字组成的集合。<br>如果可以，请返回 true；否则，返回 false。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：nums = [1,2,3,3,4,4,5,6], k = 4<br><strong>输出</strong>：true<br><strong>解释</strong>：数组可以分成 [1,2,3,4] 和 [3,4,5,6]。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3<br><strong>输出</strong>：true<br><strong>解释</strong>：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：nums = [3,3,2,2,1,1], k = 3<br><strong>输出</strong>：true</p></blockquote><p>示例四：</p><blockquote><p><strong>输入</strong>：nums = [1,2,3,4], k = 3<br><strong>输出</strong>：false<br><strong>解释</strong>：数组不能分成几个大小为 3 的子数组。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^9</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>首先对长度进行过滤，如果数组长度不是数组的整数倍，直接返回 false</p><p>然后用 HashMap 将数组存储起来</p><p>对数组按照从小到大排序，并开始遍历</p><p>当一个数 x 存在，那么 x+1, x+2, … x+k-1 也一定存在</p><p>按照这个顺序进行判断，首先判断 x 是否存在，然后循环判断 x 后 k 位是否存在，存在则从 HashMap 中减去一位，否则返回 false。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPossibleDivide</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = nums.length;<br>  <span class="hljs-keyword">if</span> (n%k!=<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  &#125;<br>  Arrays.sort(nums);<br>  HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num: nums)&#123;<br>    map.put(num, map.getOrDefault(num,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>    <span class="hljs-keyword">if</span> (!map.containsKey(nums[i]))&#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;k; j++)&#123;<br>      <span class="hljs-keyword">int</span> num = nums[i]+j;<br>      <span class="hljs-keyword">if</span> (!map.containsKey(num))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<br>      map.put(num,map.get(num)-<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (map.get(num)==<span class="hljs-number">0</span>)&#123;<br>        map.remove(num);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1380_矩阵中的幸运数</title>
    <link href="/2022/02/15/1380-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/"/>
    <url>/2022/02/15/1380-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <code>m * n</code> 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。</p><p>幸运数是指矩阵中满足同时下列两个条件的元素：</p><ul><li>在同一行的所有元素中最小</li><li>在同一列的所有元素中最大</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：matrix = [[3,7,8],[9,11,13],[15,16,17]]<br><strong>输出</strong>：[15]<br><strong>解释</strong>：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]<br><strong>输出</strong>：[12]<br><strong>解释</strong>：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：matrix = [[7,8],[1,2]]<br><strong>输出</strong>：[7]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>1 &lt;= n, m &lt;= 50</code></li><li><code>1 &lt;= matrix[i][j] &lt;= 10^5</code></li><li>矩阵中的所有元素都是不同的</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>常规思路，对每个元素进行遍历，然后判断是否为行中最小和列中最大，都符合的添加到结果中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">luckyNumbers</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>  List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>      <span class="hljs-keyword">boolean</span> isMin = <span class="hljs-keyword">true</span>, isMax = <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][k]&lt;matrix[i][j])&#123;<br>          isMin = <span class="hljs-keyword">false</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!isMin)&#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;m;k++)&#123;<br>        <span class="hljs-keyword">if</span> (matrix[k][j]&gt;matrix[i][j])&#123;<br>          isMax = <span class="hljs-keyword">false</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (isMax)&#123;<br>        ans.add(matrix[i][j]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也可以先对矩阵进行预处理，求出每行的最小值和每列的最大值，然后遍历矩阵，比较每个元素是否同时等于最小值和最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">luckyNumbers</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>  List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-keyword">int</span>[] minRow = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br>  <span class="hljs-comment">// 需要先填充最大值</span><br>  Arrays.fill(minRow, Integer.MAX_VALUE);<br>  <span class="hljs-keyword">int</span>[] maxCol = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  Arrays.fill(maxCol, Integer.MIN_VALUE);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>      minRow[i] = Math.min(minRow[i],matrix[i][j]);<br>      maxCol[j] = Math.max(maxCol[j],matrix[i][j]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>      <span class="hljs-keyword">if</span> (matrix[i][j]==minRow[i]&amp;&amp;matrix[i][j]==maxCol[j])&#123;<br>        ans.add(matrix[i][j]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>136_只出现一次的数字</title>
    <link href="/2022/02/14/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/02/14/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>: [2,2,1]<br><strong>输出</strong>: 1</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>: [4,1,2,1,2]<br><strong>输出</strong>: 4</p></blockquote><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题最直观的方法就是用 hash 表存储每个出现的数字和出现的次数，最后返回出现一次的数字。或者使用集合，用集合来存储数字，如果集合中没有该数字就加入，如果有就删除，最后剩下的数字就是只出现一次的数字。</p><p>考虑到不使用额外空间来实现，可以用位计算来解决。异或运算有以下三个性质：</p><ul><li>$a\otimes a=0$</li><li>$a\otimes 0=a$</li><li>$a \otimes b \otimes a =b\otimes a \otimes a = b \otimes (a\otimes a) = b \otimes 0 = b$</li></ul><p>所以可以对数组里的全部元素进行异或，最后得到的值就是只出现一次的数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num: nums)&#123;<br>    ans ^= num;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>540_有序数组中的单一元素</title>
    <link href="/2022/02/14/540-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/"/>
    <url>/2022/02/14/540-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p><p>请你找出并返回只出现一次的那个数。</p><p>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>: nums = [1,1,2,3,3,4,4,8,8]<br><strong>输出</strong>: 2</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>: nums =  [3,3,7,7,10,11,11]<br><strong>输出</strong>: 10</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$1 &lt;= nums.length &lt;= 10^5$</li><li>$0 &lt;= nums[i] &lt;= 10^5$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>根据题目要求，时间复杂度为O(log n)，首先想到二分法</p><p>当为偶数下标时，如果它和它的下一个相同，则说明出现一次的数在后半段，否则出现在前半段。</p><p>所以定义 left 和 right，在计算 mid 的时候，可以用 <code>left + ( right - left ) / 2</code> 来替代 <code>( left + right ) / 2</code>以防止整数溢出。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = nums.length;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = n-<span class="hljs-number">1</span>,mid=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>    mid = left+(right-left)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (mid%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>      <span class="hljs-comment">// 如果mid为奇数</span><br>      mid--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[mid]==nums[mid+<span class="hljs-number">1</span>])&#123;<br>      left = mid + <span class="hljs-number">2</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      right = mid;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> nums[left];<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题_数字流的秩</title>
    <link href="/2022/02/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%95%B0%E5%AD%97%E6%B5%81%E7%9A%84%E7%A7%A9/"/>
    <url>/2022/02/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%95%B0%E5%AD%97%E6%B5%81%E7%9A%84%E7%A7%A9/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：</p><p>实现 track(int x) 方法，每读入一个数字都会调用该方法；</p><p>实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>:<br>[“StreamRank”, “getRankOfNumber”, “track”, “getRankOfNumber”]<br>[[], [1], [0], [0]]<br><strong>输出</strong>:<br>[null,0,null,1]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>x &lt;= 50000</code></li><li><code>track</code> 和 <code>getRankOfNumber</code> 方法的调用次数均不超过 2000 次</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题比较灵活，可以有多种解法，最简单的就是粗暴解法用 int 数组存储数字，数组初始化大小为最大大小 50001，每个位置存储该位置的数字个数，track 的时候就向位置 ++，求秩则从 0 加到 x。 这个方法有局限性，就是限制了添加数字的最大值。</p><p>粗暴解法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamRank</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] list;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StreamRank</span><span class="hljs-params">()</span> </span>&#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">50001</span>];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">track</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        list[x]++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRankOfNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=x;i++)&#123;<br>            ans+=list[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>二分法是效率比较高的方法，且不受添加数字大小限制，track 的时候先找到位置再添加，求秩即返回它的位置。与上面方法相比，添加比较麻烦，但是求秩效率很高。</p><p>二分法解法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamRank</span> </span>&#123;<br>  List&lt;Integer&gt; list;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StreamRank</span><span class="hljs-params">()</span> </span>&#123;<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">track</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// 找到第一个大于x的位置，插入x</span><br>    list.add(search(x), x);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRankOfNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> search(x);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = list.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>      <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (list.get(mid) &gt; x) r = mid - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1725_可以形成最大正方形的矩形数目</title>
    <link href="/2022/02/04/1725-%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/02/04/1725-%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [li, wi]</code> 表示第 <code>i</code> 个矩形的长度为 <code>li</code> 、宽度为 <code>wi</code> 。</p><p>如果存在 <code>k</code> 同时满足 <code>k &lt;= li</code> 和 <code>k &lt;= wi</code> ，就可以将第 <code>i</code> 个矩形切成边长为 <code>k</code> 的正方形。例如，矩形 <code>[4,6]</code> 可以切成边长最大为 4 的正方形。</p><p>设 maxLen 为可以从矩形数组 rectangles 切分得到的 <strong>最大正方形</strong> 的边长。</p><p>请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 <strong>数目</strong> 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：rectangles = [[5,8],[3,9],[5,12],[16,5]]<br><strong>输出</strong>：3<br><strong>解释</strong>：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。<br>最大正方形的边长为 5 ，可以由 3 个矩形切分得到。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：rectangles = [[2,3],[3,7],[4,3],[3,7]]<br><strong>输出</strong>：3</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= rectangles.length &lt;= 1000</code></li><li><code>rectangles[i].length == 2</code></li><li>$1 &lt;= l_i, w_i &lt;= 109$</li><li>$l_i != w_i$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>题意很好理解，找到每个矩形的短边，然后比较返回最大边长及其数量。</p><p>第一次提交的时候，先用一个 List 存储每个矩形的短边，然后排序，从高往低遍历，但是超时了。</p><p>第二次提交只需要遍历一遍，每次遍历先找出短边，然后与最大边长比较，相同则数量增加 1，大于最大变长则设置最大变长为当前，然后数量设置为 1 。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countGoodRectangles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] rectangles)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] rect : rectangles)&#123;<br>    <span class="hljs-keyword">int</span> min = Math.min(rect[<span class="hljs-number">0</span>],rect[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">if</span>(min&gt;max)&#123;<br>      max = min;<br>      count = <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min == max)&#123;<br>      count++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2000_反转单词前缀</title>
    <link href="/2022/02/04/2000-%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%89%8D%E7%BC%80/"/>
    <url>/2022/02/04/2000-%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。</p><p>例如，如果 <code>word = &quot;abcdefd&quot;</code> 且 <code>ch = &quot;d&quot;</code> ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。结果字符串将会是 <code>&quot;dcbaefd&quot;</code> 。<br>返回 结果字符串 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：word = “abcdefd”, ch = “d”<br><strong>输出</strong>：”dcbaefd”<br><strong>解释</strong>：”d” 第一次出现在下标 3 。<br>反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 “dcbaefd” 。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：word = “xyxzxe”, ch = “z”<br><strong>输出</strong>：”zxyxxe”<br><strong>解释</strong>：”z” 第一次也是唯一一次出现是在下标 3 。<br>反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 “zxyxxe” 。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：word = “abcd”, ch = “z”<br><strong>输出</strong>：”abcd”<br><strong>解释</strong>：”z” 不存在于 word 中。<br>无需执行反转操作，结果字符串是 “abcd” 。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= word.length &lt;= 250</code></li><li><code>word</code> 由小写英文字母组成</li><li><code>ch</code> 是一个小写英文字母</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>题目比较简单，找到第一个出现 <code>ch</code> 的位置，如果位置等于 word 的长度，则返回原字符串。否则反转 0 到 <code>ch</code> 位置的字符串。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reversePrefix</span><span class="hljs-params">(String word, <span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>  String ans = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>,n=word.length();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;word.length();i++)&#123;<br>    <span class="hljs-keyword">if</span> (word.charAt(i)==ch)&#123;<br>      pos = i;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (pos==n)&#123;<br>    <span class="hljs-keyword">return</span> word;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=pos;i++)&#123;<br>    ans = word.charAt(i)+ans;<br>  &#125;<br>  ans += word.substring(pos+<span class="hljs-number">1</span>,n);<br><br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1414_和为k的最少斐波那契数字数目</title>
    <link href="/2022/02/03/1414-%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/02/03/1414-%E5%92%8C%E4%B8%BAk%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p><p>斐波那契数字定义为：</p><ul><li>F1 = 1</li><li>F2 = 1</li><li>Fn = Fn-1 + Fn-2 ， 其中 n &gt; 2 。</li></ul><p>数据保证对于给定的 k ，一定能找到可行解。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：k = 7<br><strong>输出</strong>：2<br><strong>解释</strong>：斐波那契数字为：1，1，2，3，5，8，13，……<br>对于 k = 7 ，我们可以得到 2 + 5 = 7 。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：k = 10<br><strong>输出</strong>：2<br><strong>解释</strong>：对于 k = 10 ，我们可以得到 2 + 8 = 10 。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：k = 19<br><strong>输出</strong>：3<br><strong>解释</strong>：对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>题目要求返回和为 k 的斐波那契数字的最少数目，根据斐波那契定义，第三项为前两项的和，所以为了找到最小数目，只需要将最大项不超过 k 的斐波那契数列从后向前遍历，相加找到小于 k 的数字即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMinFibonacciNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>  List&lt;Integer&gt; fib = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>, b=<span class="hljs-number">1</span>;<br>  fib.add(a);<br>  fib.add(b);<br>  <span class="hljs-keyword">while</span> (a+b&lt;=k)&#123;<br>    <span class="hljs-keyword">int</span> c = a+b;<br>    fib.add(c);<br>    a=b;<br>    b=c;<br>  &#125;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=fib.size()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>    <span class="hljs-keyword">while</span> (k&gt;=fib.get(i)&amp;&amp;k&gt;<span class="hljs-number">0</span>)&#123;<br>      k-=fib.get(i);<br>      ans++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2048_下一个更大的数值平衡树</title>
    <link href="/2022/02/01/2048-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <url>/2022/02/01/2048-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如果整数  x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 <strong>数值平衡数</strong> 。</p><p>给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：n = 1<br><strong>输出</strong>：22<br><strong>解释</strong>：<br>22 是一个数值平衡数，因为：</p><ul><li>数字 2 出现 2 次<br>这也是严格大于 1 的最小数值平衡数。</li></ul></blockquote><p>示例一：</p><blockquote><p><strong>输入</strong>：n = 1000<br><strong>输出</strong>：1333<br><strong>解释</strong>：<br>1333 是一个数值平衡数，因为：</p><ul><li>数字 1 出现 1 次。</li><li>数字 3 出现 3 次。<br>这也是严格大于 1000 的最小数值平衡数。<br>注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。</li></ul></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：n = 3000<br><strong>输出</strong>：3133<br><strong>解释</strong>：<br>3133 是一个数值平衡数，因为：</p><ul><li>数字 1 出现 1 次。</li><li>数字 3 出现 3 次。<br>这也是严格大于 3000 的最小数值平衡数。</li></ul></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>$0 &lt;= n &lt;= 10^6$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>简单理解就是每个数字要在整数中出现它自身数值的个数</p><p>又因为这个数要大于 n</p><p>可以对数从 n+1 开始遍历，每次检查一下是否符合，否则数值 +1</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextBeautifulNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> ans = n+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(!check(ans)) ans++;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>  <span class="hljs-comment">// 余数数组，用来记录每一位出现的次数</span><br>  <span class="hljs-keyword">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>  <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">int</span> temp = num%<span class="hljs-number">10</span>;<br>    record[temp]++;<br>    num = num/<span class="hljs-number">10</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>    <span class="hljs-comment">// 找出出现过数字，但是出现次数不等于数值的返回 false</span><br>    <span class="hljs-keyword">if</span>(record[i]!=<span class="hljs-number">0</span>&amp;&amp;record[i]!=i)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1763_最长的美好子字符串</title>
    <link href="/2022/02/01/1763-%E6%9C%80%E9%95%BF%E7%9A%84%E7%BE%8E%E5%A5%BD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/02/01/1763-%E6%9C%80%E9%95%BF%E7%9A%84%E7%BE%8E%E5%A5%BD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。比方说，<code>&quot;abABB&quot;</code> 是美好字符串，因为 <code>&#39;A&#39;</code> 和 <code>&#39;a&#39;</code> 同时出现了，且 <code>&#39;B&#39;</code> 和 <code>&#39;b&#39;</code> 也同时出现了。然而，<code>&quot;abA&quot;</code> 不是美好字符串因为 <code>&#39;b&#39;</code> 出现了，而 <code>&#39;B&#39;</code> 没有出现。</p><p>给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 <strong>最早</strong> 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：s = “YazaAay”<br><strong>输出</strong>：”aAa”<br><strong>解释</strong>：”aAa” 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 ‘a’ 和大写形式 ‘A’ 也同时出现了。<br>“aAa” 是最长的美好子字符串。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：s = “Bb”<br><strong>输出</strong>：”Bb”<br><strong>解释</strong>：”Bb” 是美好字符串，因为 ‘B’ 和 ‘b’ 都出现了。整个字符串也是原字符串的子字符串。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：s = “c”<br><strong>输出</strong>：””<br><strong>解释</strong>：没有美好子字符串。</p></blockquote><p>示例四：</p><blockquote><p><strong>输入</strong>：s = “dDzeE”<br><strong>输出</strong>：”dD”<br><strong>解释</strong>：”dD” 和 “eE” 都是最长美好子字符串。<br>由于有多个美好子字符串，返回 “dD” ，因为它出现得最早。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含大写和小写英文字母</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>因为 s 的长度在 100 以内，所以考虑暴力解法</p><p>用长度进行暴力枚举，从 2 到 len, 每次比较与 ans 的长度，如果长度小于 ans ，直接跳到下一个</p><p>在判断是否美好时，用两个 HashSet 分别存储出现的大写字母和小写字母，这样只需要记录大写字母和小写字母出现过的不同种类，考虑效率可以先比较两个 HashSet 的 size 是否相同，不同直接返回 false。在向小写字母 set 添加元素时，可以先转化为大写再添加，这样就可以使用 HashSet 的 removeAll 方法，便捷地比较是否存在同一个字母的大小写。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestNiceSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = s.length();<br>  <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>  String ans = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">// 迭代长度，从2开始</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len&lt;=n;len++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i+len-<span class="hljs-number">1</span>&lt;n;i++)&#123;<br>      String temp = s.substring(i,i+len);<br>      <span class="hljs-keyword">if</span> (temp.length()&gt;ans.length() &amp;&amp; isNice(temp))&#123;<br>        ans = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;     <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNice</span><span class="hljs-params">(String word)</span></span>&#123;<br>  Set&lt;Character&gt; upperSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>  Set&lt;Character&gt; lowerSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c:word.toCharArray())&#123;<br>    <span class="hljs-keyword">if</span> (Character.isUpperCase(c))&#123;<br>      upperSet.add(c);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      lowerSet.add(Character.toUpperCase(c));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (upperSet.size()!=lowerSet.size())&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  &#125;<br>  upperSet.removeAll(lowerSet);<br>  <span class="hljs-keyword">if</span> (upperSet.size()==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>447_回旋镖的数量</title>
    <link href="/2022/01/31/447-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/31/447-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定平面上 n 对 互不相同 的点 points ，其中 <code>points[i] = [xi, yi]</code> 。回旋镖 是由点 <code>(i, j, k)</code> 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（<strong>需要考虑元组的顺序</strong>）。</p><p>返回平面上所有回旋镖的数量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：points = [[0,0],[1,0],[2,0]]<br><strong>输出</strong>：2<br><strong>解释</strong>：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：points = [[1,1],[2,2],[3,3]]<br><strong>输出</strong>：2</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：points = [[1,1]]<br><strong>输出</strong>：0</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>n == points.length</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>points[i].length == 2</code></li><li>$-10^4&lt;= x_i, y_i &lt;= 10^4$</li><li>所有点都 <strong>互不相同</strong></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题的题目比较傻逼，讲的很迷糊</p><p>可以把回旋镖理解为一个V形结构，两边变长相同</p><p><strong>回旋镖</strong> 是由点 <code>(i, j, k)</code> 表示的元组 ，其中 <code>i</code> 和 <code>j</code> 之间的距离和 <code>i</code> 和 <code>k</code> 之间的距离相等</p><p>所以可以对<code>i</code>进行枚举，找到一对和他距离相同的 <code>j</code>和<code>k</code></p><p>对每个点，计算它与 <code>i</code>点的距离，然后以距离为键值通过哈希表存储点的数量</p><p>因为题目要求考虑元组的顺序，所以<code>num</code>个与<code>i</code>点距离相同的点可以构成<code>num(num-1)</code>个元组（若不考虑顺序，则<code>num(num-1)/2</code>）</p><p>为了简化计算，欧氏距离可以不用开平方，直接计算 $x^2+y^2$ 即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = points.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n;i++)&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">if</span> (i==j)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> x = points[i][<span class="hljs-number">0</span>]-points[j][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> y = points[i][<span class="hljs-number">1</span>]-points[j][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> dist = x*x + y*y;<br>            map.put(dist,map.getOrDefault(dist,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> key: map.keySet())&#123;<br>            <span class="hljs-keyword">int</span> m = map.get(key);<br>            ans += m*(m-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1342_将数字变成0的操作次数</title>
    <link href="/2022/01/31/1342-%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%900%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/01/31/1342-%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%900%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个非负整数 <code>num</code> ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：num = 14<br><strong>输出</strong>：6<br><strong>解释</strong>：<br>步骤 1) 14 是偶数，除以 2 得到 7 。<br>步骤 2） 7 是奇数，减 1 得到 6 。<br>步骤 3） 6 是偶数，除以 2 得到 3 。<br>步骤 4） 3 是奇数，减 1 得到 2 。<br>步骤 5） 2 是偶数，除以 2 得到 1 。<br>步骤 6） 1 是奇数，减 1 得到 0 。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：num = 8<br><strong>输出</strong>：4<br><strong>解释</strong>：<br>步骤 1） 8 是偶数，除以 2 得到 4 。<br>步骤 2） 4 是偶数，除以 2 得到 2 。<br>步骤 3） 2 是偶数，除以 2 得到 1 。<br>步骤 4） 1 是奇数，减 1 得到 0 。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：num = 123<br><strong>输出</strong>：12</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>0 &lt;= num &lt;= $10^6$</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>将数字变成 0 的步骤可以分成两类，一类是偶数，需要除以 2，一类是奇数，需要减 1，并且存在一个特例 0.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfSteps</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (num!=<span class="hljs-number">0</span>)&#123;<br>        ans+=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (num%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>            num -= <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            num = num/<span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022_将一维数组转变成二维数组</title>
    <link href="/2022/01/30/2022-%E5%B0%86%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8F%98%E6%88%90%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/30/2022-%E5%B0%86%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8F%98%E6%88%90%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 <code>0</code> 开始的一维整数数组 <code>original</code> 和两个整数 <code>m</code> 和  <code>n</code> 。你需要使用 <code>original</code> 中 所有 元素创建一个 <code>m</code> 行 <code>n</code> 列的二维数组。</p><p><code>original</code> 中下标从 <code>0</code>到 <code>n - 1</code> （都 包含 ）的元素构成二维数组的第一行，下标从 <code>n</code> 到 <code>2 * n - 1</code> （都 包含 ）的元素构成二维数组的第二行，依此类推。</p><p>请你根据上述过程返回一个 <code>m x n</code> 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例：</p><blockquote><p><strong>输入</strong>：original = [1,2,3,4], m = 2, n = 2<br><strong>输出</strong>：[[1,2],[3,4]]<br><strong>解释</strong>：<br>构造出的二维数组应该包含 2 行 2 列。<br>original 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。<br>original 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：original = [1,2,3], m = 1, n = 3<br><strong>输出</strong>：[[1,2,3]]<br><strong>解释</strong>：<br>构造出的二维数组应该包含 1 行 3 列。<br>将 original 中所有三个元素放入第一行中，构成要求的二维数组。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：original = [1,2], m = 1, n = 1<br><strong>输出</strong>：[]<br><strong>解释</strong>：<br>original 中有 2 个元素。<br>无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。</p></blockquote><p>示例四：</p><blockquote><p><strong>输入</strong>：original = [3], m = 1, n = 2<br><strong>输出</strong>：[]<br><strong>解释</strong>：<br>original 中只有 1 个元素。<br>无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>1 &lt;= <code>original.length</code> &lt;= 5 * $10^4$</li><li>1 &lt;= <code>original[i]</code> &lt;= $10^5$</li><li>1 &lt;= <code>m</code>, <code>n</code> &lt;= 4 * $10^4$</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>要将一维数组转化为二维数组，首先要判断转化的元素个数是否符合规则，这里只需要判断一维数组长度是否等于二维数组的长乘以宽</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (original.length!=m*n)&#123;<br>  <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后开始遍历二维数组的每一个位置，同是遍历一维数组的元素</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>    ans[i][j] = original[id++];<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>组合即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] construct2DArray(<span class="hljs-keyword">int</span>[] original, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n) &#123;<br>  List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">if</span> (original.length!=m*n)&#123;<br>    <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>  <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>      ans[i][j] = original[id++];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>884_两句话中的不常见单词</title>
    <link href="/2022/01/30/884-%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/"/>
    <url>/2022/01/30/884-%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>句子</strong> 是一串由空格分隔的单词。每个 <strong>单词</strong> 仅由小写字母组成。</p><p>如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 <strong>没有出现</strong> ，那么这个单词就是 不常见的 。</p><p>给你两个 句子 <code>s1</code> 和 <code>s2</code> ，返回所有 <strong>不常用单词</strong> 的列表。返回列表中单词可以按 任意顺序 组织。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：s1 = “this apple is sweet”, s2 = “this apple is sour”<br><strong>输出</strong>：[“sweet”,”sour”]</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：s1 = “apple apple”, s2 = “banana”<br><strong>输出</strong>：[“banana”]</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 200</code></li><li><code>s1</code> 和 <code>s2</code> 由小写英文字母和空格组成</li><li><code>s1</code> 和 <code>s2</code> 都不含前导或尾随空格</li><li><code>s1</code> 和 <code>s2</code> 中的所有单词间均由单个空格分隔</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题根据题目意思，只要返回在两个句子中只出现一次的单词即可，所以可以用 HashMap 来记录单词和出现的次数。</p><p>为了简化计算，可以将两个 String 串用空格拼接起来 <code>String[] ab = (s1+&quot; &quot;+s2).split(&quot; &quot;);</code></p><p>遍历单词，将单词和出现的次数 put 进去</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-keyword">for</span> (String i: ab)&#123;<br>  map.put(i,map.getOrDefault(i,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后统计出只出现一次的单词</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (String key:map.keySet())&#123;<br>  <span class="hljs-keyword">if</span> (map.get(key)==<span class="hljs-number">1</span>)&#123;<br>    list.add(key);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后返回结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String[] ans = <span class="hljs-keyword">new</span> String[list.size()];<br><span class="hljs-keyword">return</span> list.toArray(ans);<br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] uncommonFromSentences(String s1, String s2) &#123;<br>  String[] ab = (s1+<span class="hljs-string">&quot; &quot;</span>+s2).split(<span class="hljs-string">&quot; &quot;</span>);<br>  Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (String i: ab)&#123;<br>    map.put(i,map.getOrDefault(i,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>  &#125;<br>  List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (String key:map.keySet())&#123;<br>    <span class="hljs-keyword">if</span> (map.get(key)==<span class="hljs-number">1</span>)&#123;<br>      list.add(key);<br>    &#125;<br>  &#125;<br>  String[] ans = <span class="hljs-keyword">new</span> String[list.size()];<br>  <span class="hljs-keyword">return</span> list.toArray(ans);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2022/01/30/Netty/"/>
    <url>/2022/01/30/Netty/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、什么是Netty"><a href="#1、什么是Netty" class="headerlink" title="1、什么是Netty"></a>1、什么是Netty</h2><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">Netty <span class="hljs-keyword">is</span> an asynchronous event-driven network <span class="hljs-built_in">application</span> framework<br><span class="hljs-keyword">for</span> rapid development <span class="hljs-keyword">of</span> maintainable high performance protocol servers &amp; clients. <br></code></pre></div></td></tr></table></figure><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p><h2 id="2、Netty的优势如果使用传统NIO，其工作量大，bug-多"><a href="#2、Netty的优势如果使用传统NIO，其工作量大，bug-多" class="headerlink" title="2、Netty的优势如果使用传统NIO，其工作量大，bug 多"></a>2、Netty的优势如果使用传统NIO，其工作量大，bug 多</h2><ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>因为bug的存在，epoll 空轮询导致 CPU 100%</li></ul><p>Netty 对 API 进行增强，使之更易用，如 </p><ul><li>FastThreadLocal =&gt; ThreadLocal</li><li>ByteBuf =&gt; ByteBuffer</li></ul><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1、服务器端代码"><a href="#1、服务器端代码" class="headerlink" title="1、服务器端代码"></a>1、服务器端代码</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1、启动器，负责装配netty组件，启动服务器</span><br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                <span class="hljs-comment">// 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector</span><br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                <span class="hljs-comment">// 3、选择服务器的 ServerSocketChannel 实现</span><br>                .channel(NioServerSocketChannel.class)<br>                <span class="hljs-comment">// 4、child 负责处理读写，该方法决定了 child 执行哪些操作</span><br>            <span class="hljs-comment">// ChannelInitializer 处理器（仅执行一次）</span><br>            <span class="hljs-comment">// 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</span><br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel nioSocketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf=&gt;String</span><br>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringDecoder());<br>                        <span class="hljs-comment">// 6、SocketChannel的业务处理，使用上一个处理器的处理结果</span><br>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(s);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                    <span class="hljs-comment">// 7、ServerSocketChannel绑定8080端口</span><br>                &#125;).bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h2 id="2、客户端代码"><a href="#2、客户端代码" class="headerlink" title="2、客户端代码"></a>2、客户端代码</h2><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClient</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                <span class="hljs-comment">// 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现</span><br>                .channel(NioSocketChannel.class)<br>                <span class="hljs-comment">// ChannelInitializer 处理器（仅执行一次）</span><br>                <span class="hljs-comment">// 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</span><br>                .<span class="hljs-keyword">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 编码发出</span><br>                        channel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 指定要连接的服务器和端口</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>                <span class="hljs-comment">// Netty 中很多方法都是异步的，如 connect</span><br>                <span class="hljs-comment">// 这时需要使用 sync 方法等待 connect 建立连接完毕</span><br>                .sync()<br>                <span class="hljs-comment">// 获取 channel 对象，它即为通道抽象，可以进行数据读写操作</span><br>                .channel()<br>                <span class="hljs-comment">// 写入消息并清空缓冲区</span><br>                .writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h2 id="3、运行流程"><a href="#3、运行流程" class="headerlink" title="3、运行流程"></a>3、运行流程</h2><p><strong>左：客户端 右：服务器端</strong></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115324.png" alt="img"></p><h3 id="组件解释"><a href="#组件解释" class="headerlink" title="组件解释"></a>组件解释</h3><ul><li><p>channel 可以理解为数据的通道</p></li><li><p>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</p></li><li><p>handler 可以理解为数据的处理工序</p><ul><li><p>工序有多道，</p><p>合在一起就是 pipeline（传递途径）</p><p>，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</p><ul><li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li></ul></li><li><p>handler 分 Inbound 和 Outbound 两类</p><ul><li>Inbound 入站</li><li>Outbound 出站</li></ul></li></ul></li><li><p>eventLoop 可以理解为处理数据的工人</p><ul><li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li><li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li></ul></li></ul><h1 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h1><h2 id="1、EventLoop"><a href="#1、EventLoop" class="headerlink" title="1、EventLoop"></a>1、EventLoop</h2><p><strong>事件循环对象</strong> EventLoop</p><p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p><p>它的继承关系如下</p><ul><li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li><li>继承自 netty 自己的 OrderedEventExecutor<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li><li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li></ul></li></ul><p><strong>事件循环组</strong> EventLoopGroup</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a>处理普通与定时任务</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TestEventLoop &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup(2)</span>;<br>        <span class="hljs-comment">// 通过next方法可以获得下一个 EventLoop</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(group.next<span class="hljs-literal">()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(group.next<span class="hljs-literal">()</span>);<br><br>        <span class="hljs-comment">// 通过EventLoop执行普通任务</span><br>        group.next<span class="hljs-literal">()</span>.execute(<span class="hljs-literal">()</span>-&gt;&#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; hello&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">// 通过EventLoop执行定时任务</span><br>        group.next<span class="hljs-literal">()</span>.schedule<span class="hljs-constructor">AtFixedRate(()</span>-&gt;&#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; hello2&quot;</span>);<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-comment">// 优雅地关闭</span><br>        group.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>输出结果如下</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">io</span>.netty.channel.nio.NioEventLoop@<span class="hljs-number">7</span>bb<span class="hljs-number">11784</span><br><span class="hljs-attribute">io</span>.netty.channel.nio.NioEventLoop@<span class="hljs-number">33</span>a<span class="hljs-number">10788</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">1</span> hello<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello<span class="hljs-number">2</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello<span class="hljs-number">2</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello<span class="hljs-number">2</span>Copy<br></code></pre></div></td></tr></table></figure><p><strong>关闭 EventLoopGroup</strong></p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务</h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MyServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>)<br>                .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                .child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                    @Override<br>                    protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">socketChannel</span>)</span> throws Exception &#123;<br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                            @Override<br>                            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; &quot;</span> + buf.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(StandardCharsets.UTF_8)</span>);<br><br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MyClient &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException, InterruptedException &#123;<br>        Channel channel = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>)<br>                .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>                    @Override<br>                    protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">socketChannel</span>)</span> throws Exception &#123;<br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringEncoder()</span>);<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, 8080)</span>)<br>                .sync<span class="hljs-literal">()</span><br>                .channel<span class="hljs-literal">()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(channel);<br>        <span class="hljs-comment">// 此处打断点调试，调用 channel.writeAndFlush(...);</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span><span class="hljs-keyword">in</span>.read<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ServerBootstrap</span>()<br>            <span class="hljs-comment">// 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-type">NioEventLoopGroup</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">NioEventLoopGroup</span>(<span class="hljs-number">2</span>))<br>            <br>...<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>多个客户端分别发送 <code>hello</code> 结果</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">1</span> hello<span class="hljs-number">1</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello<span class="hljs-number">2</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">1</span> hello<span class="hljs-number">3</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello<span class="hljs-number">4</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello<span class="hljs-number">4</span>Copy<br></code></pre></div></td></tr></table></figure><p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115514.png" alt="img"></p><h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MyServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 增加自定义的非NioEventLoopGroup</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultEventLoopGroup()</span>;<br>        <br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup(1)</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup(2)</span>)<br>                .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                .child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                    @Override<br>                    protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">socketChannel</span>)</span> throws Exception &#123;<br>                        <span class="hljs-comment">// 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理</span><br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;nioHandler&quot;</span>,<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                            @Override<br>                            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; &quot;</span> + buf.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(StandardCharsets.UTF_8)</span>);<br>                                <span class="hljs-comment">// 调用下一个handler</span><br>                                ctx.fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">msg</span>)</span>;<br>                            &#125;<br>                        &#125;)<br>                        <span class="hljs-comment">// 该handler绑定自定义的Group</span><br>                        .add<span class="hljs-constructor">Last(<span class="hljs-params">group</span>, <span class="hljs-string">&quot;myHandler&quot;</span>, <span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                            @Override<br>                            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; &quot;</span> + buf.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(StandardCharsets.UTF_8)</span>);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>启动四个客户端发送数据</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">1</span> hello<span class="hljs-number">1</span><br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">1</span> hello<span class="hljs-number">1</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">2</span> hello<span class="hljs-number">2</span><br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello<span class="hljs-number">2</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">1</span> hello<span class="hljs-number">3</span><br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">3</span> hello<span class="hljs-number">3</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">2</span> hello<span class="hljs-number">4</span><br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">4</span> hello<span class="hljs-number">4</span>Copy<br></code></pre></div></td></tr></table></figure><p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115539.png" alt="img"></p><h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p><p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">static void invoke<span class="hljs-constructor">ChannelRead(<span class="hljs-params">final</span> AbstractChannelHandlerContext <span class="hljs-params">next</span>, Object <span class="hljs-params">msg</span>)</span> &#123;<br>    final Object m = next.pipeline.touch(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectUtil</span>.</span></span>check<span class="hljs-constructor">NotNull(<span class="hljs-params">msg</span>, <span class="hljs-string">&quot;msg&quot;</span>)</span>, next);<br>    <span class="hljs-comment">// 获得下一个EventLoop, excutor 即为 EventLoopGroup</span><br>    EventExecutor executor = next.executor<span class="hljs-literal">()</span>;<br>    <br>    <span class="hljs-comment">// 如果下一个EventLoop 在当前的 EventLoopGroup中</span><br>    <span class="hljs-keyword">if</span> (executor.<span class="hljs-keyword">in</span><span class="hljs-constructor">EventLoop()</span>) &#123;<br>        <span class="hljs-comment">// 使用当前 EventLoopGroup 中的 EventLoop 来处理任务</span><br>        next.invoke<span class="hljs-constructor">ChannelRead(<span class="hljs-params">m</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行</span><br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>            public void run<span class="hljs-literal">()</span> &#123;<br>                next.invoke<span class="hljs-constructor">ChannelRead(<span class="hljs-params">m</span>)</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li></ul><h2 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h2><p>Channel 的常用方法</p><ul><li>close() 可以用来关闭Channel</li><li>closeFuture() 用来处理 Channel 的关闭<ul><li>sync 方法作用是同步等待 Channel 关闭</li><li>而 addListener 方法是异步等待 Channel 关闭</li></ul></li><li>pipeline() 方法用于添加处理器</li><li>write() 方法将数据写入<ul><li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li><li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li></ul></li><li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><h4 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h4><p><strong>拆分客户端代码</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .<span class="hljs-keyword">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>            <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <br>        <span class="hljs-comment">// 该方法用于等待连接真正建立</span><br>        channelFuture.sync();<br>        <br>        <span class="hljs-comment">// 获取客户端-服务器之间的Channel对象</span><br>        Channel channel = channelFuture.channel();<br>        channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        System.in.read();<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p><p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p><p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p><p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p><p><strong>addListener方法</strong></p><p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .<span class="hljs-keyword">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>                <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <br><span class="hljs-comment">// 当connect方法执行完毕后，也就是连接真正建立后</span><br>        <span class="hljs-comment">// 会在NIO线程中调用operationComplete方法</span><br>        channelFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Channel channel = channelFuture.channel();<br>                channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.in.read();<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="处理关闭"><a href="#处理关闭" class="headerlink" title="处理关闭"></a>处理关闭</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> ReadClient &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;<br>        <span class="hljs-comment">// 创建EventLoopGroup，使用完毕后关闭</span><br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        <br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span><br>                .group(group)<br>                .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>                    @Override<br>                    protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">socketChannel</span>)</span> throws Exception &#123;<br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringEncoder()</span>);<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, 8080)</span>);<br>        channelFuture.sync<span class="hljs-literal">()</span>;<br><br>        Channel channel = channelFuture.channel<span class="hljs-literal">()</span>;<br>        Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br><br>        <span class="hljs-comment">// 创建一个线程用于输入并向服务器发送</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                String msg = scanner.next<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;q&quot;</span>.equals(msg)) &#123;<br>                    <span class="hljs-comment">// 关闭操作是异步的，在NIO线程中执行</span><br>                    channel.close<span class="hljs-literal">()</span>;<br>                    break;<br>                &#125;<br>                channel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">msg</span>)</span>;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;inputThread&quot;</span>).start<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-comment">// 获得closeFuture对象</span><br>        ChannelFuture closeFuture = channel.close<span class="hljs-constructor">Future()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;waiting close...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 同步等待NIO线程执行完close操作</span><br>        closeFuture.sync<span class="hljs-literal">()</span>;<br>        <br>        <span class="hljs-comment">// 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;关闭之后执行一些额外操作...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 关闭EventLoopGroup</span><br>        group.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>关闭channel</strong></p><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p><p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p><ul><li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获得closeFuture对象<br>ChannelFuture closeFuture = channel.closeFuture();<br><br><span class="hljs-regexp">//</span> 同步等待NIO线程执行完close操作<br>closeFuture.sync();Copy<br></code></pre></div></td></tr></table></figure></li><li><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">closeFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> operationComplete(ChannelFuture channelFuture) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 等待channel关闭后才执行的操作</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;关闭之后执行一些额外操作...&quot;</span>);<br>        <span class="hljs-comment">// 关闭EventLoopGroup</span><br>        <span class="hljs-keyword">group</span>.shutdownGracefully();<br>    &#125;<br>&#125;);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="3、Future与Promise"><a href="#3、Future与Promise" class="headerlink" title="3、Future与Promise"></a>3、Future与Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p><p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li></ul><table><thead><tr><th>功能/名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h3 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h3><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkFuture</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) throws ExecutionException, InterruptedException &#123;<br>        ThreadFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadFactory</span>() &#123;<br>            @Override<br>            <span class="hljs-keyword">public</span> Thread <span class="hljs-keyword">new</span><span class="hljs-type">Thread</span>(Runnable r) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>(r, <span class="hljs-string">&quot;JdkFuture&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">// 创建线程池</span><br>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>,<span class="hljs-number">10</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>), factory);<br><br>        <span class="hljs-comment">// 获得Future对象</span><br>        Future&lt;Integer&gt; future = executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-type">Callable</span>&lt;Integer&gt;() &#123;<br><br>            @Override<br>            <span class="hljs-keyword">public</span> Integer call() throws Exception &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 通过阻塞的方式，获得运行结果</span><br>        System.out.println(future.<span class="hljs-keyword">get</span>());<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> NettyFuture &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) throws ExecutionException, InterruptedException &#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br><br>        <span class="hljs-comment">// 获得 EventLoop 对象</span><br>        EventLoop eventLoop = group.next<span class="hljs-literal">()</span>;<br>        Future&lt;Integer&gt; future = eventLoop.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;<span class="hljs-literal">()</span> &#123;<br>            @Override<br>            public Integer call<span class="hljs-literal">()</span> throws Exception &#123;<br>                return <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 主线程中获取结果</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; 获取结果&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;getNow &quot;</span> + future.get<span class="hljs-constructor">Now()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;get &quot;</span> + future.get<span class="hljs-literal">()</span>);<br><br>        <span class="hljs-comment">// NIO线程中异步获取结果</span><br>        future.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> GenericFutureListener&lt;Future&lt;? <span class="hljs-params">super</span> Integer&gt;&gt;()</span> &#123;<br>            @Override<br>            public void operation<span class="hljs-constructor">Complete(Future&lt;? <span class="hljs-params">super</span> Integer&gt; <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; 获取结果&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;getNow &quot;</span> + future.get<span class="hljs-constructor">Now()</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">main</span> 获取结果<br><span class="hljs-attribute">getNow</span> null<br><span class="hljs-attribute">get</span> <span class="hljs-number">50</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">1</span> 获取结果<br><span class="hljs-attribute">getNow</span> <span class="hljs-number">50</span>Copy<br></code></pre></div></td></tr></table></figure><p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p><ul><li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li><li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li><li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li></ul><h3 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h3><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> NettyPromise &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) throws ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// 创建EventLoop</span><br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        EventLoop eventLoop = group.next<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-comment">// 创建Promise对象，用于存放结果</span><br>        DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventLoop);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">SECONDS</span>.</span></span>sleep(<span class="hljs-number">1</span>);<br>            &#125; catch (InterruptedException e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br>            <span class="hljs-comment">// 自定义线程向Promise中存放结果</span><br>            promise.set<span class="hljs-constructor">Success(50)</span>;<br>        &#125;).start<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-comment">// 主线程从Promise中获取结果</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; &quot;</span> + promise.get<span class="hljs-literal">()</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h2 id="4、Handler与Pipeline"><a href="#4、Handler与Pipeline" class="headerlink" title="4、Handler与Pipeline"></a>4、Handler与Pipeline</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> PipeLineServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>)<br>                .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                .child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                    @Override<br>                    protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">socketChannel</span>)</span> throws Exception &#123;<br>                        <span class="hljs-comment">// 在socketChannel的pipeline中添加handler</span><br>                        <span class="hljs-comment">// pipeline中handler是带有head与tail节点的双向链表，的实际结构为</span><br>     <span class="hljs-comment">// head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail</span><br>                        <span class="hljs-comment">// Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法</span><br>                        <span class="hljs-comment">// 入站时，handler是从head向后调用的</span><br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;handler1&quot;</span> ,<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                            @Override<br>                            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; Inbound handler 1&quot;</span>);<br>                                <span class="hljs-comment">// 父类该方法内部会调用fireChannelRead</span><br>                                <span class="hljs-comment">// 将数据传递给下一个handler</span><br>                                super.channel<span class="hljs-constructor">Read(<span class="hljs-params">ctx</span>, <span class="hljs-params">msg</span>)</span>;<br>                            &#125;<br>                        &#125;);<br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;handler2&quot;</span>, <span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                            @Override<br>                            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; Inbound handler 2&quot;</span>);<br>                                <span class="hljs-comment">// 执行write操作，使得Outbound的方法能够得到调用</span><br>          socketChannel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">ctx</span>.<span class="hljs-params">alloc</span>()</span>.buffer<span class="hljs-literal">()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;Server...&quot;</span>.<span class="hljs-params">getBytes</span>(StandardCharsets.UTF_8)</span>));<br>                                super.channel<span class="hljs-constructor">Read(<span class="hljs-params">ctx</span>, <span class="hljs-params">msg</span>)</span>;<br>                            &#125;<br>                        &#125;);<br>                        <span class="hljs-comment">// Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法</span><br>                        <span class="hljs-comment">// 出站时，handler的调用是从tail向前调用的</span><br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;handler3&quot;</span> ,<span class="hljs-params">new</span> ChannelOutboundHandlerAdapter()</span>&#123;<br>                            @Override<br>                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; Outbound handler 1&quot;</span>);<br>                                super.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;handler4&quot;</span> ,<span class="hljs-params">new</span> ChannelOutboundHandlerAdapter()</span>&#123;<br>                            @Override<br>                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; Outbound handler 2&quot;</span>);<br>                                super.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>运行结果如下</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Inbound handler <span class="hljs-number">1</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Inbound handler <span class="hljs-number">2</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Outbound handler <span class="hljs-number">2</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Outbound handler <span class="hljs-number">1</span>Copy<br></code></pre></div></td></tr></table></figure><p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p><p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p><ul><li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul><li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li></ul></li><li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li><li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li></ul><p><strong>具体结构如下</strong></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115605.png" alt="img"></p><p><strong>调用顺序如下</strong></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115615.png" alt="img"></p><h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a>OutboundHandler</h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115625.png" alt="img"></p><h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115634.png" alt="img"></p><h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TestEmbeddedChannel &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ChannelInboundHandlerAdapter h1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChannelInboundHandlerAdapter()</span> &#123;<br>            @Override<br>            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>                super.channel<span class="hljs-constructor">Read(<span class="hljs-params">ctx</span>, <span class="hljs-params">msg</span>)</span>;<br>            &#125;<br>        &#125;;<br><br>        ChannelInboundHandlerAdapter h2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChannelInboundHandlerAdapter()</span> &#123;<br>            @Override<br>            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>                super.channel<span class="hljs-constructor">Read(<span class="hljs-params">ctx</span>, <span class="hljs-params">msg</span>)</span>;<br>            &#125;<br>        &#125;;<br><br>        ChannelOutboundHandlerAdapter h3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChannelOutboundHandlerAdapter()</span> &#123;<br>            @Override<br>            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>                super.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        ChannelOutboundHandlerAdapter h4 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChannelOutboundHandlerAdapter()</span> &#123;<br>            @Override<br>            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>                super.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 用于测试Handler的Channel</span><br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> <span class="hljs-constructor">EmbeddedChannel(<span class="hljs-params">h1</span>, <span class="hljs-params">h2</span>, <span class="hljs-params">h3</span>, <span class="hljs-params">h4</span>)</span>;<br>        <br>        <span class="hljs-comment">// 执行Inbound操作 </span><br>        channel.write<span class="hljs-constructor">Inbound(ByteBufAllocator.DEFAULT.<span class="hljs-params">buffer</span>()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-params">getBytes</span>(StandardCharsets.UTF_8)</span>));<br>        <span class="hljs-comment">// 执行Outbound操作</span><br>        channel.write<span class="hljs-constructor">Outbound(ByteBufAllocator.DEFAULT.<span class="hljs-params">buffer</span>()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-params">getBytes</span>(StandardCharsets.UTF_8)</span>));<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h2 id="5、ByteBuf"><a href="#5、ByteBuf" class="headerlink" title="5、ByteBuf"></a>5、ByteBuf</h2><p><strong>调试工具方法</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static void log(ByteBuf buffer) &#123;<br>    <span class="hljs-built_in">int</span> length = buffer.readable<span class="hljs-constructor">Bytes()</span>;<br>    <span class="hljs-built_in">int</span> rows = length<span class="hljs-operator"> / </span><span class="hljs-number">16</span> + (length % <span class="hljs-number">15</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>;<br>    StringBuilder buf = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">rows</span> <span class="hljs-operator">*</span> 80 <span class="hljs-operator">*</span> 2)</span><br>        .append(<span class="hljs-string">&quot;read index:&quot;</span>).append(buffer.reader<span class="hljs-constructor">Index()</span>)<br>        .append(<span class="hljs-string">&quot; write index:&quot;</span>).append(buffer.writer<span class="hljs-constructor">Index()</span>)<br>        .append(<span class="hljs-string">&quot; capacity:&quot;</span>).append(buffer.capacity<span class="hljs-literal">()</span>)<br>        .append(NEWLINE);<br>    append<span class="hljs-constructor">PrettyHexDump(<span class="hljs-params">buf</span>, <span class="hljs-params">buffer</span>)</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(buf.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>&#125; <br></code></pre></div></td></tr></table></figure><p>该方法可以帮助我们更为详细地查看ByteBuf中的内容</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            sb.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br>        buffer.<span class="hljs-built_in">writeBytes</span>(sb.<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">getBytes</span>(StandardCharsets.UTF_8));<br><br>        <span class="hljs-comment">// 查看写入结果</span><br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">read index:0 write index:0 capacity:16<br><br>read index:0 write index:20 capacity:64<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61 |aaaaaaaaaaaaaaaa|<br>|00000010|<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61                                     |aaaa            |<br>+--------+-------------------------------------------------+----------------+ <br></code></pre></div></td></tr></table></figure><p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p><p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p><p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p><h3 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>);Copy<br></code></pre></div></td></tr></table></figure><p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">ByteBuf buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufAllocator</span>.</span><span class="hljs-module"><span class="hljs-identifier">DEFAULT</span>.</span></span>heap<span class="hljs-constructor">Buffer(16)</span>;Copy<br></code></pre></div></td></tr></table></figure><p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">ByteBuf buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufAllocator</span>.</span><span class="hljs-module"><span class="hljs-identifier">DEFAULT</span>.</span></span>direct<span class="hljs-constructor">Buffer(16)</span>;Copy<br></code></pre></div></td></tr></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><p><strong>验证</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> ByteBufStudy &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ByteBuf buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufAllocator</span>.</span><span class="hljs-module"><span class="hljs-identifier">DEFAULT</span>.</span></span>buffer(<span class="hljs-number">16</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(buffer.get<span class="hljs-constructor">Class()</span>);<br><br>        buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufAllocator</span>.</span><span class="hljs-module"><span class="hljs-identifier">DEFAULT</span>.</span></span>heap<span class="hljs-constructor">Buffer(16)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(buffer.get<span class="hljs-constructor">Class()</span>);<br><br>        buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufAllocator</span>.</span><span class="hljs-module"><span class="hljs-identifier">DEFAULT</span>.</span></span>direct<span class="hljs-constructor">Buffer(16)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(buffer.get<span class="hljs-constructor">Class()</span>);<br>    &#125;<br>&#125; <br><span class="hljs-comment">// 使用池化的直接内存</span><br><span class="hljs-keyword">class</span> io.netty.buffer.PooledUnsafeDirectByteBuf<br>    <br><span class="hljs-comment">// 使用池化的堆内存    </span><br><span class="hljs-keyword">class</span> io.netty.buffer.PooledUnsafeHeapByteBuf<br>    <br><span class="hljs-comment">// 使用池化的直接内存    </span><br><span class="hljs-keyword">class</span> io.netty.buffer.PooledUnsafeDirectByteBufCopy<br></code></pre></div></td></tr></table></figure><h3 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm">-<span class="hljs-type">Dio</span>.netty.allocator.<span class="hljs-keyword">type</span>=&#123;unpooled|pooled&#125; <br></code></pre></div></td></tr></table></figure><ul><li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ByteBuf主要有以下几个组成部分</p><ul><li><p>最大容量与当前容量</p><ul><li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li><li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul></li><li><p>读写操作不同于ByteBuffer只用position进行控制，</p><p>ByteBuf分别由读指针和写指针两个指针控制</p><p>。进行读写操作时，无需进行模式的切换</p><ul><li>读指针前的部分被称为废弃部分，是已经读过的内容</li><li>读指针与写指针之间的空间称为可读部分</li><li>写指针与当前容量之间的空间称为可写部分</li></ul></li></ul><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115653.png" alt="img"></p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>常用方法如下</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td><strong>用一字节 01|00 代表 true|false</strong></td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 <strong>ByteBuffer</strong></td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li><li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li></ul></blockquote><p><strong>使用方法</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.<span class="hljs-built_in">writeBytes</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        buffer.<span class="hljs-built_in">writeInt</span>(<span class="hljs-number">5</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        buffer.<span class="hljs-built_in">writeIntLE</span>(<span class="hljs-number">6</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        buffer.<span class="hljs-built_in">writeLong</span>(<span class="hljs-number">7</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">read index:0 write index:0 capacity:16<br><br>read index:0 write index:4 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>read index:0 write index:8 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>read index:0 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>read index:0 write index:20 capacity:20<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|<br>|00000010| 00 00 00 07                                     |....            |<br><span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span> <br></code></pre></div></td></tr></table></figure><p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">buffer.writeLong(7);<br>ByteBufUtil.log(buffer);Copy<br>// 扩容前<br>read index:0 write index:12 capacity:16<br>...<br><br>// 扩容后<br>read index:0 write index:20 capacity:20<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 03 </span>04<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 06 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |................|<br>|00000010|<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>07                                     |....            |<br>+--------+-------------------------------------------------+----------------+ <br></code></pre></div></td></tr></table></figure><h4 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h4><ul><li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p><ul><li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li></ul></li><li><p>如果写入后数据大小超过 512 字节，则选择下一个 2</p><p>n</p><ul><li>例如写入后大小为 513 字节，则扩容后 capacity 是 210=1024 字节（29=512 已经不够了）</li></ul></li><li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IndexOutOfBoundsException: writer<span class="hljs-constructor">Index(20)</span> + min<span class="hljs-constructor">WritableBytes(8)</span> exceeds max<span class="hljs-constructor">Capacity(20)</span>: <span class="hljs-constructor">PooledUnsafeDirectByteBuf(<span class="hljs-params">ridx</span>: 0, <span class="hljs-params">widx</span>: 20, <span class="hljs-params">cap</span>: 20<span class="hljs-operator">/</span>20)</span><span class="hljs-operator"></span><br><span class="hljs-operator">... </span><br></code></pre></div></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p><p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.<span class="hljs-built_in">writeBytes</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        buffer.<span class="hljs-built_in">writeInt</span>(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 读取4个字节</span><br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">readByte</span>());<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">readByte</span>());<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">readByte</span>());<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">readByte</span>());<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        <span class="hljs-comment">// 通过mark与reset实现重复读取</span><br>        buffer.<span class="hljs-built_in">markReaderIndex</span>();<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">readInt</span>());<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        <span class="hljs-comment">// 恢复到mark标记处</span><br>        buffer.<span class="hljs-built_in">resetReaderIndex</span>();<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br>    &#125;<br>&#125; <br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>read index:<span class="hljs-number">4</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">5</span><br>read index:<span class="hljs-number">8</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br><br>read index:<span class="hljs-number">4</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+ <br></code></pre></div></td></tr></table></figure><p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p><ul><li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p></li><li><p>入站 ByteBuf 处理原则</p><ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li><li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li><li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li><li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li><p>出站 ByteBuf 处理原则</p><ul><li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li></ul></li><li><p>异常处理原则</p><ul><li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">while</span> (!buffer.<span class="hljs-built_in">release</span>()) &#123;&#125; <br></code></pre></div></td></tr></table></figure></li></ul></li></ul><p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p><p><strong>TailConext中释放ByteBuf的源码</strong></p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onUnhandledInboundMessage</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> msg</span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;</span>, msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 具体的释放方法</span><br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>判断传过来的是否为ByteBuf，是的话才需要释放</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">release</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> msg</span>)</span> &#123;<br><span class="hljs-keyword">return</span> msg <span class="hljs-keyword">instanceof</span> ReferenceCounted ? ((ReferenceCounted)msg).release() : <span class="hljs-literal">false</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p><p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p><p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115739.png" alt="img"></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSlice</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.<span class="hljs-built_in">writeBytes</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);<br><br>        <span class="hljs-comment">// 将buffer分成两部分</span><br>        ByteBuf slice1 = buffer.<span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        ByteBuf slice2 = buffer.<span class="hljs-built_in">slice</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 需要让分片的buffer引用计数加一</span><br>        <span class="hljs-comment">// 避免原Buffer释放导致分片buffer无法使用</span><br>        slice1.<span class="hljs-built_in">retain</span>();<br>        slice2.<span class="hljs-built_in">retain</span>();<br>        <br>        ByteBufUtil.<span class="hljs-built_in">log</span>(slice1);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(slice2);<br><br>        <span class="hljs-comment">// 更改原始buffer中的值</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;===========修改原buffer中的值===========&quot;</span>);<br>        buffer.<span class="hljs-built_in">setByte</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;===========打印slice1===========&quot;</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(slice1);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>===========修改原buffer中的值===========<br>===========打印slice1===========<br>read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 05 02 03 04 05                                  |.....           |<br><span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span> <br></code></pre></div></td></tr></table></figure><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li><li>可以<strong>自动扩容</strong></li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如<ul><li>slice、duplicate、CompositeByteBuf</li></ul></li></ul><h1 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h1><h2 id="1、粘包与半包"><a href="#1、粘包与半包" class="headerlink" title="1、粘包与半包"></a>1、粘包与半包</h2><h3 id="服务器代码-1"><a href="#服务器代码-1" class="headerlink" title="服务器代码"></a>服务器代码</h3><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudyServer</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">// 连接建立时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-keyword">super</span>.channelActive(ctx);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">// 连接断开时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-keyword">super</span>.channelInactive(ctx);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">8080</span>);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());<br>            channelFuture.sync();<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>            log.debug(<span class="hljs-string">&quot;stopped&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> StudyServer().start();<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p><strong>客户端代码</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudyClient</span> &#123;</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.<span class="hljs-built_in">getLogger</span>(StudyClient.class);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bootstrap</span>();<br>            bootstrap.<span class="hljs-built_in">channel</span>(NioSocketChannel.class);<br>            bootstrap.<span class="hljs-built_in">group</span>(worker);<br>            bootstrap.<span class="hljs-built_in">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                @Override<br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">initChannel</span>(SocketChannel ch) throws Exception &#123;<br>                    log.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;connected...&quot;</span>);<br>                    ch.<span class="hljs-built_in">pipeline</span>().<span class="hljs-built_in">addLast</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ChannelInboundHandlerAdapter</span>() &#123;<br>                        @Override<br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">channelActive</span>(ChannelHandlerContext ctx) throws Exception &#123;<br>                            log.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            <span class="hljs-comment">// 每次发送16个字节的数据，共发送10次</span><br>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                ByteBuf buffer = ctx.<span class="hljs-built_in">alloc</span>().<span class="hljs-built_in">buffer</span>();<br>                                buffer.<span class="hljs-built_in">writeBytes</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>                                ctx.<span class="hljs-built_in">writeAndFlush</span>(buffer);<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = bootstrap.<span class="hljs-built_in">connect</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).<span class="hljs-built_in">sync</span>();<br>            channelFuture.<span class="hljs-built_in">channel</span>().<span class="hljs-built_in">closeFuture</span>().<span class="hljs-built_in">sync</span>();<br><br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;<br>            log.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; finally &#123;<br>            worker.<span class="hljs-built_in">shutdownGracefully</span>();<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>服务器接收结果</strong></p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:/127.0.0.1:8080 - R:/127.0.0.1:53797] READ: 160B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000010|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000020|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000030|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000040|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000050|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000060|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000070|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000080|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000090|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+ <br></code></pre></div></td></tr></table></figure><p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p><h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>将客户端-服务器之间的channel容量进行调整</p><p><strong>服务器代码</strong></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 调整channel的容量<br>serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="hljs-number">10</span>);Copy<br></code></pre></div></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p></blockquote><p><strong>服务器接收结果</strong></p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 36B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000010|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000020|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000010|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000020|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b |................|<br>|00000010| 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b |................|<br>|00000020| 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000010|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000020|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 4B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 0c 0d 0e 0f                                     |....            |<br>+--------+-------------------------------------------------+----------------+ <br></code></pre></div></td></tr></table></figure><p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><ul><li>现象<ul><li>发送 abc def，接收 abcdef</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul></li></ul><h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><ul><li>现象<ul><li>发送 abcdef，接收 abc def</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 小于实际发送数据量</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li></ul></li><li>数据链路层<ul><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul></li></ul><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p><p><strong>客户端代码改进</strong></p><p>修改channelActive方法</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> throws Exception </span>&#123;<br>    log.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;sending...&quot;</span>);<br>    ByteBuf buffer = ctx.<span class="hljs-built_in">alloc</span>().<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>);<br>    buffer.<span class="hljs-built_in">writeBytes</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>    ctx.<span class="hljs-built_in">writeAndFlush</span>(buffer);<br>    <span class="hljs-comment">// 使用短链接，每次发送完毕后就断开连接</span><br>    ctx.<span class="hljs-built_in">channel</span>().<span class="hljs-built_in">close</span>();<br>&#125; <br></code></pre></div></td></tr></table></figure><p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 发送10次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">send</span>();<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 - R:/127.0.0.1:65024] ACTIVE<br><br>6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 - R:/127.0.0.1:65024] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 ! R:/127.0.0.1:65024] INACTIVE<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 - R:/127.0.0.1:65057] ACTIVE<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 - R:/127.0.0.1:65057] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 ! R:/127.0.0.1:65057] INACTIVE<br><br><span class="hljs-bullet">... </span><br></code></pre></div></td></tr></table></figure><p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p><h4 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p><p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">ch.pipeline().addLast(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(<span class="hljs-number">16</span>));<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><p><strong>客户端代码</strong></p><p>客户端发送数据的代码如下</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">// 约定最大长度为16</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">16</span>;<br><span class="hljs-comment">// 被发送的数据</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">// 向服务器发送10个报文</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    ByteBuf buffer = ctx.<span class="hljs-built_in">alloc</span>().<span class="hljs-built_in">buffer</span>(maxLength);<br>    <span class="hljs-comment">// 定长byte数组，未使用部分会以0进行填充</span><br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[maxLength];<br>    <span class="hljs-comment">// 生成长度为0~15的数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>)(Math.<span class="hljs-built_in">random</span>()*(maxLength<span class="hljs-number">-1</span>)); j++) &#123;<br>        bytes[j] = (<span class="hljs-keyword">byte</span>) c;<br>    &#125;<br>    buffer.<span class="hljs-built_in">writeBytes</span>(bytes);<br>    c++;<br>    <span class="hljs-comment">// 将数据发送给服务器</span><br>    ctx.<span class="hljs-built_in">writeAndFlush</span>(buffer);<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>服务器代码</strong></p><p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-comment">// 通过定长解码器对粘包数据进行拆分</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">FixedLengthFrameDecoder</span>(<span class="hljs-number">16</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">LoggingHandler</span>(LogLevel.DEBUG));Copy<br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><br>8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><span class="hljs-bullet">... </span><br></code></pre></div></td></tr></table></figure><h4 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p><p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)<strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p><p><strong>以换行符 \n 为分隔符</strong></p><p>客户端代码</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 约定最大长度为 64</span><br>final <span class="hljs-built_in">int</span> maxLength = <span class="hljs-number">64</span>;<br><span class="hljs-comment">// 被发送的数据</span><br><span class="hljs-built_in">char</span> c = <span class="hljs-character">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    ByteBuf buffer = ctx.alloc<span class="hljs-literal">()</span>.buffer(maxLength);<br>    <span class="hljs-comment">// 生成长度为0~62的数据</span><br>    Random random = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random()</span>;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-built_in">int</span>)(random.next<span class="hljs-constructor">Int(<span class="hljs-params">maxLength</span>-2)</span>); j++) &#123;<br>        sb.append(c);<br>    &#125;<br>    <span class="hljs-comment">// 数据以 \n 结尾</span><br>    sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-params">sb</span>.<span class="hljs-params">toString</span>()</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>);<br>    c++;<br>    <span class="hljs-comment">// 将数据发送给服务器</span><br>    ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">buffer</span>)</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>服务器代码</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-comment">// 通过行解码器对粘包数据进行拆分，以 \n 为分隔符</span><br><span class="hljs-comment">// 需要指定最大长度</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">DelimiterBasedFrameDecoder</span>(<span class="hljs-number">64</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">LoggingHandler</span>(LogLevel.DEBUG));Copy<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 10B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 11B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 2B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 63                                           |cc              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><span class="hljs-bullet">... </span><br></code></pre></div></td></tr></table></figure><p><strong>以自定义分隔符 \c 为分隔符</strong></p><p>客户端代码</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">...<br>    <br><span class="hljs-comment">// 数据以 \c 结尾</span><br>sb.append(<span class="hljs-string">&quot;\\c&quot;</span>);<br>buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-params">sb</span>.<span class="hljs-params">toString</span>()</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>);<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">... </span><br></code></pre></div></td></tr></table></figure><p>服务器代码</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 将分隔符放入ByteBuf中</span><br>ByteBuf bufSet = ch.alloc<span class="hljs-literal">()</span>.buffer<span class="hljs-literal">()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;\\c&quot;</span>.<span class="hljs-params">getBytes</span>(StandardCharsets.UTF_8)</span>);<br><span class="hljs-comment">// 通过行解码器对粘包数据进行拆分，以 \c 为分隔符</span><br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> DelimiterBasedFrameDecoder(64, <span class="hljs-params">ch</span>.<span class="hljs-params">alloc</span>()</span>.buffer<span class="hljs-literal">()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-params">bufSet</span>)</span>));<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> LoggingHandler(LogLevel.DEBUG)</span>);Copy<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 14B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><br>8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 3B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62                                        |bbb             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><span class="hljs-bullet">... </span><br></code></pre></div></td></tr></table></figure><h4 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p><p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> LengthFieldBasedFrameDecoder(<br>    <span class="hljs-built_in">int</span> maxFrameLength,<br>    <span class="hljs-built_in">int</span> lengthFieldOffset, <span class="hljs-built_in">int</span> lengthFieldLength,<br>    <span class="hljs-built_in">int</span> lengthAdjustment, <span class="hljs-built_in">int</span> initialBytesToStrip) <br></code></pre></div></td></tr></table></figure><p><strong>参数解析</strong></p><ul><li>maxFrameLength 数据最大长度<ul><li>表示数据的最大长度（包括附加信息、长度标识等内容）</li></ul></li><li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul><li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li></ul></li><li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul><li>数据中用于表示有用数据长度的标识所占的字节数</li></ul></li><li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul><li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li></ul></li><li>initialBytesToStrip <strong>数据读取起点</strong><ul><li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li></ul></li></ul><p><strong>参数图解</strong></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115811.png" alt="img"></p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">lengthFieldOffset   = 0<br>lengthFieldLength   = 2<br>lengthAdjustment    = 0<br>initialBytesToStrip = 0 (= do not strip header)<br>  <br>BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)<br>+--------+----------------+      +--------+----------------+<br>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+--------+----------------+      +--------+----------------+ <br></code></pre></div></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节</p><p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p><hr><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">lengthFieldOffset   = 0<br>lengthFieldLength   = 2<br>lengthAdjustment    = 0<br>initialBytesToStrip = 2 (= the length of the Length field)<br>  <br>BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)<br>+--------+----------------+      +----------------+<br>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+--------+----------------+      +----------------+ <br></code></pre></div></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p><p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p><hr><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">lengthFieldOffset   = 2 (= the length of Header 1)<br>lengthFieldLength   = 3<br>lengthAdjustment    = 0<br>initialBytesToStrip = 0<br>  <br>BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br>+----------+----------+----------------+      +----------+----------+----------------+<br>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+----------+----------+----------------+      +----------+----------+----------------+ <br></code></pre></div></td></tr></table></figure><p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p><p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p><hr><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">lengthFieldOffset   = 0<br>lengthFieldLength   = 3<br>lengthAdjustment    = 2 (= the length of Header 1)<br>initialBytesToStrip = 0<br>  <br>BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br>+----------+----------+----------------+      +----------+----------+----------------+<br>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+----------+----------+----------------+      +----------+----------+----------------+ <br></code></pre></div></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p><p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p><hr><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">lengthFieldOffset   = 1 (= the length of HDR1)<br>lengthFieldLength   = 2<br>lengthAdjustment    = 1 (= the length of HDR2)<br>initialBytesToStrip = 3 (= the length of HDR1 + LEN)<br>  <br>BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)<br>+------+--------+------+----------------+      +------+----------------+<br>|<span class="hljs-string"> HDR1 </span>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> HDR2 </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> HDR2 </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0xCA </span>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> 0xFE </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0xFE </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+------+--------+------+----------------+      +------+----------------+ <br></code></pre></div></td></tr></table></figure><p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p><hr><p><strong>使用</strong></p><p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncoderStudy</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟服务器</span><br>        <span class="hljs-comment">// 使用EmbeddedChannel测试handler</span><br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EmbeddedChannel</span>(<br>                <span class="hljs-comment">// 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-built_in">LengthFieldBasedFrameDecoder</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-built_in">LoggingHandler</span>(LogLevel.DEBUG)<br>        );<br><br>        <span class="hljs-comment">// 模拟客户端，写入数据</span><br>        ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>();<br>        <span class="hljs-built_in">send</span>(buffer, <span class="hljs-string">&quot;Hello&quot;</span>);<br>        channel.<span class="hljs-built_in">writeInbound</span>(buffer);<br>        <span class="hljs-built_in">send</span>(buffer, <span class="hljs-string">&quot;World&quot;</span>);<br>        channel.<span class="hljs-built_in">writeInbound</span>(buffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ByteBuf buf, <span class="hljs-keyword">String</span> msg)</span> </span>&#123;<br>        <span class="hljs-comment">// 得到数据的长度</span><br>        <span class="hljs-keyword">int</span> length = msg.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">byte</span>[] bytes = msg.<span class="hljs-built_in">getBytes</span>(StandardCharsets.UTF_8);<br>        <span class="hljs-comment">// 将数据信息写入buf</span><br>        <span class="hljs-comment">// 写入长度标识前的其他信息</span><br>        buf.<span class="hljs-built_in">writeByte</span>(<span class="hljs-number">0xCA</span>);<br>        <span class="hljs-comment">// 写入数据长度标识</span><br>        buf.<span class="hljs-built_in">writeInt</span>(length);<br>        <span class="hljs-comment">// 写入长度标识后的其他信息</span><br>        buf.<span class="hljs-built_in">writeByte</span>(<span class="hljs-number">0xFE</span>);<br>        <span class="hljs-comment">// 写入具体的数据</span><br>        buf.<span class="hljs-built_in">writeBytes</span>(bytes);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |<br><span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span> <br></code></pre></div></td></tr></table></figure><h2 id="2、协议设计与解析"><a href="#2、协议设计与解析" class="headerlink" title="2、协议设计与解析"></a>2、协议设计与解析</h2><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>TCP/IP 中消息传输基于流的方式，没有边界</p><p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p><h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守如下协议</p><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">// 该指令一共有3部分，每条指令之后都要添加回车与换行符<br>*3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>// 第一个指令的长度是3<br>$3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>// 第一个指令是set指令<br>set<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>// 下面的指令以此类推<br>$4<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>name<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>$5<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span><br>Nyima<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>Copy<br></code></pre></div></td></tr></table></figure><p><strong>客户端代码如下</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> RedisClient &#123;<br>    static final Logger log = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoggerFactory</span>.</span></span>get<span class="hljs-constructor">Logger(StudyServer.<span class="hljs-params">class</span>)</span>;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup group =  <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ChannelFuture channelFuture = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span><br>                    .group(group)<br>                    .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>                        @Override<br>                        protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> &#123;<br>                            <span class="hljs-comment">// 打印日志</span><br>                            ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> LoggingHandler(LogLevel.DEBUG)</span>);<br>                            ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                                @Override<br>                                public void channel<span class="hljs-constructor">Active(ChannelHandlerContext <span class="hljs-params">ctx</span>)</span> throws Exception &#123;<br>                                    <span class="hljs-comment">// 回车与换行符</span><br>                                    final byte<span class="hljs-literal">[]</span> LINE = &#123;<span class="hljs-character">&#x27;\r&#x27;</span>,<span class="hljs-character">&#x27;\n&#x27;</span>&#125;;<br>                                    <span class="hljs-comment">// 获得ByteBuf</span><br>                                    ByteBuf buffer = ctx.alloc<span class="hljs-literal">()</span>.buffer<span class="hljs-literal">()</span>;<br>                                    <span class="hljs-comment">// 连接建立后，向Redis中发送一条指令，注意添加回车与换行</span><br>                                    <span class="hljs-comment">// set name Nyima</span><br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;*3&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;$3&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;set&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;$4&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;$5&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;Nyima&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">buffer</span>)</span>;<br>                                &#125;<br><br>                            &#125;);<br>                        &#125;<br>                    &#125;)<br>                    .connect(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, 6379)</span>);<br>            channelFuture.sync<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel<span class="hljs-literal">()</span>.close<span class="hljs-literal">()</span>.sync<span class="hljs-literal">()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            <span class="hljs-comment">// 关闭group</span><br>            group.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>控制台打印结果</strong></p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">1600 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x28c994f1, L:/127.0.0.1:60792 - R:localhost/127.0.0.1:6379] WRITE: 34B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 2a<span class="hljs-number"> 33 </span>0d 0a<span class="hljs-number"> 24 </span>33 0d 0a<span class="hljs-number"> 73 </span>65<span class="hljs-number"> 74 </span>0d 0a<span class="hljs-number"> 24 </span>34 0d |*3..$3..set..$4.|<br>|00000010| 0a 6e<span class="hljs-number"> 61 </span>6d<span class="hljs-number"> 65 </span>0d 0a<span class="hljs-number"> 24 </span>35 0d 0a 4e<span class="hljs-number"> 79 </span>69 6d<span class="hljs-number"> 61 </span>|.name..$5..Nyima|<br>|00000020| 0d 0a                                           |..              |<br>+--------+-------------------------------------------------+----------------+ <br></code></pre></div></td></tr></table></figure><p><strong>Redis中查询执行结果</strong></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115832.png" alt="img"></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-comment">// HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder</span><br><span class="hljs-comment">// Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器</span><br>public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServerCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler&lt;HttpRequestDecoder</span>, <span class="hljs-title">HttpResponseEncoder&gt;</span></span><br>        implements <span class="hljs-type">HttpServerUpgradeHandler</span>.<span class="hljs-type">SourceCodecCopy</span><br></code></pre></div></td></tr></table></figure><p><strong>服务器代码</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> HttpServer &#123;<br>    static final Logger log = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoggerFactory</span>.</span></span>get<span class="hljs-constructor">Logger(StudyServer.<span class="hljs-params">class</span>)</span>;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span><br>                .group(group)<br>                .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                .child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                    @Override<br>                    protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> &#123;<br>                        ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> LoggingHandler(LogLevel.DEBUG)</span>);<br>                        <span class="hljs-comment">// 作为服务器，使用 HttpServerCodec 作为编码器与解码器</span><br>                        ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> HttpServerCodec()</span>);<br>                        <span class="hljs-comment">// 服务器只处理HTTPRequest</span><br>                        ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;()</span> &#123;<br>                            @Override<br>                            protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, HttpRequest <span class="hljs-params">msg</span>)</span> &#123;<br>                                <span class="hljs-comment">// 获得请求uri</span><br>                                log.debug(msg.uri<span class="hljs-literal">()</span>);<br><br>                                <span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span><br>                                DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultFullHttpResponse(<span class="hljs-params">msg</span>.<span class="hljs-params">protocolVersion</span>()</span>, HttpResponseStatus.OK);<br>                                <span class="hljs-comment">// 设置响应内容</span><br>                                byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>;<br>                                <span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span><br>                                response.headers<span class="hljs-literal">()</span>.set<span class="hljs-constructor">Int(CONTENT_LENGTH, <span class="hljs-params">bytes</span>.<span class="hljs-params">length</span>)</span>;<br>                                <span class="hljs-comment">// 设置响应体</span><br>                                response.content<span class="hljs-literal">()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-params">bytes</span>)</span>;<br><br>                                <span class="hljs-comment">// 写回响应</span><br>                                ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">response</span>)</span>;<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-comment">// 服务器只处理HTTPRequest</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() <br></code></pre></div></td></tr></table></figure><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span><br>DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultFullHttpResponse(<span class="hljs-params">msg</span>.<span class="hljs-params">protocolVersion</span>()</span>, HttpResponseStatus.OK);<br><span class="hljs-comment">// 设置响应内容</span><br>byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>;<br><span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span><br>response.headers<span class="hljs-literal">()</span>.set<span class="hljs-constructor">Int(CONTENT_LENGTH, <span class="hljs-params">bytes</span>.<span class="hljs-params">length</span>)</span>;<br><span class="hljs-comment">// 设置响应体</span><br>response.content<span class="hljs-literal">()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-params">bytes</span>)</span>;Copy<br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><p>浏览器</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115849.png" alt="img"></p><p>控制台</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">// 请求内容<br>1714 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:55503] READ: 688B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 47 </span>45<span class="hljs-number"> 54 </span>20 2f<span class="hljs-number"> 66 </span>61<span class="hljs-number"> 76 </span>69<span class="hljs-number"> 63 </span>6f 6e 2e<span class="hljs-number"> 69 </span>63 6f |GET /favicon.ico|<br>|00000010|<span class="hljs-number"> 20 </span>48<span class="hljs-number"> 54 </span>54<span class="hljs-number"> 50 </span>2f<span class="hljs-number"> 31 </span>2e<span class="hljs-number"> 31 </span>0d 0a<span class="hljs-number"> 48 </span>6f<span class="hljs-number"> 73 </span>74 3a | HTTP/1.1..Host:|<br>|00000020|<span class="hljs-number"> 20 </span>6c 6f<span class="hljs-number"> 63 </span>61 6c<span class="hljs-number"> 68 </span>6f<span class="hljs-number"> 73 </span>74 3a<span class="hljs-number"> 38 </span>30<span class="hljs-number"> 38 </span>30 0d | localhost:8080.|<br>|00000030| 0a<span class="hljs-number"> 43 </span>6f 6e 6e<span class="hljs-number"> 65 </span>63<span class="hljs-number"> 74 </span>69 6f 6e 3a<span class="hljs-number"> 20 </span>6b<span class="hljs-number"> 65 </span>65 |.Connection: kee|<br>|00000040|<span class="hljs-number"> 70 </span>2d<span class="hljs-number"> 61 </span>6c<span class="hljs-number"> 69 </span>76<span class="hljs-number"> 65 </span>0d 0a<span class="hljs-number"> 50 </span>72<span class="hljs-number"> 61 </span>67 6d<span class="hljs-number"> 61 </span>3a |p-alive..Pragma:|<br>....<br><br>// 响应内容<br>1716 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:55503] WRITE: 61B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 48 </span>54<span class="hljs-number"> 54 </span>50 2f<span class="hljs-number"> 31 </span>2e<span class="hljs-number"> 31 </span>20<span class="hljs-number"> 32 </span>30<span class="hljs-number"> 30 </span>20 4f 4b 0d |HTTP/1.1<span class="hljs-number"> 200 </span>OK.|<br>|00000010| 0a<span class="hljs-number"> 43 </span>6f 6e<span class="hljs-number"> 74 </span>65 6e<span class="hljs-number"> 74 </span>2d 4c<span class="hljs-number"> 65 </span>6e<span class="hljs-number"> 67 </span>74<span class="hljs-number"> 68 </span>3a |.Content-Length:|<br>|00000020|<span class="hljs-number"> 20 </span>32<span class="hljs-number"> 32 </span>0d 0a 0d 0a 3c<span class="hljs-number"> 68 </span>31 3e<span class="hljs-number"> 48 </span>65 6c 6c 6f | 22....&lt;h1&gt;Hello|<br>|00000030| 2c<span class="hljs-number"> 20 </span>57 6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>21 3c 2f<span class="hljs-number"> 68 </span>31 3e          |, World!&lt;/h1&gt;   |<br>+--------+-------------------------------------------------+----------------+ <br></code></pre></div></td></tr></table></figure><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><ul><li><p><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</p></li><li><p><strong>版本号</strong>：可以支持协议的升级</p></li><li><p>序列化算法</p><p>：消息正文到底采用哪种序列化反序列化方式</p><ul><li>如：json、protobuf、hessian、jdk</li></ul></li><li><p><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</p></li><li><p><strong>请求序号</strong>：为了双工通信，提供异步能力</p></li><li><p><strong>正文长度</strong></p></li><li><p><strong>消息正文</strong></p></li></ul><h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;<br><br>    @Override<br>    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;<br>        <span class="hljs-comment">// 设置魔数 4个字节</span><br>        out.write<span class="hljs-constructor">Bytes(<span class="hljs-params">new</span> <span class="hljs-params">byte</span>[]&#123;&#x27;N&#x27;,&#x27;Y&#x27;,&#x27;I&#x27;,&#x27;M&#x27;&#125;)</span>;<br>        <span class="hljs-comment">// 设置版本号 1个字节</span><br>        out.write<span class="hljs-constructor">Byte(1)</span>;<br>        <span class="hljs-comment">// 设置序列化方式 1个字节</span><br>        out.write<span class="hljs-constructor">Byte(1)</span>;<br>        <span class="hljs-comment">// 设置指令类型 1个字节</span><br>        out.write<span class="hljs-constructor">Byte(<span class="hljs-params">msg</span>.<span class="hljs-params">getMessageType</span>()</span>);<br>        <span class="hljs-comment">// 设置请求序号 4个字节</span><br>        out.write<span class="hljs-constructor">Int(<span class="hljs-params">msg</span>.<span class="hljs-params">getSequenceId</span>()</span>);<br>        <span class="hljs-comment">// 为了补齐为16个字节，填充1个字节的数据</span><br>        out.write<span class="hljs-constructor">Byte(0xff)</span>;<br><br>        <span class="hljs-comment">// 获得序列化后的msg</span><br>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ByteArrayOutputStream()</span>;<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectOutputStream(<span class="hljs-params">bos</span>)</span>;<br>        oos.write<span class="hljs-constructor">Object(<span class="hljs-params">msg</span>)</span>;<br>        byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = bos.<span class="hljs-keyword">to</span><span class="hljs-constructor">ByteArray()</span>;<br><br>        <span class="hljs-comment">// 获得并设置正文长度 长度用4个字节标识</span><br>        out.write<span class="hljs-constructor">Int(<span class="hljs-params">bytes</span>.<span class="hljs-params">length</span>)</span>;<br>        <span class="hljs-comment">// 设置消息正文</span><br>        out.write<span class="hljs-constructor">Bytes(<span class="hljs-params">bytes</span>)</span>;<br>    &#125;<br><br>    @Override<br>    protected void decode(ChannelHandlerContext ctx, ByteBuf <span class="hljs-keyword">in</span>, List&lt;Object&gt; out) throws Exception &#123;<br>        <span class="hljs-comment">// 获取魔数</span><br>        <span class="hljs-built_in">int</span> magic = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Int()</span>;<br>        <span class="hljs-comment">// 获取版本号</span><br>        byte version = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Byte()</span>;<br>        <span class="hljs-comment">// 获得序列化方式</span><br>        byte seqType = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Byte()</span>;<br>        <span class="hljs-comment">// 获得指令类型</span><br>        byte messageType = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Byte()</span>;<br>        <span class="hljs-comment">// 获得请求序号</span><br>        <span class="hljs-built_in">int</span> sequenceId = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Int()</span>;<br>        <span class="hljs-comment">// 移除补齐字节</span><br>        <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Byte()</span>;<br>        <span class="hljs-comment">// 获得正文长度</span><br>        <span class="hljs-built_in">int</span> length = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Int()</span>;<br>        <span class="hljs-comment">// 获得正文</span><br>        byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-keyword">new</span> byte<span class="hljs-literal">[<span class="hljs-identifier">length</span>]</span>;<br>        <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Bytes(<span class="hljs-params">bytes</span>, 0, <span class="hljs-params">length</span>)</span>;<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectInputStream(<span class="hljs-params">new</span> ByteArrayInputStream(<span class="hljs-params">bytes</span>)</span>);<br>        Message message = (Message) ois.read<span class="hljs-constructor">Object()</span>;<br><span class="hljs-comment">// 将信息放入List中，传递给下一个handler</span><br>        out.add(message);<br>        <br>        <span class="hljs-comment">// 打印获得的信息正文</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========魔数===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(magic);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========版本号===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(version);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========序列化方法===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(seqType);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========指令类型===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(messageType);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========请求序号===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(sequenceId);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========正文长度===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(length);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========正文===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(message);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageCodec&lt;Message&gt;Copy</span></span><br></code></pre></div></td></tr></table></figure></li><li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p></li><li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p></li></ul><p><strong>编写测试类</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TestCodec &#123;<br>    static final org.slf4j.Logger log = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoggerFactory</span>.</span></span>get<span class="hljs-constructor">Logger(StudyServer.<span class="hljs-params">class</span>)</span>;<br>    public static void main(String<span class="hljs-literal">[]</span> args) throws Exception &#123;<br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> <span class="hljs-constructor">EmbeddedChannel()</span>;<br>        <span class="hljs-comment">// 添加解码器，避免粘包半包问题</span><br>        channel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> LengthFieldBasedFrameDecoder(1024, 12, 4, 0, 0)</span>);<br>        channel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> LoggingHandler(LogLevel.DEBUG)</span>);<br>        channel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> MessageCodec()</span>);<br>        LoginRequestMessage user = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoginRequestMessage(<span class="hljs-string">&quot;Nyima&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)</span>;<br><br>        <span class="hljs-comment">// 测试编码与解码</span><br>        ByteBuf byteBuf = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufAllocator</span>.</span><span class="hljs-module"><span class="hljs-identifier">DEFAULT</span>.</span></span>buffer<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageCodec()</span>.encode(null, user, byteBuf);<br>        channel.write<span class="hljs-constructor">Inbound(<span class="hljs-params">byteBuf</span>)</span>;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li><li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li></ul><p>运行结果</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115904.png" alt="img"></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115917.png" alt="img"></p><h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.DEBUG)</span>;<br><span class="hljs-comment">// 不同的channel中使用同一个handler对象，提高复用率</span><br>channel1.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;<br>channel2.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;Copy<br></code></pre></div></td></tr></table></figure><p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p><ul><li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li><li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li></ul><p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<code>@Sharable</code>注解来标明，该handler能否在多个channel中共享。</strong></p><p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p><h4 id="自定义编解码器能否使用-Sharable注解"><a href="#自定义编解码器能否使用-Sharable注解" class="headerlink" title="自定义编解码器能否使用@Sharable注解"></a><strong>自定义编解码器能否使用@Sharable注解</strong></h4><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p><p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p><p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<code>ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared</code></p><ul><li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115931.png" alt="img"></p><p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p><ul><li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li></ul></li></ul><p><strong>如果想要共享，需要怎么办呢？</strong></p><p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-meta">@ChannelHandler</span>.<span class="hljs-type">Sharable</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageSharableCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec&lt;ByteBuf</span>, <span class="hljs-title">Message&gt;</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void encode(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">Message</span> msg, <span class="hljs-type">List</span>&lt;<span class="hljs-type">Object</span>&gt; out) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void decode(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">ByteBuf</span> msg, <span class="hljs-type">List</span>&lt;<span class="hljs-type">Object</span>&gt; out) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>...<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h2 id="3、在线聊天室"><a href="#3、在线聊天室" class="headerlink" title="3、在线聊天室"></a>3、在线聊天室</h2><h3 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h3><h4 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h4><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 登录成功返回 true, 否则返回 false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">boolean</span> login(<span class="hljs-keyword">String</span> username, <span class="hljs-keyword">String</span> password);<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h4><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Session</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 会话绑定用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> bind(Channel channel, <span class="hljs-keyword">String</span> username);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解绑会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要解绑会话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> unbind(Channel channel);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">Object</span> getAttribute(Channel channel, <span class="hljs-keyword">String</span> name);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> setAttribute(Channel channel, <span class="hljs-keyword">String</span> name, <span class="hljs-keyword">Object</span> value);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户名获取 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> channel</span><br><span class="hljs-comment">     */</span><br>    Channel getChannel(<span class="hljs-keyword">String</span> username);<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h4><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GroupSession</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> members 成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功时返回组对象, 失败返回 null</span><br><span class="hljs-comment">     */</span><br>    Group createGroup(<span class="hljs-keyword">String</span> name, Set&lt;<span class="hljs-keyword">String</span>&gt; members);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加入聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    Group joinMember(<span class="hljs-keyword">String</span> name, <span class="hljs-keyword">String</span> member);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    Group removeMember(<span class="hljs-keyword">String</span> name, <span class="hljs-keyword">String</span> member);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    Group removeGroup(<span class="hljs-keyword">String</span> name);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员集合, 如果群不存在或没有成员会返回 empty set</span><br><span class="hljs-comment">     */</span><br>    Set&lt;<span class="hljs-keyword">String</span>&gt; getMembers(<span class="hljs-keyword">String</span> name);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员 channel 集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">List</span>&lt;Channel&gt; getMembersChannel(<span class="hljs-keyword">String</span> name);<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断群聊是否一被创建</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 群聊名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">boolean</span> isCreated(<span class="hljs-keyword">String</span> name);<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130115946.png" alt="img"></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130120103.png" alt="img"></p><ul><li>client包：存放客户端相关类</li><li>message包：存放各种类型的消息</li><li>protocol包：存放自定义协议</li><li>server包：存放服务器相关类<ul><li>service包：存放用户相关类</li><li>session包：单聊及群聊相关会话类</li></ul></li></ul><h4 id="客户端代码结构"><a href="#客户端代码结构" class="headerlink" title="客户端代码结构"></a>客户端代码结构</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> ChatClient &#123;<br>    static final Logger log = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoggerFactory</span>.</span></span>get<span class="hljs-constructor">Logger(ChatClient.<span class="hljs-params">class</span>)</span>;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.DEBUG)</span>;<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageSharableCodec()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span>;<br>            bootstrap.group(group);<br>            bootstrap.channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>                @Override<br>                protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ProtocolFrameDecoder()</span>);<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">messageSharableCodec</span>)</span>;<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.connect<span class="hljs-literal">()</span>.sync<span class="hljs-literal">()</span>.channel<span class="hljs-literal">()</span>;<br>            channel.close<span class="hljs-constructor">Future()</span>.sync<span class="hljs-literal">()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>           group.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="服务器代码结构"><a href="#服务器代码结构" class="headerlink" title="服务器代码结构"></a>服务器代码结构</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> ChatServer &#123;<br>    static final Logger log = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoggerFactory</span>.</span></span>get<span class="hljs-constructor">Logger(ChatServer.<span class="hljs-params">class</span>)</span>;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.DEBUG)</span>;<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageSharableCodec()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span>;<br>            bootstrap.group(boss, worker);<br>            bootstrap.channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>);<br>            bootstrap.child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                @Override<br>                protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ProtocolFrameDecoder()</span>);<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">messageSharableCodec</span>)</span>;<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.bind(<span class="hljs-number">8080</span>).sync<span class="hljs-literal">()</span>.channel<span class="hljs-literal">()</span>;<br>            channel.close<span class="hljs-constructor">Future()</span>.sync<span class="hljs-literal">()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            boss.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>            worker.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><p>客户端添加如下handler，<strong>分别处理登录、聊天等操作</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建连接时执行的处理器，用于执行登陆操作</span><br><span class="hljs-comment">     */</span><br>    @Override<br>    public void channel<span class="hljs-constructor">Active(ChannelHandlerContext <span class="hljs-params">ctx</span>)</span> throws Exception &#123;<br>        <span class="hljs-comment">// 开辟额外线程，用于用户登陆及后续操作</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<br>            Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;请输入用户名&quot;</span>);<br>            String username = scanner.next<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;请输入密码&quot;</span>);<br>            String password = scanner.next<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 创建包含登录信息的请求体</span><br>            LoginRequestMessage message = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoginRequestMessage(<span class="hljs-params">username</span>, <span class="hljs-params">password</span>)</span>;<br>            <span class="hljs-comment">// 发送到channel中</span><br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">message</span>)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;等待后续操作...&quot;</span>);<br>            <span class="hljs-comment">// 阻塞，直到登陆成功后CountDownLatch被设置为0</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                waitLogin.await<span class="hljs-literal">()</span>;<br>            &#125; catch (InterruptedException e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br>            <span class="hljs-comment">// 执行后续操作</span><br>            <span class="hljs-keyword">if</span> (!loginStatus.get<span class="hljs-literal">()</span>) &#123;<br>                <span class="hljs-comment">// 登陆失败，关闭channel并返回</span><br>                ctx.channel<span class="hljs-literal">()</span>.close<span class="hljs-literal">()</span>;<br>                return;<br>            &#125;<br>            <span class="hljs-comment">// 登录成功后，执行其他操作</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;send [username] [content]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;gsend [group name] [content]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;gmembers [group name]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;gjoin [group name]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;gquit [group name]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;quit&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                String command = scanner.next<span class="hljs-constructor">Line()</span>;<br>                <span class="hljs-comment">// 获得指令及其参数，并发送对应类型消息</span><br>                String<span class="hljs-literal">[]</span> commands = command.split(<span class="hljs-string">&quot; &quot;</span>);<br>                switch (commands<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>)&#123;<br>                    case <span class="hljs-string">&quot;send&quot;</span>:<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> ChatRequestMessage(<span class="hljs-params">username</span>, <span class="hljs-params">commands</span>[1], <span class="hljs-params">commands</span>[2])</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;gsend&quot;</span>:<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupChatRequestMessage(<span class="hljs-params">username</span>,<span class="hljs-params">commands</span>[1], <span class="hljs-params">commands</span>[2])</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;gcreate&quot;</span>:<br>                        <span class="hljs-comment">// 分割，获得群员名</span><br>                        String<span class="hljs-literal">[]</span> members = commands<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.split(<span class="hljs-string">&quot;,&quot;</span>);<br>                        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">members</span>)</span>);<br>                        <span class="hljs-comment">// 把自己加入到群聊中</span><br>                        set.add(username);<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupCreateRequestMessage(<span class="hljs-params">commands</span>[1],<span class="hljs-params">set</span>)</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;gmembers&quot;</span>:<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupMembersRequestMessage(<span class="hljs-params">commands</span>[1])</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;gjoin&quot;</span>:<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupJoinRequestMessage(<span class="hljs-params">username</span>, <span class="hljs-params">commands</span>[1])</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;gquit&quot;</span>:<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupQuitRequestMessage(<span class="hljs-params">username</span>, <span class="hljs-params">commands</span>[1])</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;quit&quot;</span>:<br>                        ctx.channel<span class="hljs-literal">()</span>.close<span class="hljs-literal">()</span>;<br>                        return;<br>                    default:<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;指令有误，请重新输入&quot;</span>);<br>                        continue;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;login channel&quot;</span>).start<span class="hljs-literal">()</span>;<br>    &#125;<br><br>    @Override<br>    public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>        <span class="hljs-keyword">if</span> (msg instanceof LoginResponseMessage) &#123;<br>            <span class="hljs-comment">// 如果是登录响应信息</span><br>            LoginResponseMessage message = (LoginResponseMessage) msg;<br>            boolean isSuccess = message.is<span class="hljs-constructor">Success()</span>;<br>            <span class="hljs-comment">// 登录成功，设置登陆标记</span><br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                loginStatus.set(<span class="hljs-literal">true</span>);<br>            &#125;<br>            <span class="hljs-comment">// 登陆后，唤醒登陆线程</span><br>            waitLogin.count<span class="hljs-constructor">Down()</span>;<br>        &#125;<br>    &#125;<br>&#125;);Copy<br></code></pre></div></td></tr></table></figure><h4 id="服务器代码-2"><a href="#服务器代码-2" class="headerlink" title="服务器代码"></a>服务器代码</h4><p>服务器添加如下handler，并添加到对应的channel中，<strong>负责处理登录请求信息，并作出响应</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">@ChannelHandler.Sharable <span class="hljs-comment">// 必须添加该注解</span><br>public <span class="hljs-keyword">class</span> LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, LoginRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        <span class="hljs-comment">// 获得登录信息</span><br>        String username = msg.get<span class="hljs-constructor">Username()</span>;<br>        String password = msg.get<span class="hljs-constructor">Password()</span>;<br>        <span class="hljs-comment">// 校验登录信息</span><br>        boolean login = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserServiceFactory</span>.</span></span>get<span class="hljs-constructor">UserService()</span>.login(username, password);<br>        LoginResponseMessage message;<br>        <span class="hljs-keyword">if</span> (login) &#123;<br>            message = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoginResponseMessage(<span class="hljs-params">true</span>, <span class="hljs-string">&quot;登陆成功&quot;</span>)</span>;<br>            <span class="hljs-comment">// 绑定channel与user</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SessionFactory</span>.</span></span>get<span class="hljs-constructor">Session()</span>.bind(ctx.channel<span class="hljs-literal">()</span>, username);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            message = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoginResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-string">&quot;登陆失败&quot;</span>)</span>;<br>        &#125;<br>        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">message</span>)</span>;<br>    &#125;<br>&#125; <br><span class="hljs-comment">// 该handler处理登录请求</span><br>LoginRequestMessageHandler loginRequestMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoginRequestMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> LoginRequestMessageHandler()</span>);Copy<br></code></pre></div></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>客户端</strong></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">5665</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.MessageSharableCodec</span>  - <span class="hljs-number">1314474317</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">279</span><br><span class="hljs-number">5667</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.MessageSharableCodec</span>  - message:AbstractResponseMessage&#123;success=true, reason=<span class="hljs-string">&#x27;登陆成功&#x27;</span>&#125;<br><span class="hljs-number">5667</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-string">&#x27;登陆成功&#x27;</span>&#125;<br>successCopy<br></code></pre></div></td></tr></table></figure><p><strong>服务器</strong></p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 0, 0, 217<br>11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:LoginRequestMessage&#123;username=&#x27;Nyima&#x27;, password=&#x27;123&#x27;&#125;<br><br>7946 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x8e7c07f6, L:/127.0.0.1:8080 - R:/127.0.0.1:60572] WRITE: 295B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 4e<span class="hljs-number"> 59 </span>49 4d<span class="hljs-number"> 01 </span>01<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 01 </span>17 |NYIM............|<br>|00000010| ac ed<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 73 </span>72<span class="hljs-number"> 00 </span>31<span class="hljs-number"> 63 </span>6e 2e 6e<span class="hljs-number"> 79 </span>69 6d<span class="hljs-number"> 61 </span>|....sr.1cn.nyima|<br>|00000020|<span class="hljs-number"> 63 </span>2e<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 75 </span>64<span class="hljs-number"> 79 </span>2e<span class="hljs-number"> 64 </span>61<span class="hljs-number"> 79 </span>38 2e 6d<span class="hljs-number"> 65 </span>73 |c.study.day8.mes|<br>|00000030|<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 2e 4c 6f<span class="hljs-number"> 67 </span>69 6e<span class="hljs-number"> 52 </span>65<span class="hljs-number"> 73 </span>70 6f 6e |sage.LoginRespon|<br>|00000040|<span class="hljs-number"> 73 </span>65 4d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 e2<span class="hljs-number"> 34 </span>49<span class="hljs-number"> 24 </span>72<span class="hljs-number"> 52 </span>f3 |seMessage.4I$rR.|<br>|00000050|<span class="hljs-number"> 07 </span>02<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 78 </span>72<span class="hljs-number"> 00 </span>34<span class="hljs-number"> 63 </span>6e 2e 6e<span class="hljs-number"> 79 </span>69 6d<span class="hljs-number"> 61 </span>|....xr.4cn.nyima|<br>|00000060|<span class="hljs-number"> 63 </span>2e<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 75 </span>64<span class="hljs-number"> 79 </span>2e<span class="hljs-number"> 64 </span>61<span class="hljs-number"> 79 </span>38 2e 6d<span class="hljs-number"> 65 </span>73 |c.study.day8.mes|<br>|00000070|<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 2e<span class="hljs-number"> 41 </span>62<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 72 </span>61<span class="hljs-number"> 63 </span>74<span class="hljs-number"> 52 </span>65<span class="hljs-number"> 73 </span>|sage.AbstractRes|<br>|00000080|<span class="hljs-number"> 70 </span>6f 6e<span class="hljs-number"> 73 </span>65 4d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 b3 7e<span class="hljs-number"> 19 </span>32 |ponseMessage.~.2|<br>|00000090| 9b<span class="hljs-number"> 88 </span>4d 7b<span class="hljs-number"> 02 </span>00<span class="hljs-number"> 02 </span>5a<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 73 </span>75<span class="hljs-number"> 63 </span>63<span class="hljs-number"> 65 </span>73 |..M&#123;...Z..succes|<br>|000000a0|<span class="hljs-number"> 73 </span>4c<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 72 </span>65<span class="hljs-number"> 61 </span>73 6f 6e<span class="hljs-number"> 74 </span>00<span class="hljs-number"> 12 </span>4c 6a<span class="hljs-number"> 61 </span>|sL..reasont..Lja|<br>|000000b0|<span class="hljs-number"> 76 </span>61 2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69 6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 78 </span>|va/lang/String;x|<br>|000000c0|<span class="hljs-number"> 72 </span>00<span class="hljs-number"> 24 </span>63 6e 2e 6e<span class="hljs-number"> 79 </span>69 6d<span class="hljs-number"> 61 </span>63 2e<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 75 </span>|r.$cn.nyimac.stu|<br>|000000d0|<span class="hljs-number"> 64 </span>79 2e<span class="hljs-number"> 64 </span>61<span class="hljs-number"> 79 </span>38 2e 6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 2e |dy.day8.message.|<br>|000000e0| 4d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 dd e9<span class="hljs-number"> 84 </span>b7<span class="hljs-number"> 21 </span>db<span class="hljs-number"> 18 </span>52<span class="hljs-number"> 02 </span>|Message....!..R.|<br>|000000f0|<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 49 </span>00 0b 6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65<span class="hljs-number"> 54 </span>79<span class="hljs-number"> 70 </span>65 |..I..messageType|<br>|00000100|<span class="hljs-number"> 49 </span>00 0a<span class="hljs-number"> 73 </span>65<span class="hljs-number"> 71 </span>75<span class="hljs-number"> 65 </span>6e<span class="hljs-number"> 63 </span>65<span class="hljs-number"> 49 </span>64<span class="hljs-number"> 78 </span>70<span class="hljs-number"> 00 </span>|I..sequenceIdxp.|<br>|00000110|<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 74 </span>00 0c e7<span class="hljs-number"> 99 </span>bb e9<span class="hljs-number"> 99 </span>|........t.......|<br>|00000120|<span class="hljs-number"> 86 </span>e6<span class="hljs-number"> 88 </span>90 e5 8a 9f                            |.......         |<br>+--------+-------------------------------------------------+----------------+ <br></code></pre></div></td></tr></table></figure><h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理ChatRequestMessage的handler</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">@ChannelHandler.Sharable <span class="hljs-comment">// 必须添加该注解</span><br>public <span class="hljs-keyword">class</span> ChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;ChatRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, ChatRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        <span class="hljs-comment">// 获得user所在的channel</span><br>        Channel channel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SessionFactory</span>.</span></span>get<span class="hljs-constructor">Session()</span>.get<span class="hljs-constructor">Channel(<span class="hljs-params">msg</span>.<span class="hljs-params">getTo</span>()</span>);<br>        <span class="hljs-comment">// 如果双方都在线</span><br>        <span class="hljs-keyword">if</span> (channel != null) &#123;<br>            <span class="hljs-comment">// 通过接收方与服务器之间的channel发送信息</span><br>            channel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> ChatResponseMessage(<span class="hljs-params">msg</span>.<span class="hljs-params">getFrom</span>()</span>, msg.get<span class="hljs-constructor">Content()</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 通过发送方与服务器之间的channel发送消息</span><br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> ChatResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-string">&quot;对方用户不存在或离线，发送失败&quot;</span>)</span>);<br>        &#125;<br>    &#125;<br>&#125; <br><span class="hljs-comment">// 该handler处理单聊请求</span><br>ChatRequestMessageHandler chatRequestMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChatRequestMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">chatRequestMessageHandler</span>)</span>;Copy<br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><p>发送方（zhangsan）</p><figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit"><span class="hljs-built_in">send</span> Nyima helloCopy<br></code></pre></div></td></tr></table></figure><p>接收方（Nyima）</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">// 收到zhangsan发来的消息</span><br><span class="hljs-number">20230</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - ChatResponseMessage&#123;from=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attribute">content</span>=<span class="hljs-string">&#x27;hello&#x27;</span>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>添加处理<code>GroupCreateRequestMessage</code>的handler</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">@ChannelHandler.Sharable<br>public <span class="hljs-keyword">class</span> GroupCreateMessageHandler extends SimpleChannelInboundHandler&lt;GroupCreateRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, GroupCreateRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        <span class="hljs-comment">// 获得要创建的群聊名</span><br>        String groupName = msg.get<span class="hljs-constructor">GroupName()</span>;<br>        <span class="hljs-comment">// 获得要创建的群聊的成员组</span><br>        Set&lt;String&gt; members = msg.get<span class="hljs-constructor">Members()</span>;<br>        <span class="hljs-comment">// 判断该群聊是否创建过，未创建返回null并创建群聊</span><br>        Group group = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GroupSessionFactory</span>.</span></span>get<span class="hljs-constructor">GroupSession()</span>.create<span class="hljs-constructor">Group(<span class="hljs-params">groupName</span>, <span class="hljs-params">members</span>)</span>;<br>        <span class="hljs-keyword">if</span> (group<span class="hljs-operator"> == </span>null) &#123;<br>            <span class="hljs-comment">// 发送创建成功消息</span><br>            GroupCreateResponseMessage groupCreateResponseMessage = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupCreateResponseMessage(<span class="hljs-params">true</span>, <span class="hljs-params">groupName</span> + <span class="hljs-string">&quot;创建成功&quot;</span>)</span>;<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">groupCreateResponseMessage</span>)</span>;<br>            <span class="hljs-comment">// 获得在线群员的channel，给群员发送入群聊消息</span><br>            List&lt;Channel&gt; membersChannel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GroupSessionFactory</span>.</span></span>get<span class="hljs-constructor">GroupSession()</span>.get<span class="hljs-constructor">MembersChannel(<span class="hljs-params">groupName</span>)</span>;<br>            groupCreateResponseMessage = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupCreateResponseMessage(<span class="hljs-params">true</span>, <span class="hljs-string">&quot;您已被拉入&quot;</span>+<span class="hljs-params">groupName</span>)</span>;<br>            <span class="hljs-comment">// 给每个在线群员发送消息</span><br>            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;<br>                channel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">groupCreateResponseMessage</span>)</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 发送失败消息</span><br>            GroupCreateResponseMessage groupCreateResponseMessage = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupCreateResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-params">groupName</span> + <span class="hljs-string">&quot;已存在&quot;</span>)</span>;<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">groupCreateResponseMessage</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125; <br><span class="hljs-comment">// 该handler处理创建群聊请求</span><br>GroupCreateMessageHandler groupCreateMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupCreateMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">groupCreateMessageHandler</span>)</span>;Copy<br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><p>创建者客户端</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">// 首次创建</span><br>gcreate Netty学习 zhangsan,lisi<br><br><span class="hljs-number">31649</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-string">&#x27;Netty学习创建成功&#x27;</span>&#125;<br><span class="hljs-number">15244</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-string">&#x27;您已被拉入Netty学习&#x27;</span>&#125;<br><br><br><span class="hljs-comment">// 再次创建</span><br>gcreate Netty学习 zhangsan,lisi<br><span class="hljs-number">40771</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - AbstractResponseMessage&#123;success=false, reason=<span class="hljs-string">&#x27;Netty学习已存在&#x27;</span>&#125; <br></code></pre></div></td></tr></table></figure><p>群员客户端</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">28788 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-comment">&#x27;您已被拉入Netty学习&#x27;&#125; </span><br></code></pre></div></td></tr></table></figure><h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">@ChannelHandler.Sharable<br>public <span class="hljs-keyword">class</span> GroupChatMessageHandler extends SimpleChannelInboundHandler&lt;GroupChatRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, GroupChatRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        String groupName = msg.get<span class="hljs-constructor">GroupName()</span>;<br>        GroupSession groupSession = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GroupSessionFactory</span>.</span></span>get<span class="hljs-constructor">GroupSession()</span>;<br>        <span class="hljs-comment">// 判断群聊是否存在</span><br>        boolean isCreated = groupSession.is<span class="hljs-constructor">Created(<span class="hljs-params">groupName</span>)</span>;<br>        <span class="hljs-keyword">if</span> (isCreated) &#123;<br>            <span class="hljs-comment">// 给群员发送信息</span><br>            List&lt;Channel&gt; membersChannel = groupSession.get<span class="hljs-constructor">MembersChannel(<span class="hljs-params">groupName</span>)</span>;<br>            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;<br>                channel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupChatResponseMessage(<span class="hljs-params">msg</span>.<span class="hljs-params">getFrom</span>()</span>, msg.get<span class="hljs-constructor">Content()</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupChatResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-string">&quot;群聊不存在&quot;</span>)</span>);<br>        &#125;<br>    &#125;<br>&#125; <br><span class="hljs-comment">// 该handler处理群聊聊天</span><br>GroupChatMessageHandler groupChatMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupChatMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">groupChatMessageHandler</span>)</span>;Copy<br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><p>发送方（群聊存在）</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">gsend Netty学习 你们好<br><br><span class="hljs-number">45408</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - GroupChatResponseMessage&#123;from=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attribute">content</span>=<span class="hljs-string">&#x27;你们好&#x27;</span>&#125; <br></code></pre></div></td></tr></table></figure><p>接收方</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">48082 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from=<span class="hljs-comment">&#x27;zhangsan&#x27;, content=&#x27;你们好&#x27;&#125; </span><br></code></pre></div></td></tr></table></figure><p>发送方（群聊不存在）</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">gsend Spring学习 你们好<br><br>25140 [nioEventLoopGroup-2-1] <span class="hljs-builtin-name">DEBUG</span> cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;<span class="hljs-attribute">success</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">reason</span>=<span class="hljs-string">&#x27;群聊不存在&#x27;</span>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">@ChannelHandler.Sharable<br>public <span class="hljs-keyword">class</span> GroupJoinMessageHandler extends SimpleChannelInboundHandler&lt;GroupJoinRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, GroupJoinRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        GroupSession groupSession = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GroupSessionFactory</span>.</span></span>get<span class="hljs-constructor">GroupSession()</span>;<br>        <span class="hljs-comment">// 判断该用户是否在群聊中</span><br>        Set&lt;String&gt; members = groupSession.get<span class="hljs-constructor">Members(<span class="hljs-params">msg</span>.<span class="hljs-params">getGroupName</span>()</span>);<br>        boolean joinFlag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 群聊存在且用户未加入，才能加入</span><br>        <span class="hljs-keyword">if</span> (!members.contains(msg.get<span class="hljs-constructor">Username()</span>)<span class="hljs-operator"> &amp;&amp; </span>groupSession.is<span class="hljs-constructor">Created(<span class="hljs-params">msg</span>.<span class="hljs-params">getGroupName</span>()</span>)) &#123;<br>            joinFlag = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (joinFlag) &#123;<br>            <span class="hljs-comment">// 加入群聊</span><br>            groupSession.join<span class="hljs-constructor">Member(<span class="hljs-params">msg</span>.<span class="hljs-params">getGroupName</span>()</span>, msg.get<span class="hljs-constructor">Username()</span>);<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupJoinResponseMessage(<span class="hljs-params">true</span>,<span class="hljs-string">&quot;加入&quot;</span>+<span class="hljs-params">msg</span>.<span class="hljs-params">getGroupName</span>()</span>+<span class="hljs-string">&quot;成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupJoinResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-string">&quot;加入失败，群聊未存在或您已加入该群聊&quot;</span>)</span>);<br>        &#125;<br>    &#125;<br>&#125; <br><span class="hljs-comment">// 该handler处理加入群聊</span><br>GroupJoinMessageHandler groupJoinMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupJoinMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">groupJoinMessageHandler</span>)</span>;Copy<br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><p>正常加入群聊</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">94921 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-comment">&#x27;加入Netty学习成功&#x27;&#125; </span><br></code></pre></div></td></tr></table></figure><p>加入不能存在或已加入的群聊</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">44025 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=<span class="hljs-comment">&#x27;加入失败，群聊未存在或您已加入该群聊&#x27;&#125; </span><br></code></pre></div></td></tr></table></figure><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">@ChannelHandler.Sharable<br>public <span class="hljs-keyword">class</span> GroupQuitMessageHandler extends SimpleChannelInboundHandler&lt;GroupQuitRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, GroupQuitRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        GroupSession groupSession = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GroupSessionFactory</span>.</span></span>get<span class="hljs-constructor">GroupSession()</span>;<br>        String groupName = msg.get<span class="hljs-constructor">GroupName()</span>;<br>        Set&lt;String&gt; members = groupSession.get<span class="hljs-constructor">Members(<span class="hljs-params">groupName</span>)</span>;<br>        String username = msg.get<span class="hljs-constructor">Username()</span>;<br>        <span class="hljs-comment">// 判断用户是否在群聊中以及群聊是否存在</span><br>        boolean joinFlag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (groupSession.is<span class="hljs-constructor">Created(<span class="hljs-params">groupName</span>)</span><span class="hljs-operator"> &amp;&amp; </span>members.contains(username)) &#123;<br>            <span class="hljs-comment">// 可以退出</span><br>            joinFlag = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (joinFlag) &#123;<br>            <span class="hljs-comment">// 退出成功</span><br>            groupSession.remove<span class="hljs-constructor">Member(<span class="hljs-params">groupName</span>, <span class="hljs-params">username</span>)</span>;<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupQuitResponseMessage(<span class="hljs-params">true</span>, <span class="hljs-string">&quot;退出&quot;</span>+<span class="hljs-params">groupName</span>+<span class="hljs-string">&quot;成功&quot;</span>)</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 退出失败</span><br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupQuitResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-string">&quot;群聊不存在或您未加入该群，退出&quot;</span>+<span class="hljs-params">groupName</span>+<span class="hljs-string">&quot;失败&quot;</span>)</span>);<br>        &#125;<br>    &#125;<br>&#125; <br><span class="hljs-comment">// 该handler处理退出群聊</span><br>GroupQuitMessageHandler groupQuitMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupQuitMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">groupQuitMessageHandler</span>)</span>;Copy<br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><p>正常退出</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">32282 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-comment">&#x27;退出Netty学习成功&#x27;&#125; </span><br></code></pre></div></td></tr></table></figure><p>退出不存在或未加入的群聊</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">67404 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=<span class="hljs-comment">&#x27;群聊不存在或您未加入该群，退出Netty失败&#x27;&#125; </span><br></code></pre></div></td></tr></table></figure><h4 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h4><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-meta">@ChannelHandler</span>.<span class="hljs-type">Sharable</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupMembersMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler&lt;GroupMembersRequestMessage&gt;</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void channelRead0(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">GroupMembersRequestMessage</span> msg) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-type">GroupMembersResponseMessage</span>(<span class="hljs-type">GroupSessionFactory</span>.getGroupSession().getMembers(msg.getGroupName())));<br>    &#125;<br>&#125; <br><span class="hljs-comment">// 该handler处理查看成员</span><br><span class="hljs-type">GroupMembersMessageHandler</span> groupMembersMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-type">GroupMembersMessageHandler</span>();<br>ch.pipeline().addLast(groupMembersMessageHandler);<span class="hljs-type">Copy</span><br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">46557 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupMembersResponseMessage&#123;members=[zhangsan, Nyima]&#125; <br></code></pre></div></td></tr></table></figure><h3 id="退出聊天室"><a href="#退出聊天室" class="headerlink" title="退出聊天室"></a>退出聊天室</h3><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-meta">@ChannelHandler</span>.<span class="hljs-type">Sharable</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuitHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 断开连接时触发 Inactive事件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    public void channelInactive(<span class="hljs-type">ChannelHandlerContext</span> ctx) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-comment">// 解绑</span><br>        <span class="hljs-type">SessionFactory</span>.getSession().unbind(ctx.channel());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常退出，需要解绑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    public void exceptionCaught(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">Throwable</span> cause) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-comment">// 解绑</span><br>        <span class="hljs-type">SessionFactory</span>.getSession().unbind(ctx.channel());<br>    &#125;<br>&#125; <br><span class="hljs-comment">// 该handler处理退出聊天室</span><br>ch.pipeline().addLast(quitHandler);<br><span class="hljs-type">GroupMembersMessageHandler</span> groupMembersMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-type">GroupMembersMessageHandler</span>();<span class="hljs-type">Copy</span><br></code></pre></div></td></tr></table></figure><p><strong>退出时，客户端会关闭channel并返回</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br><span class="hljs-comment">// 关闭channel并返回</span><br>    ctx.<span class="hljs-built_in">channel</span>().<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span>;Copy<br></code></pre></div></td></tr></table></figure><h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p><strong>原因</strong></p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，<strong>但应用程序没有感知到</strong>，仍然占用着资源</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p><strong>问题</strong></p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以添加<code>IdleStateHandler</code>对空闲时间进行检测，通过构造函数可以传入三个参数</p><ul><li>readerIdleTimeSeconds 读空闲经过的秒数</li><li>writerIdleTimeSeconds 写空闲经过的秒数</li><li>allIdleTimeSeconds 读和写空闲经过的秒数</li></ul><p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130120137.png" alt="img"></p><ul><li>读空闲会触发<code>READER_IDLE</code></li><li>写空闲会触发<code>WRITE_IDLE</code></li><li>读和写空闲会触发<code>ALL_IDEL</code></li></ul><p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p><p><strong>服务器端代码</strong></p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 用于空闲连接的检测，5s内未读到数据，会触发READ_IDLE事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 添加双向处理器，负责处理READER_IDLE事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">ChannelDuplexHandler</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> userEventTriggered(ChannelHandlerContext ctx, <span class="hljs-built_in">Object</span> evt) throws Exception &#123;<br>        <span class="hljs-comment">// 获得事件</span><br>        IdleStateEvent event = (IdleStateEvent) evt;<br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;<br>            <span class="hljs-comment">// 断开连接</span><br>            ctx.channel().close();<br>        &#125;<br>    &#125;<br>&#125;);Copy<br></code></pre></div></td></tr></table></figure><ul><li><p>使用<code>IdleStateHandler</code>进行空闲检测</p></li><li><p>使用双向处理器</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ChannelDuplexHandler</span><br></code></pre></div></td></tr></table></figure><p>对入站与出站事件进行处理</p><ul><li><code>IdleStateHandler</code>中的事件为特殊事件，需要实现<code>ChannelDuplexHandler</code>的<code>userEventTriggered</code>方法，判断事件类型并自定义处理方式，来对事件进行处理</li></ul></li></ul><p>为<strong>避免因非网络等原因引发的READ_IDLE事件</strong>，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，<strong>直接让服务器断开连接是不可取的</strong></p><p>为避免此类情况，需要在<strong>客户端向服务器发送心跳包</strong>，发送频率要<strong>小于</strong>服务器设置的<code>IdleTimeSeconds</code>，一般设置为其值的一半</p><p><strong>客户端代码</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 发送心跳包，让服务器知道客户端在线</span><br><span class="hljs-comment">// 3s未发生WRITER_IDLE，就像服务器发送心跳包</span><br><span class="hljs-comment">// 该值为服务器端设置的READER_IDLE触发时间的一半左右</span><br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> IdleStateHandler(0, 3, 0)</span>);<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ChannelDuplexHandler()</span> &#123;<br>    @Override<br>    public void user<span class="hljs-constructor">EventTriggered(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">evt</span>)</span> throws Exception &#123;<br>        IdleStateEvent event = (IdleStateEvent) evt;<br>        <span class="hljs-keyword">if</span> (event.state<span class="hljs-literal">()</span><span class="hljs-operator"> == </span>IdleState.WRITER_IDLE) &#123;<br>            <span class="hljs-comment">// 发送心跳包</span><br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> PingMessage()</span>);<br>        &#125;<br>    &#125;<br>&#125;);Copy<br></code></pre></div></td></tr></table></figure><h1 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h1><h2 id="1、拓展序列化算法"><a href="#1、拓展序列化算法" class="headerlink" title="1、拓展序列化算法"></a>1、拓展序列化算法</h2><h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> object 被序列化的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 被序列化对象类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 序列化后的字节数组</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz 反序列化的目标类的Class对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes 被反序列化的字节数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 反序列化目标类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反序列化后的对象</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span></span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="枚举实现类"><a href="#枚举实现类" class="headerlink" title="枚举实现类"></a>枚举实现类</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public enum SerializerAlgorithm implements Serializer &#123;<br>    <span class="hljs-comment">// Java的序列化和反序列化</span><br>    Java &#123;<br>        @Override<br>        public &lt;T&gt; byte<span class="hljs-literal">[]</span> serialize(T <span class="hljs-keyword">object</span>) &#123;<br>            <span class="hljs-comment">// 序列化后的字节数组</span><br>            byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = null;<br>            <span class="hljs-keyword">try</span> (ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ByteArrayOutputStream()</span>;<br>                 ObjectOutputStream oos = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectOutputStream(<span class="hljs-params">bos</span>)</span>) &#123;<br>                oos.write<span class="hljs-constructor">Object(<span class="hljs-params">object</span>)</span>;<br>                <span class="hljs-built_in">bytes</span> = bos.<span class="hljs-keyword">to</span><span class="hljs-constructor">ByteArray()</span>;<br>            &#125; catch (IOException e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br>            return <span class="hljs-built_in">bytes</span>;<br>        &#125;<br><br>        @Override<br>        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span>) &#123;<br>            T target = null;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">bytes</span>)</span>);<br>            <span class="hljs-keyword">try</span> (ByteArrayInputStream bis = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ByteArrayInputStream(<span class="hljs-params">bytes</span>)</span>;<br>                 ObjectInputStream ois = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectInputStream(<span class="hljs-params">bis</span>)</span>) &#123;<br>                target = (T) ois.read<span class="hljs-constructor">Object()</span>;<br>            &#125; catch (IOException <span class="hljs-pattern-match">| <span class="hljs-constructor">ClassNotFoundException</span> e) &#123;</span><br><span class="hljs-pattern-match">                e.print<span class="hljs-constructor">StackTrace()</span>;</span><br><span class="hljs-pattern-match">            &#125;</span><br><span class="hljs-pattern-match">            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 返回反序列化后的对象</span><br><span class="hljs-pattern-match">            return target;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">    </span><br><span class="hljs-pattern-match">     <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-constructor">Json</span>的序列化和反序列化</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">Json</span> &#123;</span><br><span class="hljs-pattern-match">        @<span class="hljs-constructor">Override</span></span><br><span class="hljs-pattern-match">        public &lt;<span class="hljs-constructor">T</span>&gt; byte[] serialize(<span class="hljs-constructor">T</span> <span class="hljs-keyword">object</span>) &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">object</span>)</span>;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">System</span>.out.println(s);</span><br><span class="hljs-pattern-match">            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 指定字符集，获得字节数组</span><br><span class="hljs-pattern-match">            return s.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        @<span class="hljs-constructor">Override</span></span><br><span class="hljs-pattern-match">        public &lt;<span class="hljs-constructor">T</span>&gt; <span class="hljs-constructor">T</span> deserialize(<span class="hljs-constructor">Class</span>&lt;<span class="hljs-constructor">T</span>&gt; clazz, byte[] <span class="hljs-built_in">bytes</span>) &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">bytes</span>, StandardCharsets.UTF_8)</span>;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">System</span>.out.println(s);</span><br><span class="hljs-pattern-match">            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 此处的clazz为具体类型的<span class="hljs-constructor">Class</span>对象，而不是父类<span class="hljs-constructor">Message</span>的</span><br><span class="hljs-pattern-match">            return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>.from<span class="hljs-constructor">Json(<span class="hljs-params">s</span>, <span class="hljs-params">clazz</span>)</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125; </span><br></code></pre></div></td></tr></table></figure><h3 id="修改原编解码器"><a href="#修改原编解码器" class="headerlink" title="修改原编解码器"></a>修改原编解码器</h3><p><strong>编码</strong></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获得序列化后的msg<br><span class="hljs-regexp">//</span> 使用指定的序列化方式<br>SerializerAlgorithm[] values = SerializerAlgorithm.values();<br><span class="hljs-regexp">//</span> 获得序列化后的对象<br>byte[] bytes = values[out.getByte(<span class="hljs-number">5</span>)-<span class="hljs-number">1</span>].serialize(msg);Copy<br></code></pre></div></td></tr></table></figure><p><strong>解码</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 获得反序列化方式</span><br>SerializerAlgorithm<span class="hljs-literal">[]</span> values = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SerializerAlgorithm</span>.</span></span>values<span class="hljs-literal">()</span>;<br><span class="hljs-comment">// 通过指定方式进行反序列化</span><br><span class="hljs-comment">// 需要通过Message的方法获得具体的消息类型</span><br>Message message = values<span class="hljs-literal">[<span class="hljs-identifier">seqType</span>-<span class="hljs-number">1</span>]</span>.deserialize(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Message</span>.</span></span>get<span class="hljs-constructor">MessageClass(<span class="hljs-params">messageType</span>)</span>, <span class="hljs-built_in">bytes</span>);Copy<br></code></pre></div></td></tr></table></figure><h2 id="2、参数调优"><a href="#2、参数调优" class="headerlink" title="2、参数调优"></a>2、参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul><li>属于 <strong>SocketChannal</strong> 的参数</li><li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li><li><strong>注意</strong>：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestParam</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Bootstrap</span>().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);<br>        <br>        <span class="hljs-comment">// ServerSocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ServerBootstrap</span>().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,<span class="hljs-number">5000</span>);<br>        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ServerBootstrap</span>().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li><p>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong></p></li><li><p>服务器通过</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ServerBootstrap</span><br></code></pre></div></td></tr></table></figure><p>来配置参数，但是对于不同的 Channel 需要选择不同的方法</p><ul><li>通过 <code>option</code> 来配置 <strong>ServerSocketChannel</strong> 上的参数</li><li>通过 <code>childOption</code> 来配置 <strong>SocketChannel</strong> 上的参数</li></ul></li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p><p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <br>    ...<br>        <br>    <span class="hljs-comment">// Schedule connect timeout.</span><br>    <span class="hljs-comment">// 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置</span><br>    <span class="hljs-keyword">int</span> connectTimeoutMillis = <span class="hljs-built_in">config</span>().<span class="hljs-built_in">getConnectTimeoutMillis</span>();<br>    <span class="hljs-comment">// 如果超时时间大于0</span><br>    <span class="hljs-keyword">if</span> (connectTimeoutMillis &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行</span><br>        <span class="hljs-comment">// schedule(Runnable command, long delay, TimeUnit unit)</span><br>        connectTimeoutFuture = <span class="hljs-built_in">eventLoop</span>().<span class="hljs-built_in">schedule</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Runnable</span>() &#123;<br>            @Override<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br>                <span class="hljs-comment">// 判断是否建立连接，Promise进行NIO线程与主线程之间的通信</span><br>                <span class="hljs-comment">// 如果超时，则通过tryFailure方法将异常放入Promise中</span><br>                <span class="hljs-comment">// 在主线程中抛出</span><br>                ChannelPromise connectPromise = AbstractNioChannel.<span class="hljs-keyword">this</span>.connectPromise;<br>                ConnectTimeoutException cause = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConnectTimeoutException</span>(<span class="hljs-string">&quot;connection timed out: &quot;</span> + remoteAddress);<br>                <span class="hljs-keyword">if</span> (connectPromise != null &amp;&amp; connectPromise.<span class="hljs-built_in">tryFailure</span>(cause)) &#123;<br>                    <span class="hljs-built_in">close</span>(<span class="hljs-built_in">voidPromise</span>());<br>                &#125;<br>            &#125;<br>        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);<br>    &#125;<br>    <br>   ...<br>        <br>&#125; <br></code></pre></div></td></tr></table></figure><p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p><ul><li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li><li>如果指定时间内没有建立连接，则会执行其中的任务<ul><li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li></ul></li></ul><h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><p>该参数是 <strong>ServerSocketChannel</strong> 的参数</p><h4 id="三次握手与连接队列"><a href="#三次握手与连接队列" class="headerlink" title="三次握手与连接队列"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130120204.png" alt="img"></p><p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130120805.png" alt="img"></p><p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130120227.png" alt="img"></p><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p><ul><li>半连接队列 - sync queue<ul><li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li>全连接队列 - accept queue<ul><li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p><p><strong>设置方式如下</strong></p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-comment">// 设置全连接队列，大小为2</span><br><span class="hljs-keyword">new</span> ServerBootstrap().option(ChannelOption.SO_BACKLOG, <span class="hljs-number">2</span>);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">@Override<br>protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind(SocketAddress <span class="hljs-params">localAddress</span>)</span> throws Exception &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PlatformDependent</span>.</span></span>java<span class="hljs-constructor">Version()</span> &gt;= <span class="hljs-number">7</span>) &#123;<br>        java<span class="hljs-constructor">Channel()</span>.bind(localAddress, config.get<span class="hljs-constructor">Backlog()</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        java<span class="hljs-constructor">Channel()</span>.socket<span class="hljs-literal">()</span>.bind(localAddress, config.get<span class="hljs-constructor">Backlog()</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> backlog = NetUtil.SOMAXCONN;<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><p>具体的赋值操作如下</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">SOMAXCONN = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AccessController</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Privileged(<span class="hljs-params">new</span> PrivilegedAction&lt;Integer&gt;()</span> &#123;<br>    @Override<br>    public Integer run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-comment">// Determine the default somaxconn (server socket backlog) value of the platform.</span><br>        <span class="hljs-comment">// The known defaults:</span><br>        <span class="hljs-comment">// - Windows NT Server 4.0+: 200</span><br>        <span class="hljs-comment">// - Linux and Mac OS X: 128</span><br>        <span class="hljs-built_in">int</span> somaxconn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PlatformDependent</span>.</span></span>is<span class="hljs-constructor">Windows()</span> ? <span class="hljs-number">200</span> : <span class="hljs-number">128</span>;<br>        File file = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-string">&quot;/proc/sys/net/core/somaxconn&quot;</span>)</span>;<br>        BufferedReader <span class="hljs-keyword">in</span> = null;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the</span><br>            <span class="hljs-comment">// try / catch block.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/4936</span><br>            <span class="hljs-keyword">if</span> (file.exists<span class="hljs-literal">()</span>) &#123;<br>                <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BufferedReader(<span class="hljs-params">new</span> FileReader(<span class="hljs-params">file</span>)</span>);<br>                <span class="hljs-comment">// 将somaxconn设置为Linux配置文件中设置的值</span><br>                somaxconn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">in</span>.<span class="hljs-params">readLine</span>()</span>);<br>                <span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">DebugEnabled()</span>) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, file, somaxconn);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">                ...</span><br><span class="hljs-operator">            </span>&#125;<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">        </span>&#125;  <br>        <span class="hljs-comment">// 返回backlog的值</span><br>        return somaxconn;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li><p>backlog的值会根据操作系统的不同，来</p><p>选择不同的默认值</p><ul><li>Windows 200</li><li>Linux/Mac OS 128</li></ul></li><li><p><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</p></li></ul><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li><li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li></ul><h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul><li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li><li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li><li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li></ul><h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-comment">// 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型</span><br><span class="hljs-comment">// 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型</span><br><span class="hljs-keyword">new</span> <span class="hljs-type">ServerBootstrap</span>().childOption(ChannelOption.ALLOCATOR, <span class="hljs-keyword">new</span> <span class="hljs-type">PooledByteBufAllocator</span>());Copy<br></code></pre></div></td></tr></table></figure><p><strong>ByteBufAllocator类型</strong></p><ul><li><p>池化并使用直接内存</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-comment">// true表示使用直接内存</span><br><span class="hljs-keyword">new</span> PooledByteBufAllocator(<span class="hljs-keyword">true</span>);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure></li><li><p>池化并使用堆内存</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-comment">// false表示使用堆内存</span><br><span class="hljs-keyword">new</span> PooledByteBufAllocator(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure></li><li><p>非池化并使用直接内存</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-comment">// ture表示使用直接内存</span><br><span class="hljs-keyword">new</span> UnpooledByteBufAllocator(<span class="hljs-keyword">true</span>);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure></li><li><p>非池化并使用堆内存</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-comment">// false表示使用堆内存</span><br><span class="hljs-keyword">new</span> UnpooledByteBufAllocator(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li><strong>控制 Netty 接收缓冲区大小</strong></li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li></ul><h2 id="3、RPC框架"><a href="#3、RPC框架" class="headerlink" title="3、RPC框架"></a>3、RPC框架</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在聊天室代码的基础上进行一定的改进</p><p><strong>Message</strong>中添加如下代码</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    ...<br><br>    <span class="hljs-comment">// 添加RPC消息类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> RPC_MESSAGE_TYPE_REQUEST = <span class="hljs-number">101</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span>  RPC_MESSAGE_TYPE_RESPONSE = <span class="hljs-number">102</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 将消息类型放入消息类对象Map中</span><br>        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.<span class="hljs-keyword">class</span>);<br>        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.<span class="hljs-keyword">class</span>);<br>    &#125;<br><br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>RPC请求消息</strong></p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequestMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用的接口全限定名，服务端根据它找到实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> interfaceName;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用接口中的方法名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> methodName;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法返回类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class&lt;?&gt; returnType;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数类型数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class[] parameterTypes;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数值数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Object</span>[] parameterValue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">RpcRequestMessage</span>(<span class="hljs-params">int sequenceId, <span class="hljs-built_in">String</span> interfaceName, <span class="hljs-built_in">String</span> methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, <span class="hljs-built_in">Object</span>[] parameterValue</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setSequenceId(sequenceId);<br>        <span class="hljs-built_in">this</span>.interfaceName = interfaceName;<br>        <span class="hljs-built_in">this</span>.methodName = methodName;<br>        <span class="hljs-built_in">this</span>.returnType = returnType;<br>        <span class="hljs-built_in">this</span>.parameterTypes = parameterTypes;<br>        <span class="hljs-built_in">this</span>.parameterValue = parameterValue;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">getMessageType</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;<br>    &#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getInterfaceName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> interfaceName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getMethodName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> methodName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; <span class="hljs-function"><span class="hljs-title">getReturnType</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> returnType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Class[] <span class="hljs-function"><span class="hljs-title">getParameterTypes</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> parameterTypes;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span>[] <span class="hljs-function"><span class="hljs-title">getParameterValue</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> parameterValue;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RpcRequestMessage&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;interfaceName=&#x27;&quot;</span> + interfaceName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, methodName=&#x27;&quot;</span> + methodName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, returnType=&quot;</span> + returnType +<br>                <span class="hljs-string">&quot;, parameterTypes=&quot;</span> + Arrays.toString(parameterTypes) +<br>                <span class="hljs-string">&quot;, parameterValue=&quot;</span> + Arrays.toString(parameterValue) +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>想要远程调用一个方法，必须知道以<strong>下五个信息</strong></p><ul><li>方法所在的全限定类名</li><li>方法名</li><li>方法返回值类型</li><li>方法参数类型</li><li>方法参数值</li></ul><p><strong>RPC响应消息</strong></p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Object</span> returnValue;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Exception exceptionValue;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">getMessageType</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setReturnValue</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> returnValue</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.returnValue = returnValue;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setExceptionValue</span>(<span class="hljs-params">Exception exceptionValue</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.exceptionValue = exceptionValue;<br>    &#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">getReturnValue</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> returnValue;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Exception <span class="hljs-function"><span class="hljs-title">getExceptionValue</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> exceptionValue;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RpcResponseMessage&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;returnValue=&quot;</span> + returnValue +<br>                <span class="hljs-string">&quot;, exceptionValue=&quot;</span> + exceptionValue +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>响应消息中只需要获取<strong>返回结果和异常值</strong></p><p><strong>服务器</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> RPCServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.DEBUG)</span>;<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageSharableCodec()</span>;<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcRequestMessageHandler rpcRequestMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RpcRequestMessageHandler()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span>;<br>            serverBootstrap.channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                @Override<br>                protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ProtocolFrameDecoder()</span>);<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">messageSharableCodec</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">rpcRequestMessageHandler</span>)</span>;<br>                &#125;<br>            &#125;);<br>            Channel channel = serverBootstrap.bind(<span class="hljs-number">8080</span>).sync<span class="hljs-literal">()</span>.channel<span class="hljs-literal">()</span>;<br>            channel.close<span class="hljs-constructor">Future()</span>.sync<span class="hljs-literal">()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            boss.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>            worker.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>服务器中添加了<strong>处理RPCRequest消息的handler</strong></p><p><strong>客户端</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> RPCClient &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.DEBUG)</span>;<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageSharableCodec()</span>;<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RpcResponseMessageHandler()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span>;<br>            bootstrap.channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>);<br>            bootstrap.group(group);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>                @Override<br>                protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ProtocolFrameDecoder()</span>);<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">messageSharableCodec</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">rpcResponseMessageHandler</span>)</span>;<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.connect(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, 8080)</span>).sync<span class="hljs-literal">()</span>.channel<span class="hljs-literal">()</span>;<br>            channel.close<span class="hljs-constructor">Future()</span>.sync<span class="hljs-literal">()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            group.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>通过接口Class获取实例对象的<strong>Factory</strong></p><figure class="highlight processing"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> class ServicesFactory &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">HashMap</span>&lt;Class&lt;?&gt;, <span class="hljs-keyword">Object</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">Object</span> getInstance(Class&lt;?&gt; interfaceClass) <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException &#123;<br>        <span class="hljs-comment">// 根据Class创建实例</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloService&quot;</span>);<br>            <span class="hljs-keyword">Object</span> instance = Class.forName(<span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloServiceImpl&quot;</span>).newInstance();<br>           <br>            <span class="hljs-comment">// 放入 InterfaceClass -&gt; InstanceObject 的映射</span><br>            <span class="hljs-built_in">map</span>.put(clazz, instance);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(interfaceClass);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="RpcRequestMessageHandler"><a href="#RpcRequestMessageHandler" class="headerlink" title="RpcRequestMessageHandler"></a>RpcRequestMessageHandler</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">@ChannelHandler.Sharable<br>public <span class="hljs-keyword">class</span> RpcRequestMessageHandler extends SimpleChannelInboundHandler&lt;RpcRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, RpcRequestMessage <span class="hljs-params">rpcMessage</span>)</span> &#123;<br>        RpcResponseMessage rpcResponseMessage = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RpcResponseMessage()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 设置返回值的属性</span><br>            rpcResponseMessage.set<span class="hljs-constructor">SequenceId(<span class="hljs-params">rpcMessage</span>.<span class="hljs-params">getSequenceId</span>()</span>);<br>            <span class="hljs-comment">// 返回一个实例</span><br>            HelloService service = (HelloService) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServicesFactory</span>.</span></span>get<span class="hljs-constructor">Instance(Class.<span class="hljs-params">forName</span>(<span class="hljs-params">rpcMessage</span>.<span class="hljs-params">getInterfaceName</span>()</span>));<br>            <br>            <span class="hljs-comment">// 通过反射调用方法，并获取返回值</span><br>            Method <span class="hljs-keyword">method</span> = service.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">Method(<span class="hljs-params">rpcMessage</span>.<span class="hljs-params">getMethodName</span>()</span>, rpcMessage.get<span class="hljs-constructor">ParameterTypes()</span>);<br>            <span class="hljs-comment">// 获得返回值</span><br>            Object invoke = <span class="hljs-keyword">method</span>.invoke(service, rpcMessage.get<span class="hljs-constructor">ParameterValue()</span>);<br>            <span class="hljs-comment">// 设置返回值</span><br>            rpcResponseMessage.set<span class="hljs-constructor">ReturnValue(<span class="hljs-params">invoke</span>)</span>;<br>        &#125; catch (Exception e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>            <span class="hljs-comment">// 设置异常</span><br>            rpcResponseMessage.set<span class="hljs-constructor">ExceptionValue(<span class="hljs-params">e</span>)</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 向channel中写入Message</span><br>    ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">rpcResponseMessage</span>)</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>远程调用方法主要是通过反射实现的，大致步骤如下</p><ul><li>通过<strong>请求消息传入被调入方法的各个参数</strong></li><li>通过<strong>全限定接口名，在map中查询到对应的类并实例化对象</strong></li><li>通过反射获取Method，并调用其invoke方法的<strong>返回值，并放入响应消息中</strong></li><li>若有<strong>异常需要捕获，并放入响应消息中</strong></li></ul><h3 id="RpcResponseMessageHandler"><a href="#RpcResponseMessageHandler" class="headerlink" title="RpcResponseMessageHandler"></a>RpcResponseMessageHandler</h3><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-meta">@ChannelHandler</span>.<span class="hljs-type">Sharable</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler&lt;RpcResponseMessage&gt;</span> </span>&#123;<br>    static <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> log = <span class="hljs-type">LoggerFactory</span>.getLogger(<span class="hljs-type">ChatServer</span>.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void channelRead0(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">RpcResponseMessage</span> msg) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>        <span class="hljs-type">System</span>.out.println((<span class="hljs-type">String</span>)msg.getReturnValue());<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClient</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>...<br>           <br>        <span class="hljs-comment">// 创建请求并发送</span><br>RpcRequestMessage message = <span class="hljs-keyword">new</span> RpcRequestMessage(<span class="hljs-number">1</span>,<br>               <span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloService&quot;</span>,<br>               <span class="hljs-string">&quot;sayHello&quot;</span>,<br>               <span class="hljs-keyword">String</span>.<span class="hljs-keyword">class</span>,<br>               <span class="hljs-keyword">new</span> <span class="hljs-class"><span class="hljs-keyword">Class</span>[]</span>&#123;<span class="hljs-keyword">String</span>.<span class="hljs-keyword">class</span>&#125;,<br>               <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>[]&#123;<span class="hljs-string">&quot;Nyima&quot;</span>&#125;);<br><br>        channel.writeAndFlush(message);   <br>            <br>        ...    <br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>运行结果</strong></p><p>客户端</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1606 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.server.ChatServer  - RpcResponseMessage&#123;returnValue=你好，Nyima, exceptionValue=null&#125; <br></code></pre></div></td></tr></table></figure><h3 id="改进客户端"><a href="#改进客户端" class="headerlink" title="改进客户端"></a>改进客户端</h3><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RPCClientManager</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 产生SequenceId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger sequenceId = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Channel channel = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Object <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-comment">// 创建代理对象</span><br>        HelloService service = (HelloService) getProxy(HelloService.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-comment">// 通过代理对象执行方法</span><br>        System.<span class="hljs-keyword">out</span>.println(service.sayHello(<span class="hljs-string">&quot;Nyima&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.println(service.sayHello(<span class="hljs-string">&quot;Hulu&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例模式创建Channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title">getChannel</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;<br>            synchronized (<span class="hljs-keyword">lock</span>) &#123;<br>                <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">init</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> channel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用代理模式，帮助我们创建请求消息并发送</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span>(<span class="hljs-params">Class&lt;?&gt; serviceClass</span>)</span> &#123;<br>        Class&lt;?&gt;[] classes = <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;serviceClass&#125;;<br>        <span class="hljs-comment">// 使用JDK代理，创建代理对象</span><br>        Object o = Proxy.newProxyInstance(serviceClass.getClassLoader(), classes, <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>            @Override<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span>(<span class="hljs-params">Object proxy, Method method, Object[] args</span>) throws Throwable</span> &#123;<br>                <span class="hljs-comment">// 创建请求消息</span><br>                <span class="hljs-built_in">int</span> id = sequenceId.getAndIncrement();<br>                RpcRequestMessage message = <span class="hljs-keyword">new</span> RpcRequestMessage(id, serviceClass.getName(),<br>                        method.getName(), method.getReturnType(),<br>                        method.getParameterTypes(),<br>                        args);<br>                <span class="hljs-comment">// 发送消息</span><br>                getChannel().writeAndFlush(message);<br><br>                <span class="hljs-comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span><br>                DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());<br>                <span class="hljs-comment">// 将Promise放入Map中</span><br>                RpcResponseMessageHandler.promiseMap.put(id, promise);<br>                <span class="hljs-comment">// 等待被放入Promise中结果</span><br>                promise.<span class="hljs-keyword">await</span>();<br>                <span class="hljs-keyword">if</span> (promise.isSuccess()) &#123;<br>                    <span class="hljs-comment">// 调用方法成功，返回方法执行结果</span><br>                    <span class="hljs-keyword">return</span> promise.getNow();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 调用方法失败，抛出异常</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(promise.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;<br>        NioEventLoopGroup <span class="hljs-keyword">group</span> = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="hljs-keyword">new</span> RpcResponseMessageHandler();<br><br>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>        bootstrap.channel(NioSocketChannel.<span class="hljs-keyword">class</span>);<br>        bootstrap.<span class="hljs-keyword">group</span>(<span class="hljs-keyword">group</span>);<br>        bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            @Override<br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span>(<span class="hljs-params">SocketChannel ch</span>) throws Exception</span> &#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                ch.pipeline().addLast(loggingHandler);<br>                ch.pipeline().addLast(messageSharableCodec);<br>                ch.pipeline().addLast(rpcResponseMessageHandler);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">try</span> &#123;<br>            channel = bootstrap.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)).sync().channel();<br>            <span class="hljs-comment">// 异步关闭 group，避免Channel被阻塞</span><br>            channel.closeFuture().addListener(future -&gt; &#123;<br>                <span class="hljs-keyword">group</span>.shutdownGracefully();<br>            &#125;);<br>        &#125; catch (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>获得Channel</strong></p><ul><li>建立连接，获取Channel的操作被封装到了<code>init</code>方法中，当连接断开时，通过<code>addListener</code>方<strong>法异步关闭group</strong></li><li>通过<strong>单例模式</strong>创建与获取Channel</li></ul><p><strong>远程调用方法</strong></p><ul><li>为了让方法的调用变得简洁明了，将<code>RpcRequestMessage</code>的<strong>创建与发送过程通过JDK的动态代理来完成</strong></li><li>通过返回的代理对象调用方法即可，<strong>方法参数为被调用方法接口的Class类</strong></li></ul><p><strong>远程调用方法返回值获取</strong></p><ul><li><p>调用方法的是主线程，处理返回结果的是NIO线程（RpcResponseMessageHandler）。<strong>要在不同线程中进行返回值的传递，需要用到Promise</strong></p></li><li><p>在<code>RpcResponseMessageHandler</code>中创建一个Map</p><ul><li>Key为<strong>SequenceId</strong></li><li>Value为对应的<strong>Promise</strong></li></ul></li><li><p><strong>主线程</strong>的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。<strong>需要使用await等待结果被放入Promise中</strong>。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span><br>DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(get<span class="hljs-constructor">Channel()</span>.event<span class="hljs-constructor">Loop()</span>);<br><span class="hljs-comment">// 将Promise放入Map中</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RpcResponseMessageHandler</span>.</span></span>promiseMap.put(id, promise);<br><span class="hljs-comment">// 等待被放入Promise中结果</span><br>promise.await<span class="hljs-literal">()</span>;<br><span class="hljs-keyword">if</span> (promise.is<span class="hljs-constructor">Success()</span>) &#123;<br>    <span class="hljs-comment">// 调用方法成功，返回方法执行结果</span><br>    return promise.get<span class="hljs-constructor">Now()</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 调用方法失败，抛出异常</span><br>    throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-params">promise</span>.<span class="hljs-params">cause</span>()</span>);<br>&#125; <br></code></pre></div></td></tr></table></figure></li><li><p><strong>NIO线程</strong>负责通过SequenceId<strong>获取并移除（remove）</strong>对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值</p><ul><li>如果<strong>没有异常信息</strong>（ExceptionValue），就调用<code>promise.setSuccess(returnValue)</code>放入方法返回值</li><li>如果<strong>有异常信息</strong>，就调用<code>promise.setFailure(exception)</code>放入异常信息</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span><br>Promise&lt;Object&gt; promise = promiseMap.remove(msg.get<span class="hljs-constructor">SequenceId()</span>);<br>Object returnValue = msg.get<span class="hljs-constructor">ReturnValue()</span>;<br>Exception <span class="hljs-keyword">exception</span> = msg.get<span class="hljs-constructor">ExceptionValue()</span>;<br><span class="hljs-keyword">if</span> (promise != null) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">exception</span> != null) &#123;<br>        <span class="hljs-comment">// 返回结果中有异常信息</span><br>        promise.set<span class="hljs-constructor">Failure(<span class="hljs-params">exception</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 方法正常执行，没有异常</span><br>        promise.set<span class="hljs-constructor">Success(<span class="hljs-params">returnValue</span>)</span>;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure></li></ul><h3 id="改进RpcResponseMessageHandler"><a href="#改进RpcResponseMessageHandler" class="headerlink" title="改进RpcResponseMessageHandler"></a>改进RpcResponseMessageHandler</h3><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">@ChannelHandler.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcResponseMessage</span>&gt; </span>&#123;<br>    <span class="hljs-built_in">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于存放Promise的集合，Promise用于主线程与NIO线程之间传递返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> Map&lt;<span class="hljs-keyword">Integer</span>, Promise&lt;<span class="hljs-keyword">Object</span>&gt;&gt; promiseMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);<br><br>    @Override<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws <span class="hljs-built_in">Exception</span> &#123;<br>        <span class="hljs-comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span><br>        Promise&lt;<span class="hljs-keyword">Object</span>&gt; promise = promiseMap.remove(msg.getSequenceId());<br>        <span class="hljs-keyword">Object</span> returnValue = msg.getReturnValue();<br>        <span class="hljs-built_in">Exception</span> <span class="hljs-built_in">exception</span> = msg.getExceptionValue();<br>        <span class="hljs-keyword">if</span> (promise != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exception</span> != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 返回结果中有异常信息</span><br>                promise.setFailure(<span class="hljs-built_in">exception</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 方法正常执行，没有异常</span><br>                promise.setSuccess(returnValue);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 拿到返回结果并打印</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h1 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h1><h2 id="1、启动流程"><a href="#1、启动流程" class="headerlink" title="1、启动流程"></a>1、启动流程</h2><p>Netty启动流程可以简化成如下代码</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span><br>Selector selector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Selector</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>; <br><br><span class="hljs-comment">// 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span><br>NioServerSocketChannel attachment = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioServerSocketChannel()</span>;<br><br><span class="hljs-comment">// 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span><br>ServerSocketChannel serverSocketChannel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>; <br>serverSocketChannel.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br><br><span class="hljs-comment">// 启动 nio boss 线程执行接下来的操作</span><br><br><span class="hljs-comment">//注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span><br>SelectionKey selectionKey = serverSocketChannel.register(selector, <span class="hljs-number">0</span>, attachment);<br><br><span class="hljs-comment">// head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span><br><br><span class="hljs-comment">// 绑定端口</span><br>serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(8080)</span>);<br><br><span class="hljs-comment">// 触发 channel active 事件，在 head 中关注 op_accept 事件</span><br>selectionKey.interest<span class="hljs-constructor">Ops(SelectionKey.OP_ACCEPT)</span>;Copy<br></code></pre></div></td></tr></table></figure><ul><li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li><li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li><li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li><li>绑定端口</li><li>通过<code>interestOps</code>设置感兴趣的事件</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p><p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public ChannelFuture bind(SocketAddress localAddress) &#123;<br>validate<span class="hljs-literal">()</span>;<br>return <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind(ObjectUtil.<span class="hljs-params">checkNotNull</span>(<span class="hljs-params">localAddress</span>, <span class="hljs-string">&quot;localAddress&quot;</span>)</span>);<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="doBind"><a href="#doBind" class="headerlink" title="doBind"></a>doBind</h3><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p><p><strong>dobind方法在主线程中执行</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind(<span class="hljs-params">final</span> SocketAddress <span class="hljs-params">localAddress</span>)</span> &#123;<br>    <span class="hljs-comment">// 负责NioServerSocketChannel和ServerSocketChannel的创建</span><br>    <span class="hljs-comment">// ServerSocketChannel的注册工作</span><br>    <span class="hljs-comment">// init由main线程完成，regisetr由NIO线程完成</span><br>    final ChannelFuture regFuture = init<span class="hljs-constructor">AndRegister()</span>;<br>    final Channel channel = regFuture.channel<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (regFuture.cause<span class="hljs-literal">()</span> != null) &#123;<br>        return regFuture;<br>    &#125;<br><br>    <span class="hljs-comment">// 因为register操作是异步的</span><br>    <span class="hljs-comment">// 所以要判断主线程执行到这里时，register操作是否已经执行完毕</span><br>    <span class="hljs-keyword">if</span> (regFuture.is<span class="hljs-constructor">Done()</span>) &#123;<br>        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span><br>        ChannelPromise promise = channel.<span class="hljs-keyword">new</span><span class="hljs-constructor">Promise()</span>;<br>        <br>        <span class="hljs-comment">// 执行doBind0绑定操作</span><br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">regFuture</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br>        return promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br>        <span class="hljs-comment">// 如果register操作还没执行完，就会到这个分支中来</span><br>        final PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PendingRegistrationPromise(<span class="hljs-params">channel</span>)</span>;<br>        <br>        <span class="hljs-comment">// 添加监听器，NIO线程异步进行doBind0操作</span><br>        regFuture.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>            @Override<br>            public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>                Throwable cause = future.cause<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">if</span> (cause != null) &#123;<br>                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>                    promise.set<span class="hljs-constructor">Failure(<span class="hljs-params">cause</span>)</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>                    promise.registered<span class="hljs-literal">()</span>;<br><br>                    <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">regFuture</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        return promise;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li><li><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作</li><li><strong>doBind0</strong>则负责连接的创建工作</li></ul><h3 id="initAndRegisterd"><a href="#initAndRegisterd" class="headerlink" title="initAndRegisterd"></a>initAndRegisterd</h3><p>代码</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">final ChannelFuture init<span class="hljs-constructor">AndRegister()</span> &#123;<br>    Channel channel = null;<br>    <span class="hljs-keyword">try</span> &#123;<br>        channel = channelFactory.<span class="hljs-keyword">new</span><span class="hljs-constructor">Channel()</span>;<br>        init(channel);<br>    &#125; catch (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (channel != null) &#123;<br>            <span class="hljs-comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br>            channel.unsafe<span class="hljs-literal">()</span>.close<span class="hljs-constructor">Forcibly()</span>;<br>            <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>            return <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultChannelPromise(<span class="hljs-params">channel</span>, GlobalEventExecutor.INSTANCE)</span>.set<span class="hljs-constructor">Failure(<span class="hljs-params">t</span>)</span>;<br>        &#125;<br>        <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultChannelPromise(<span class="hljs-params">new</span> FailedChannel()</span>, GlobalEventExecutor.INSTANCE).set<span class="hljs-constructor">Failure(<span class="hljs-params">t</span>)</span>;<br>    &#125;<br><br>    ChannelFuture regFuture = config<span class="hljs-literal">()</span>.group<span class="hljs-literal">()</span>.register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause<span class="hljs-literal">()</span> != null) &#123;<br>        <span class="hljs-keyword">if</span> (channel.is<span class="hljs-constructor">Registered()</span>) &#123;<br>            channel.close<span class="hljs-literal">()</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe<span class="hljs-literal">()</span>.close<span class="hljs-constructor">Forcibly()</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span><br>    <span class="hljs-comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span><br>    <span class="hljs-comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span><br>    <span class="hljs-comment">//    added to the event loop&#x27;s task queue for later execution.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span><br>    <span class="hljs-comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span><br>    <span class="hljs-comment">//         because register(), bind(), and connect() are all bound to the same thread.</span><br><br>    return regFuture;<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">Channel channel = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 通过反射初始化NioServerSocketChannel</span><br>    channel = channelFactory.<span class="hljs-keyword">new</span><span class="hljs-type">Channel</span>();<br>    init(channel);<br>&#125; <br></code></pre></div></td></tr></table></figure><p>newChannel方法</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">newChannel</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 通过反射调用NioServerSocketChannel的构造方法</span><br>        <span class="hljs-comment">// 创建NioServerSocketChannel对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title">constructor</span>.<span class="hljs-title">newInstance</span>(<span class="hljs-params"></span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + <span class="hljs-title">constructor</span>.<span class="hljs-title">getDeclaringClass</span>(<span class="hljs-params"></span>), <span class="hljs-title">t</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>NioServerSocketChannel构造方法</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> NioServerSocketChannel() &#123;<br>    <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>    <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Socket</span>(DEFAULT_SELECTOR_PROVIDER));<br>&#125; <br></code></pre></div></td></tr></table></figure><p>newSocket方法</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerSocketChannel <span class="hljs-keyword">new</span><span class="hljs-type">Socket</span>(SelectorProvider provider) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ServerSocketChannel.open方法：</span><br>        <span class="hljs-comment">// SelectorProvider.provider().openServerSocketChannel()</span><br>    <span class="hljs-comment">// 所以此处相当于ServerSocketChannel.open()</span><br>        <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>    <span class="hljs-keyword">return</span> provider.openServerSocketChannel();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ChannelException</span>(<span class="hljs-string">&quot;Failed to open a server socket.&quot;</span>, e);<br>&#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>init方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>   ...<br><br>    <span class="hljs-comment">// NioSocketChannl的Pipeline    </span><br>    ChannelPipeline p = channel.pipeline();<br><br>    ...<br><br>    <span class="hljs-comment">// 向Pipeline中添加了一个handler，该handler等待被调用</span><br>    p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// register之后才调用该方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>            <br>            <span class="hljs-comment">// 创建handler并加入到pipeline中</span><br>            ChannelHandler <span class="hljs-keyword">handler</span> = config.<span class="hljs-keyword">handler</span>();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">handler</span> != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.addLast(<span class="hljs-keyword">handler</span>);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 添加新的handler，在发生Accept事件后建立连接</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>init主要完成了以下三个操作</strong></p><ul><li><p>创建NioServerSocketChannel</p></li><li><p>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</p></li><li><p>由</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">initChannel</span><br></code></pre></div></td></tr></table></figure><p>方法向NioServerSocketChannel中添加了两个handler，</p><p>添加操作在register之后被执行</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accepet事件后建立连接</li></ul></li></ul><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p><p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p><p><strong>promise.channel().unsafe().register(this, promise)</strong></p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> final <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params">EventLoop eventLoop, final ChannelPromise promise</span>)</span> &#123;<br>    ...<br><br>    <span class="hljs-comment">// 获取EventLoop</span><br>    AbstractChannel.this.eventLoop = eventLoop;<br><br>   <span class="hljs-comment">// 此处完成了由 主线程 到 NIO线程 的切换</span><br>    <span class="hljs-comment">// eventLoop.inEventLoop()用于判断当前线程是否为NIO线程</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 向NIO线程中添加任务</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>                    <span class="hljs-comment">// 该方法中会执行doRegister</span><br>                    <span class="hljs-comment">// 执行真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>           ...<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>register0方法</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">register0</span>(<span class="hljs-params">ChannelPromise promise</span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>       ...<br>            <br>        <span class="hljs-comment">// 执行真正的注册操作</span><br>        doRegister();<br>        neverRegistered = <span class="hljs-literal">false</span>;<br>        registered = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span><br>        <br>        <span class="hljs-comment">// 调用init中的initChannel方法</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br><br>        ...<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        ...<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>doRegister方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// javaChannel()即为ServerSocketChannel</span><br>            <span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><br>            <span class="hljs-comment">// this为NIOServerSocketChannel，作为附件</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            ...<br>           <br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>回调initChannel</p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>    ChannelHandler <span class="hljs-keyword">handler</span> = config.<span class="hljs-keyword">handler</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">handler</span> != <span class="hljs-keyword">null</span>) &#123;<br>        pipeline.addLast(<span class="hljs-keyword">handler</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加新任务，任务负责添加handler</span><br>    <span class="hljs-comment">// 该handler负责发生Accepet事件后建立连接</span><br>    ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>        &#125;<br>    &#125;);<br>&#125; <br></code></pre></div></td></tr></table></figure><p>Register主要完成了以下三个操作</p><ul><li><p>完成了主线程到NIO的<strong>线程切换</strong></p><ul><li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li><li>切换的方式为让eventLoop执行register的操作</li><li><strong>register的操作在NIO线程中完成</strong></li></ul></li><li><p><strong>调用doRegister方法</strong></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> javaChannel()即为ServerSocketChannel<br><span class="hljs-regexp">//</span> eventLoop().unwrappedSelector()获取eventLoop中的Selector<br><span class="hljs-regexp">//</span> this为NIOServerSocketChannel，作为附件<br>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, this);Copy<br></code></pre></div></td></tr></table></figure><ul><li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li><li>此时还未关注事件</li><li>添加NioServerSocketChannel附件</li></ul></li><li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p><ul><li><p>initChannel方法主要创建了</p><p>两个handler</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accept事件后建立连接</li></ul></li></ul></li></ul><h3 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h3><h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// initAndRegister为异步方法，会返回ChannelFuture对象</span><br>final ChannelFuture regFuture = init<span class="hljs-constructor">AndRegister()</span>;<br>regFuture.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>    @Override<br>    public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>        Throwable cause = future.cause<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">if</span> (cause != null) &#123;<br>            <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>            <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>            promise.set<span class="hljs-constructor">Failure(<span class="hljs-params">cause</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>            promise.registered<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 如果没有异常，则执行绑定操作</span><br>            <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">regFuture</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;);Copy<br></code></pre></div></td></tr></table></figure><p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p><p>NioServerSocketChannel.doBind方法</p><p>通过该方法，绑定了对应的端口</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@SuppressJava6Requirement</span>(reason = <span class="hljs-string">&quot;Usage guarded by java version check&quot;</span>)<br><span class="hljs-variable">@Override</span><br>protected void doBind(SocketAddress localAddress) throws Exception &#123;<br>    <span class="hljs-selector-tag">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;<br>        <span class="hljs-comment">// 调用ServerSocketChannel的bind方法，绑定端口</span><br>        <span class="hljs-selector-tag">javaChannel</span>()<span class="hljs-selector-class">.bind</span>(localAddress, config.getBacklog());<br>    &#125; <span class="hljs-selector-tag">else</span> &#123;<br>        <span class="hljs-selector-tag">javaChannel</span>()<span class="hljs-selector-class">.socket</span>()<span class="hljs-selector-class">.bind</span>(localAddress, config.getBacklog());<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="关注事件"><a href="#关注事件" class="headerlink" title="关注事件"></a>关注事件</h4><p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<br>    invokeLater(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            pipeline.fireChannelActive();<br>        &#125;<br>    &#125;);<br>&#125; <br></code></pre></div></td></tr></table></figure><p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">@Override<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> doBeginRead() throws Exception &#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    readPending = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>erestOps = selectionKey.<span class="hljs-built_in">int</span>erestOps();<br>    <span class="hljs-comment">// 如果ServerSocketChannel没有关注Accept事件</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">int</span>erestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 则让其关注Accepet事件</span><br>        <span class="hljs-comment">// readInterestOp 取值是 16</span><br>        <span class="hljs-comment">// 在 NioServerSocketChannel 创建时初始化</span><br>        selectionKey.<span class="hljs-built_in">int</span>erestOps(<span class="hljs-built_in">int</span>erestOps | readInterestOp);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p><ul><li><p>首先获取Channel所有感兴趣的事件</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>erestOps = selectionKey.<span class="hljs-built_in">int</span>erestOps();Copy<br></code></pre></div></td></tr></table></figure></li><li><p>然后再设置其感兴趣的事件</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">selectionKey.interest<span class="hljs-constructor">Ops(<span class="hljs-params">interestOps</span> | <span class="hljs-params">readInterestOp</span>)</span>;Copy<br></code></pre></div></td></tr></table></figure></li></ul><p><strong>各个事件对应的值</strong></p><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220130120330.png" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，完成了</p><ul><li>NioServerSocketChannel与ServerSocketChannel的创建</li><li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li><li>绑定了对应的端口</li><li>关注了Accept事件</li></ul><h2 id="2、NioEventLoop剖析"><a href="#2、NioEventLoop剖析" class="headerlink" title="2、NioEventLoop剖析"></a>2、NioEventLoop剖析</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>NioEventLoop的重要组成部分有三个</p><ul><li><p><strong>Selector</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioEventLoop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SingleThreadEventLoop</span> </span>&#123;<br>    <br>    ...<br>        <br>    <span class="hljs-comment">// selector中的selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// unwrappedSelector中的selectedKeys是基于HashSet的    </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Selector</span> selector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Selector</span> unwrappedSelector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SelectedSelectionKeySet</span> selectedKeys;<br>    <br>    ...<br>&#125; <br></code></pre></div></td></tr></table></figure></li><li><p><strong>Thread与TaskQueue</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadEventExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractScheduledEventExecutor</span> <span class="hljs-title">implements</span> <span class="hljs-title">OrderedEventExecutor</span> </span>&#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Queue</span>&lt;<span class="hljs-type">Runnable</span>&gt; taskQueue;<br><br>    <span class="hljs-comment">// 线程</span><br>    <span class="hljs-keyword">private</span> volatile <span class="hljs-type">Thread</span> thread;<br>&#125; <br></code></pre></div></td></tr></table></figure></li></ul><h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector是在NioEventLoop的构造方法中被创建的</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">NioEventLoop(NioEventLoopGroup <span class="hljs-params">parent</span>, Executor <span class="hljs-params">executor</span>, SelectorProvider <span class="hljs-params">selectorProvider</span>, SelectStrategy <span class="hljs-params">strategy</span>, RejectedExecutionHandler <span class="hljs-params">rejectedExecutionHandler</span>, EventLoopTaskQueueFactory <span class="hljs-params">queueFactory</span>)</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">           </span><br><span class="hljs-operator">        </span><span class="hljs-comment">// 初始化selector，初始化过程在openSelector中</span><br>        final SelectorTuple selectorTuple = <span class="hljs-keyword">open</span><span class="hljs-constructor">Selector()</span>;<br>        this.selector = selectorTuple.selector;<br>        this.unwrappedSelector = selectorTuple.unwrappedSelector;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-keyword">open</span><span class="hljs-constructor">Selector()</span> &#123;<br>    final Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 此处等同于 Selector.open()方法</span><br>        <span class="hljs-comment">// 创建了unwrappedSelector对象</span><br>        unwrappedSelector = provider.<span class="hljs-keyword">open</span><span class="hljs-constructor">Selector()</span>;<br>    &#125; catch (IOException e) &#123;<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChannelException(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, <span class="hljs-params">e</span>)</span>;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p><p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">unwrappedSelector</span> = provider.openSelector()<span class="hljs-comment">;Copy</span><br></code></pre></div></td></tr></table></figure><p>获得了Selector对象<code>unwrappedSelector</code></p><p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorTuple</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">final</span> Selector selector;<br><br>    SelectorTuple(Selector unwrappedSelector) &#123;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-keyword">this</span>.selector = unwrappedSelector;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 一般调用的是这个构造方法</span><br><span class="hljs-comment">    */</span><br>    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-keyword">this</span>.selector = selector;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p><h4 id="两个Selector"><a href="#两个Selector" class="headerlink" title="两个Selector"></a>两个Selector</h4><p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p><ul><li>selector中的SelectedKeys是<strong>基于数组</strong>的</li><li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li></ul><p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-function"><span class="hljs-title">openSelector</span>(<span class="hljs-params"></span>)</span> &#123;<br>    final Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br><br>    ...<br>    <br>    <span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br>    final SelectedSelectionKeySet selectedKeySet = <span class="hljs-keyword">new</span> SelectedSelectionKeySet();<br><br><br>    <span class="hljs-built_in">Object</span> maybeException = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;<span class="hljs-built_in">Object</span>&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过反射拿到unwrappedSelector中的selectedKeys属性</span><br>                Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;selectedKeys&quot;</span>);<br>                Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;publicSelectedKeys&quot;</span>);<br><br>                ...<br><br>                <span class="hljs-comment">// 暴力反射，修改私有属性</span><br>                Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br>                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br><br>                <span class="hljs-comment">// 替换为基于数组的selectedKeys实现</span><br>                selectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    selectedKeys = selectedKeySet;<br>    <br>    <span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SelectorTuple(unwrappedSelector,<br>                             <span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));<br>&#125; <br></code></pre></div></td></tr></table></figure><p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p><ul><li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br>final SelectedSelectionKeySet selectedKeySet = <span class="hljs-keyword">new</span> <span class="hljs-type">SelectedSelectionKeySet</span>();<br><br>SelectedSelectionKeySet() &#123;<br>keys = <span class="hljs-keyword">new</span> <span class="hljs-type">SelectionKey</span>[<span class="hljs-number">1024</span>];<br>&#125; <br></code></pre></div></td></tr></table></figure></li><li><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p></li><li><p><strong>通过Selector的构造方法</strong>获得selector</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">SelectedSelectionKeySetSelector(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">selectedKeySet</span>)</span> <br></code></pre></div></td></tr></table></figure></li><li><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>return <span class="hljs-keyword">new</span> <span class="hljs-constructor">SelectorTuple(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">new</span> SelectedSelectionKeySetSelector(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">selectedKeySet</span>)</span>);Copy<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="NIO线程启动时机"><a href="#NIO线程启动时机" class="headerlink" title="NIO线程启动时机"></a>NIO线程启动时机</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p><p><strong>测试代码</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNioEventLoop</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        EventLoop eventLoop = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NioEventLoopGroup</span>().<span class="hljs-built_in">next</span>();<br>        <span class="hljs-comment">// 使用NioEventLoop执行任务</span><br>        eventLoop.<span class="hljs-built_in">execute</span>(()-&gt;&#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>进入<code>execute</code>执行任务</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> execute(Runnable <span class="hljs-keyword">task</span>) &#123;<br>    <span class="hljs-comment">// 检测传入的任务是否为空，为空会抛出NullPointerException</span><br>    ObjectUtil.checkNotNull(<span class="hljs-keyword">task</span>, <span class="hljs-string">&quot;task&quot;</span>);<br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-comment">// 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true</span><br>    execute(<span class="hljs-keyword">task</span>, !(<span class="hljs-keyword">task</span> <span class="hljs-keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(<span class="hljs-keyword">task</span>));<br>&#125; <br></code></pre></div></td></tr></table></figure><p>进入上述代码的<code>execute</code>方法</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">private void execute(Runnable task, boolean immediate) &#123;<br>    <span class="hljs-regexp">//</span> 判断当前线程是否为NIO线程<br>    <span class="hljs-regexp">//</span> 判断方法为 return thread == this.thread;<br>    <span class="hljs-regexp">//</span> this.thread即为NIO线程，首次执行任务时，其为null<br>    boolean inEventLoop = inEventLoop();<br>    <br>    <span class="hljs-regexp">//</span> 向任务队列taskQueue中添加任务<br>    addTask(task);<br>    <br>    <span class="hljs-regexp">//</span> 当前线程不是NIO线程，则进入<span class="hljs-keyword">if</span>语句<br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        <span class="hljs-regexp">//</span> 启动NIO线程的核心方法<br>        startThread();<br>        <br>        ...<br>        <br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 有任务需要被执行时，唤醒阻塞的NIO线程<br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>进入<code>startThread</code>方法</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void start<span class="hljs-constructor">Thread()</span> &#123;<br>    <span class="hljs-comment">// 查看NIO线程状态是否为未启动</span><br>    <span class="hljs-comment">// 该if代码块只会执行一次</span><br>    <span class="hljs-comment">// state一开始的值就是ST_NOT_STARTED</span><br>    <span class="hljs-comment">// private volatile int state = ST_NOT_STARTED;</span><br>    <span class="hljs-keyword">if</span> (state<span class="hljs-operator"> == </span>ST_NOT_STARTED) &#123;<br>        <span class="hljs-comment">// 通过原子属性更新器将状态更新为启动（ST_STARTED）</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">STATE_UPDATER</span>.</span></span>compare<span class="hljs-constructor">AndSet(<span class="hljs-params">this</span>, ST_NOT_STARTED, ST_STARTED)</span>) &#123;<br>            boolean success = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行启动线程</span><br>                <span class="hljs-keyword">do</span><span class="hljs-constructor">StartThread()</span>;<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; finally &#123;<br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">STATE_UPDATER</span>.</span></span>compare<span class="hljs-constructor">AndSet(<span class="hljs-params">this</span>, ST_STARTED, ST_NOT_STARTED)</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">doStartThread</span>(<span class="hljs-params"></span>)</span> &#123;<br>    assert thread == <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 创建NIO线程并执行任务</span><br>    executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-comment">// thread即为NIO线程</span><br>            thread = Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                thread.interrupt();<br>            &#125;<br><br>            <span class="hljs-built_in">boolean</span> success = <span class="hljs-literal">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行内部run方法</span><br>                SingleThreadEventExecutor.this.run();<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <br>            <br>            ...<br>    &#125;);<br>&#125; <br></code></pre></div></td></tr></table></figure><p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p><p>该run方法是<strong>NioEvnetLoop的run方法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">@Override<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> selectCnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 执行各种任务</span><br>   <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">int</span> strategy;<br>            <span class="hljs-keyword">try</span> &#123;<br>                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br>                <span class="hljs-keyword">switch</span> (strategy) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br>                    <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span><br><br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    <span class="hljs-built_in">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();<br>                    <span class="hljs-keyword">if</span> (curDeadlineNanos == <span class="hljs-number">-1L</span>) &#123;<br>                        curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span><br>                    &#125;<br>                    nextWakeupNanos.<span class="hljs-keyword">set</span>(curDeadlineNanos);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>                            strategy = <span class="hljs-keyword">select</span>(curDeadlineNanos);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// This update is just to help block unnecessary selector wakeups</span><br>                        <span class="hljs-comment">// so use of lazySet is ok (no race condition)</span><br>                        nextWakeupNanos.lazySet(AWAKE);<br>                    &#125;<br>                    <span class="hljs-comment">// fall through</span><br>                <span class="hljs-literal">default</span>:<br>                &#125;<br>       &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 执行各种任务</span><br>   ...<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p><p>run方法中有SELECT分支</p><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso"><span class="hljs-keyword">case</span> SelectStrategy.<span class="hljs-keyword">SELECT</span>:<br>long curDeadlineNanos = nextScheduledTaskDeadlineNanos();<br><span class="hljs-keyword">if</span> (curDeadlineNanos == <span class="hljs-number">-1</span>L) &#123;<br>        curDeadlineNanos = <span class="hljs-literal">NONE</span>; <span class="hljs-comment">// nothing on the calendar</span><br>    &#125;<br>nextWakeupNanos.<span class="hljs-built_in">set</span>(curDeadlineNanos);<br>try &#123;<br>    <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>            <span class="hljs-comment">// 执行select方法</span><br>            strategy = <span class="hljs-keyword">select</span>(curDeadlineNanos);<br>        &#125;<br>    &#125;<br><span class="hljs-params">...</span> <br></code></pre></div></td></tr></table></figure><p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deadlineNanos)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 如果没有指定阻塞事件，就调用select()</span><br>    <span class="hljs-keyword">if</span> (deadlineNanos == NONE) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> selector.<span class="hljs-title">select</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>    <span class="hljs-comment">// 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞</span><br>    <span class="hljs-comment">// Timeout will only be 0 if deadline is within 5 microsecs</span><br>    <span class="hljs-keyword">long</span> timeoutMillis = deadlineToDelayNanos(deadlineNanos + <span class="hljs-number">995000</span>L) / <span class="hljs-number">1000000</span>L;<br>    <span class="hljs-keyword">return</span> timeoutMillis &lt;= <span class="hljs-number">0</span> ? selector.selectNow() : selector.select(timeoutMillis);<br>&#125; <br></code></pre></div></td></tr></table></figure><p>但需要注意的是，**<code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程**</p><p>唤醒是通过execute最后的if代码块来完成的</p><figure class="highlight gcode"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gcode"><span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br><span class="hljs-keyword">if</span> <span class="hljs-comment">(!addTaskWakesUp &amp;&amp; immediate)</span> &#123;<br>    wakeup<span class="hljs-comment">(inEventLoop)</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">wakeup</span>(<span class="hljs-params"><span class="hljs-built_in">boolean</span> inEventLoop</span>)</span> &#123;<br>    <span class="hljs-comment">// 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒</span><br>    <span class="hljs-comment">// 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) != AWAKE) &#123;<br>        <span class="hljs-comment">// 唤醒被selector.select方法阻塞的NIO线程</span><br>        selector.wakeup();<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>唤醒时需要进行两个判断</p><ul><li><p>判断提交任务的</p><p>是否为NIO线程</p><ul><li>若是其他线程，才能唤醒NIO线程</li><li>若是NIO线程自己，则不能唤醒</li></ul></li><li><p>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</p></li></ul><h4 id="SELECT分支"><a href="#SELECT分支" class="headerlink" title="SELECT分支"></a>SELECT分支</h4><p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> strategy = selectStrategy.calculate<span class="hljs-constructor">Strategy(<span class="hljs-params">selectNowSupplier</span>, <span class="hljs-params">hasTasks</span>()</span>);<br>switch (strategy) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span>&#125; <br></code></pre></div></td></tr></table></figure><p>strategy的值由<code>calculateStrategy</code>方法确定</p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculateStrategy</span><span class="hljs-params">(IntSupplier selectSupplier, <span class="hljs-keyword">boolean</span> hasTasks)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// selectSupplier.get() 底层是 selector.selectNow();</span><br>    <span class="hljs-keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>该方法会<strong>根据hasTaks变量判断任务队列中是否有任务</strong></p><ul><li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p><ul><li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IntSupplier selectNowSupplier = <span class="hljs-keyword">new</span> IntSupplier() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> NioEventLoop.<span class="hljs-keyword">this</span>.selectNow();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectNow</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.selector.selectNow();<br>&#125; <br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>若没有任务，就会进入SELECT分支</p></li></ul><p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p><h3 id="Java-NIO空轮询BUG"><a href="#Java-NIO空轮询BUG" class="headerlink" title="Java NIO空轮询BUG"></a>Java NIO空轮询BUG</h3><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p><p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso">@Override<br><span class="hljs-keyword">protected</span> <span class="hljs-literal">void</span> run() &#123;<br>    <span class="hljs-params">...</span><br>    for(;;)&#123;<br>        <span class="hljs-params">...</span><br>        <span class="hljs-comment">// 可能发生空轮询，无法阻塞NIO线程</span><br>        strategy = <span class="hljs-keyword">select</span>(curDeadlineNanos);  <br>        <span class="hljs-params">...</span>     <br>    <br>     <span class="hljs-keyword">if</span>(<span class="hljs-params">...</span>) &#123;<br><span class="hljs-params">...</span><br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unexpectedSelectorWakeup(selectCnt) )&#123;<br>            <span class="hljs-comment">// 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector</span><br>            <span class="hljs-comment">// 并将selectCnt重置为0</span><br>            selectCnt = <span class="hljs-number">0</span>;<br>        &#125;<br>&#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p><p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>    <span class="hljs-comment">// The selector returned prematurely many times in a row.</span><br>    <span class="hljs-comment">// Rebuild the selector to work around the problem.</span><br>    <span class="hljs-selector-tag">logger</span><span class="hljs-selector-class">.warn</span>(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>,selectCnt, selector);<br>    <span class="hljs-comment">// 重建selector，将原selector的配置信息传给新selector</span><br>    <span class="hljs-comment">// 再用新selector覆盖旧selector</span><br>    <span class="hljs-selector-tag">rebuildSelector</span>();<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">true</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p><h3 id="ioRatio"><a href="#ioRatio" class="headerlink" title="ioRatio"></a>ioRatio</h3><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p><p><strong>NioEventLoop.run方法</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 处理IO事件时间比例，默认为50%</span><br>final <span class="hljs-built_in">int</span> ioRatio = this.ioRatio;<br><br><span class="hljs-comment">// 如果IO事件时间比例设置为100%</span><br><span class="hljs-keyword">if</span> (ioRatio<span class="hljs-operator"> == </span><span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果需要去处理IO事件</span><br>        <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 先处理IO事件</span><br>            process<span class="hljs-constructor">SelectedKeys()</span>;<br>        &#125;<br>    &#125; finally &#123;<br>        <span class="hljs-comment">// Ensure we always run tasks.</span><br>        <span class="hljs-comment">// 剩下的时间都去处理普通任务和定时任务</span><br>        ranTasks = run<span class="hljs-constructor">AllTasks()</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果需要去处理IO事件</span><br>    <span class="hljs-comment">// 记录处理IO事件前的时间</span><br>    final long ioStartTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>nano<span class="hljs-constructor">Time()</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 去处理IO事件</span><br>        process<span class="hljs-constructor">SelectedKeys()</span>;<br>    &#125; finally &#123;<br>        <span class="hljs-comment">// Ensure we always run tasks.</span><br>        <span class="hljs-comment">// ioTime为处理IO事件耗费的事件</span><br>        final long ioTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>nano<span class="hljs-constructor">Time()</span> - ioStartTime;<br>        <span class="hljs-comment">// 计算出处理其他任务的事件</span><br>        <span class="hljs-comment">// 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行</span><br>        ranTasks = run<span class="hljs-constructor">AllTasks(<span class="hljs-params">ioTime</span> <span class="hljs-operator">*</span> (100 - <span class="hljs-params">ioRatio</span>)</span><span class="hljs-operator"> / </span>ioRatio);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有IO事件需要处理</span><br>    <span class="hljs-comment">// This will run the minimum number of tasks</span><br>    <span class="hljs-comment">// 直接处理普通和定时任务</span><br>    ranTasks = run<span class="hljs-constructor">AllTasks(0)</span>; <br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p><ul><li><p>判断ioRatio是否为100</p><ul><li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p><ul><li>若需要处理IO事件，则先处理IO事件</li></ul></li><li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">// 没有指定执行任务的时间<br><span class="hljs-attribute">ranTasks</span> = runAllTasks()<span class="hljs-comment">;Copy</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>若ioRatio不为100</p><ul><li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p></li><li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 比如ioTime为<span class="hljs-number">10</span>s，ioRatio为<span class="hljs-number">50</span><br><span class="hljs-regexp">//</span> 那么通过 <span class="hljs-number">10</span>*(<span class="hljs-number">100</span>-<span class="hljs-number">50</span>)/<span class="hljs-number">50</span>=<span class="hljs-number">10</span> 计算出其他任务可用的时间为 <span class="hljs-number">10</span>s<br><span class="hljs-regexp">//</span> 处理IO事件占用的事件总比例为<span class="hljs-number">50</span>%<br>ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);Copy<br></code></pre></div></td></tr></table></figure></li><li><p>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</p></li></ul></li><li><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">// 运行最少数量的任务<br><span class="hljs-attribute">ranTasks</span> = runAllTasks(<span class="hljs-number">0</span>)<span class="hljs-comment">;Copy</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void process<span class="hljs-constructor">SelectedKeys()</span> &#123;<br>    <span class="hljs-comment">// 如果selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// 一般情况下都走这个分支</span><br>    <span class="hljs-keyword">if</span> (selectedKeys != null) &#123;<br>        <span class="hljs-comment">// 处理各种IO事件</span><br>        process<span class="hljs-constructor">SelectedKeysOptimized()</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        process<span class="hljs-constructor">SelectedKeysPlain(<span class="hljs-params">selector</span>.<span class="hljs-params">selectedKeys</span>()</span>);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>processSelectedKeysOptimized方法</p><figure class="highlight smali"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs smali">private void processSelectedKeysOptimized() &#123;<br>    for (int i = 0; i &lt; selectedKeys.size; ++i) &#123;<br>        // 拿到SelectionKeyec<br>       <span class="hljs-keyword"> final</span> SelectionKey k = selectedKeys.keys[i];<br>        // null out entry in the<span class="hljs-built_in"> array </span>to allow to have it GC&#x27;ed once the Channel close<br>        // See https://github.com/netty/netty/issues/2363<br>        selectedKeys.keys[i] = null;<br><br>        // 获取SelectionKey上的附件，即NioServerSocketChannel<br>       <span class="hljs-keyword"> final</span> Object a = k.attachment();<br><br>       <span class="hljs-built_in"> if </span>(a instanceof AbstractNioChannel) &#123;<br>            // 处理事件，传入附件NioServerSocketChannel<br>            processSelectedKey(k, (AbstractNioChannel) a);<br>        &#125; else &#123;<br>            @SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;<br>            processSelectedKey(k, task);<br>        &#125;<br><br>       <span class="hljs-built_in"> if </span>(needsToSelectAgain) &#123;<br>            // null out entries in the<span class="hljs-built_in"> array </span>to allow to have it GC&#x27;ed once the Channel close<br>            // See https://github.com/netty/netty/issues/2363<br>            selectedKeys.reset(i + 1);<br><br>            selectAgain();<br>            i = -1;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">Object</span> a = k.attachment();Copy<br></code></pre></div></td></tr></table></figure><p>如果附件继承自AbstractNioChannel，则会调用</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span><br>process<span class="hljs-constructor">SelectedKey(<span class="hljs-params">k</span>, (AbstractNioChannel)</span> a);Copy<br></code></pre></div></td></tr></table></figure><p>去处理各个事件</p><p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p><p>获取SelectionKey的事件，然后进行相应处理</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span>(<span class="hljs-params">SelectionKey k, AbstractNioChannel ch</span>)</span> &#123;<br>    final AbstractNioChannel.NioUnsafe <span class="hljs-keyword">unsafe</span> = ch.<span class="hljs-keyword">unsafe</span>();<br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        final EventLoop eventLoop;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop = ch.eventLoop();<br>        &#125; catch (Throwable ignored) &#123;<br>            <span class="hljs-comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span><br>            <span class="hljs-comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span><br>            <span class="hljs-comment">// to close ch.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span><br>        <span class="hljs-comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span><br>        <span class="hljs-comment">// still healthy and should not be closed.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/5125</span><br>        <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// close the channel if the key is not valid anymore</span><br>            <span class="hljs-keyword">unsafe</span>.close(<span class="hljs-keyword">unsafe</span>.voidPromise());<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">int</span> readyOps = k.readyOps();<br>        <span class="hljs-comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span><br>        <span class="hljs-comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/924</span><br>            <span class="hljs-built_in">int</span> ops = k.interestOps();<br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            k.interestOps(ops);<br><br>            <span class="hljs-keyword">unsafe</span>.finishConnect();<br>        &#125;<br><br>        <span class="hljs-comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span><br>            ch.<span class="hljs-keyword">unsafe</span>().forceFlush();<br>        &#125;<br><br>        <span class="hljs-comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span><br>        <span class="hljs-comment">// to a spin loop</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">unsafe</span>.read();<br>        &#125;<br>    &#125; catch (CancelledKeyException ignored) &#123;<br>        <span class="hljs-keyword">unsafe</span>.close(<span class="hljs-keyword">unsafe</span>.voidPromise());<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h2 id="3、Accept剖析"><a href="#3、Accept剖析" class="headerlink" title="3、Accept剖析"></a>3、Accept剖析</h2><h3 id="NIO中处理Accept事件流程"><a href="#NIO中处理Accept事件流程" class="headerlink" title="NIO中处理Accept事件流程"></a>NIO中处理Accept事件流程</h3><p>NIO中处理Accept事件主要有以下六步</p><ul><li>selector.select()阻塞线程，直到事件发生</li><li>遍历selectionKeys</li><li>获取一个key，判断事件类型是否为Accept</li></ul><hr><ul><li>创建SocketChannel，设置为非阻塞</li><li>将SocketChannel注册到selector中</li><li>关注selectionKeys的read事件</li></ul><p>代码如下</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 阻塞直到事件发生<br>selector.select();<br><br>Iterator&lt;SelectionKey&gt; iter = selector.selectionKeys().iterator();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;    <br>    <span class="hljs-regexp">//</span> 拿到一个事件<br>    SelectionKey key = iter.<span class="hljs-keyword">next</span>();<br>    <br>    <span class="hljs-regexp">//</span> 如果是 accept 事件<br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <br>        <span class="hljs-regexp">//</span> 执行accept，获得SocketChannel<br>        SocketChannel channel = serverSocketChannel.accept();<br>        channel.configureBlocking(false);<br>        <br>        <span class="hljs-regexp">//</span> 将SocketChannel注册到selector中，并关注read事件<br>        channel.register(selector, SelectionKey.OP_READ);<br>    &#125;<br>    <span class="hljs-regexp">//</span> ...<br>&#125; <br></code></pre></div></td></tr></table></figure><p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p><h3 id="SocketChannel的创建与注册"><a href="#SocketChannel的创建与注册" class="headerlink" title="SocketChannel的创建与注册"></a>SocketChannel的创建与注册</h3><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">if ((<span class="hljs-name">readyOps</span> &amp; (<span class="hljs-name">SelectionKey</span>.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == <span class="hljs-number">0</span>) &#123;<br>unsafe.read()<span class="hljs-comment">;</span><br>&#125; <br></code></pre></div></td></tr></table></figure><p><code>NioMessageUnsafe.read</code>方法</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public void read<span class="hljs-literal">()</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    </span><span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// doReadMessages中执行了accept获得了SocketChannel</span><br>                <span class="hljs-comment">// 并创建NioSocketChannel作为消息放入readBuf</span><br>                <span class="hljs-comment">// readBuf是一个ArrayList用来缓存消息</span><br>                <span class="hljs-comment">// private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();</span><br>                <span class="hljs-built_in">int</span> localRead = <span class="hljs-keyword">do</span><span class="hljs-constructor">ReadMessages(<span class="hljs-params">readBuf</span>)</span>;<span class="hljs-operator"></span><br><span class="hljs-operator">                </span><br><span class="hljs-operator">                ...</span><br><span class="hljs-operator">                </span><br><span class="hljs-operator"></span><span class="hljs-comment">// localRead值为1，就一条消息，即接收一个客户端连接</span><br>                allocHandle.inc<span class="hljs-constructor">MessagesRead(<span class="hljs-params">localRead</span>)</span>;<br>            &#125; <span class="hljs-keyword">while</span> (allocHandle.continue<span class="hljs-constructor">Reading()</span>);<br>        &#125; catch (Throwable t) &#123;<br>            <span class="hljs-keyword">exception</span> = t;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> size = readBuf.size<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>            readPending = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 触发read事件，让pipeline上的handler处理</span><br>            <span class="hljs-comment">// ServerBootstrapAcceptor.channelRead</span><br>            pipeline.fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">readBuf</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span>);<br>        &#125;<span class="hljs-operator"></span><br><span class="hljs-operator">        </span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">        </span><br><span class="hljs-operator">    </span>&#125; finally &#123;<br>        <span class="hljs-keyword">if</span> (!readPending<span class="hljs-operator"> &amp;&amp; </span>!config.is<span class="hljs-constructor">AutoRead()</span>) &#123;<br>            remove<span class="hljs-constructor">ReadOp()</span>;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><code>NioSocketChannel.doReadMessages</code>方法</p><p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">@Override<br>protected <span class="hljs-built_in">int</span> <span class="hljs-keyword">do</span><span class="hljs-constructor">ReadMessages(List&lt;Object&gt; <span class="hljs-params">buf</span>)</span> throws Exception &#123;<br>    <span class="hljs-comment">// 处理accpet事件，获得SocketChannel</span><br>    SocketChannel ch = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SocketUtils</span>.</span></span>accept(java<span class="hljs-constructor">Channel()</span>);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch != null) &#123;<br>            <span class="hljs-comment">// 创建了NioSocketChannel，作为消息放在了readBuf中</span><br>            buf.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NioSocketChannel(<span class="hljs-params">this</span>, <span class="hljs-params">ch</span>)</span>);<br>            return <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; catch (Throwable t) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">       ...</span><br><span class="hljs-operator">    </span>&#125;<br><br>    return <span class="hljs-number">0</span>;<br>&#125; <br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerBootstrapAcceptor</span>.</span></span>channelRead<br>public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-comment">// 这时的msg是NioSocketChannel</span><br>    final Channel child = (Channel) msg;<br><br>    <span class="hljs-comment">// NioSocketChannel添加childHandler，即初始化器</span><br>    child.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">childHandler</span>)</span>;<br><br>    <span class="hljs-comment">// 设置选项</span><br>    set<span class="hljs-constructor">ChannelOptions(<span class="hljs-params">child</span>, <span class="hljs-params">childOptions</span>, <span class="hljs-params">logger</span>)</span>;<br><br>    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;<br>        child.attr((AttributeKey&lt;Object&gt;) e.get<span class="hljs-constructor">Key()</span>).set(e.get<span class="hljs-constructor">Value()</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程</span><br>        childGroup.register(child).add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>            @Override<br>            public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>                <span class="hljs-keyword">if</span> (!future.is<span class="hljs-constructor">Success()</span>) &#123;<br>                    force<span class="hljs-constructor">Close(<span class="hljs-params">child</span>, <span class="hljs-params">future</span>.<span class="hljs-params">cause</span>()</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; catch (Throwable t) &#123;<br>        force<span class="hljs-constructor">Close(<span class="hljs-params">child</span>, <span class="hljs-params">t</span>)</span>;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>通过<code>AbstractUnsafe.register</code> 方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractChannel</span>.</span></span>this.eventLoop = eventLoop;<br><br>    <span class="hljs-keyword">if</span> (eventLoop.<span class="hljs-keyword">in</span><span class="hljs-constructor">EventLoop()</span>) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这行代码完成的是nio boss -&gt; nio worker线程的切换</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>                @Override<br>                public void run<span class="hljs-literal">()</span> &#123;<br>                    <span class="hljs-comment">// 真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; catch (Throwable t) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">        </span>&#125;<br>    &#125;<br>&#125; <br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractChannel</span>.</span><span class="hljs-module"><span class="hljs-identifier">AbstractUnsafe</span>.</span></span>register0<br><span class="hljs-keyword">private</span> void register0(ChannelPromise promise) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">        </span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">            </span><br><span class="hljs-operator">        </span><span class="hljs-comment">// 该方法将SocketChannel注册到Selector中</span><br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">Register()</span>;<br>        <br>        <span class="hljs-comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span><br>        pipeline.invoke<span class="hljs-constructor">HandlerAddedIfNeeded()</span>;<br>        <span class="hljs-comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span><br><br>        safe<span class="hljs-constructor">SetSuccess(<span class="hljs-params">promise</span>)</span>;<br>        pipeline.fire<span class="hljs-constructor">ChannelRegistered()</span>;<br>        <br>        <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Active()</span>) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                <span class="hljs-comment">// 触发pipeline上active事件</span><br>                pipeline.fire<span class="hljs-constructor">ChannelActive()</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config<span class="hljs-literal">()</span>.is<span class="hljs-constructor">AutoRead()</span>) &#123;<br>                <span class="hljs-keyword">begin</span><span class="hljs-constructor">Read()</span>;<br>            &#125;<br>        &#125;<br>    &#125; catch (Throwable t) &#123;<br>        close<span class="hljs-constructor">Forcibly()</span>;<br>        closeFuture.set<span class="hljs-constructor">Closed()</span>;<br>        safe<span class="hljs-constructor">SetFailure(<span class="hljs-params">promise</span>, <span class="hljs-params">t</span>)</span>;<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p><figure class="highlight aspectj"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将Selector注册到Selector中</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125; <br>HeadContext.channelActive<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>    ctx.fireChannelActive();<br><span class="hljs-comment">// 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)</span><br>    readIfIsAutoRead();<br>&#125; <br></code></pre></div></td></tr></table></figure><p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> doBeginRead() throws Exception &#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 这时候 interestOps是0</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>erestOps = selectionKey.<span class="hljs-built_in">int</span>erestOps();<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">int</span>erestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 关注read事件</span><br>        selectionKey.<span class="hljs-built_in">int</span>erestOps(<span class="hljs-built_in">int</span>erestOps | readInterestOp);<br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h2 id="4、Read剖析"><a href="#4、Read剖析" class="headerlink" title="4、Read剖析"></a>4、Read剖析</h2><p>read事件的处理也是在</p><figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">if ((<span class="hljs-name">readyOps</span> &amp; (<span class="hljs-name">SelectionKey</span>.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == <span class="hljs-number">0</span>) &#123;<br>unsafe.read()<span class="hljs-comment">;</span><br>&#125; <br></code></pre></div></td></tr></table></figure><p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">java@Override<br>public final void read<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-comment">// 获得Channel的配置</span><br>    final ChannelConfig config = config<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (should<span class="hljs-constructor">BreakReadReady(<span class="hljs-params">config</span>)</span>) &#123;<br>        clear<span class="hljs-constructor">ReadPending()</span>;<br>        return;<br>    &#125;<br>    final ChannelPipeline pipeline = pipeline<span class="hljs-literal">()</span>;<br><span class="hljs-comment">// 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）</span><br>final ByteBufAllocator allocator = config.get<span class="hljs-constructor">Allocator()</span>;<br>    <span class="hljs-comment">// 用来分配 byteBuf，确定单次读取大小</span><br>    final RecvByteBufAllocator.Handle allocHandle = recv<span class="hljs-constructor">BufAllocHandle()</span>;<br>    allocHandle.reset(config);<br><br>    ByteBuf byteBuf = null;<br>    boolean close = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 创建ByteBuf</span><br>            byteBuf = allocHandle.allocate(allocator);<br>            <span class="hljs-comment">// 读取内容，放入ByteBUf中</span><br>            allocHandle.last<span class="hljs-constructor">BytesRead(<span class="hljs-params">doReadBytes</span>(<span class="hljs-params">byteBuf</span>)</span>);<br>            <span class="hljs-keyword">if</span> (allocHandle.last<span class="hljs-constructor">BytesRead()</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>                byteBuf.release<span class="hljs-literal">()</span>;<br>                byteBuf = null;<br>                close = allocHandle.last<span class="hljs-constructor">BytesRead()</span> &lt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (close) &#123;<br>                    readPending = <span class="hljs-literal">false</span>;<br>                &#125;<br>                break;<br>            &#125;<br><br>            allocHandle.inc<span class="hljs-constructor">MessagesRead(1)</span>;<br>            readPending = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 触发read 事件，让pipeline上的handler处理</span><br>            <span class="hljs-comment">// 这时是处理NioSocketChannel上的handler</span><br>            pipeline.fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">byteBuf</span>)</span>;<br>            byteBuf = null;<br>        &#125; <br>        <span class="hljs-comment">// 是否要继续循环</span><br>        <span class="hljs-keyword">while</span> (allocHandle.continue<span class="hljs-constructor">Reading()</span>);<br><br>        allocHandle.read<span class="hljs-constructor">Complete()</span>;<br>        <span class="hljs-comment">// 触发 read complete事件</span><br>        pipeline.fire<span class="hljs-constructor">ChannelReadComplete()</span>;<br><br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            close<span class="hljs-constructor">OnRead(<span class="hljs-params">pipeline</span>)</span>;<br>        &#125;<br>    &#125; catch (Throwable t) &#123;<br>        handle<span class="hljs-constructor">ReadException(<span class="hljs-params">pipeline</span>, <span class="hljs-params">byteBuf</span>, <span class="hljs-params">t</span>, <span class="hljs-params">close</span>, <span class="hljs-params">allocHandle</span>)</span>;<br>    &#125; finally &#123;<br>         <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>         <span class="hljs-comment">// This could be for two reasons:</span><br>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>         <span class="hljs-comment">//</span><br>         <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-keyword">if</span> (!readPending<span class="hljs-operator"> &amp;&amp; </span>!config.is<span class="hljs-constructor">AutoRead()</span>) &#123;<br>            remove<span class="hljs-constructor">ReadOp()</span>;<br>        &#125;<br>    &#125;<br>&#125; <br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultMaxMessagesRecvByteBufAllocator</span>.</span><span class="hljs-module"><span class="hljs-identifier">MaxMessageHandle</span>.</span></span>continue<span class="hljs-constructor">Reading(<span class="hljs-params">io</span>.<span class="hljs-params">netty</span>.<span class="hljs-params">util</span>.UncheckedBooleanSupplier)</span><br>public boolean continue<span class="hljs-constructor">Reading(UncheckedBooleanSupplier <span class="hljs-params">maybeMoreDataSupplier</span>)</span> &#123;<br>    return <br>           <span class="hljs-comment">// 一般为true</span><br>           config.is<span class="hljs-constructor">AutoRead()</span><span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">           </span><span class="hljs-comment">// respectMaybeMoreData默认为true</span><br>           <span class="hljs-comment">// maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true</span><br>           (!respectMaybeMoreData<span class="hljs-operator"> || </span>maybeMoreDataSupplier.get<span class="hljs-literal">()</span>)<span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">           </span><span class="hljs-comment">// 小于最大次数，maxMessagePerRead默认16</span><br>           totalMessages &lt; maxMessagePerRead<span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">           </span><span class="hljs-comment">// 实际读到了数据</span><br>           totalBytesRead &gt; <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>转载自<a href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#Netty">Nyima</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>65_有效数字</title>
    <link href="/2022/01/29/65-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/"/>
    <url>/2022/01/29/65-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>难度：困难</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有效数字（按顺序）可以分成以下几个部分：</p><ol><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li></ol><p>小数（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ul><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ul></li></ol><p>整数（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分有效数字列举如下：</p><ul><li><code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code></li></ul><p>部分无效数字列举如下：</p><ul><li><code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code></li></ul><p>给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 <strong>true</strong> 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：s = “0”<br><strong>输出</strong>：true</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：s = “e”<br><strong>输出</strong>：false</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：s = “.”<br><strong>输出</strong>：false</p></blockquote><p>示例四：</p><blockquote><p><strong>输入</strong>：s = “.1”<br><strong>输出</strong>：true</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，或者点 <code>&#39;.&#39;</code> 。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h4 id="确定有限状态自动机"><a href="#确定有限状态自动机" class="headerlink" title="确定有限状态自动机"></a>确定有限状态自动机</h4><p>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：</p><ul><li>有一个特殊的状态，被称作「初始状态」。</li><li>还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。</li></ul><p>起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。</p><p>并且如果没有匹配到转移规则，也拒绝该字符串。</p><p>自动机驱动的编程，可以看成是一种暴力解法。</p><h3 id="合法数值字符串"><a href="#合法数值字符串" class="headerlink" title="合法数值字符串"></a>合法数值字符串</h3><p>一个合法的数值字符串，包含以下部分：</p><ul><li>符号位，即 +、−两种符号</li><li>整数部分，即由若干字符 0−9 组成的字符串</li><li>小数点</li><li>小数部分，其构成与整数部分相同</li><li>指数部分，其中包含开头的字符 e（大写小写均可）、可选的符号位，和整数部分</li></ul><p>上面五个部分每个都不是必需的，但是受一些额外规则制约：</p><ul><li>如果符号位存在，其后面必须跟着数字或者小数点</li><li>小数点的前后两侧，至少有一侧是数字</li></ul><h3 id="自动机状态转换"><a href="#自动机状态转换" class="headerlink" title="自动机状态转换"></a>自动机状态转换</h3><p>根据这些规则，罗列出自动机的所有状态：</p><ol start="0"><li>初始状态</li><li>符号位</li><li>整数部分</li><li>左侧有整数的小数点</li><li>左侧无整数的小数点</li><li>小数部分</li><li>字符 e</li><li>指数部分的符号位</li><li>指数部分的整数部分</li></ol><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220129144707.png" alt="fig1"></p><p>初始状态即状态0，接受状态为状态2、状态3、状态5、状态8。</p><ul><li>当输入正负号时：<ul><li>如果当前状态是初始状态0，则状态切换为1</li><li>如果当前状态是状态6，则切换到状态7</li><li>其他则拒绝</li></ul></li><li>当输入数字时：<ul><li>如果当前状态是状态0，1，2，则切换到状态2</li><li>如果当前状态是状态3，4，5，则切换到状态5</li><li>如果当前状态是状态6，7，8，则切换到状态8</li></ul></li><li>当输入小数点时：<ul><li>如果当前状态是状态0，1，则切换到状态4</li><li>如果当前状态是状态2，则切换到状态3</li><li>其他则拒绝</li></ul></li><li>当输入字符 E | e 时：<ul><li>如果当前状态是 2，3，5，则切换到状态6</li><li>其他则拒绝</li></ul></li><li>其他字符：<ul><li>拒绝 </li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(String s)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> state = <span class="hljs-number">0</span>;<br>  s = s.trim(); <span class="hljs-comment">// 去除头尾空格</span><br>  <span class="hljs-comment">// 遍历所有字符，当作输入</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s.length(); i++)&#123;<br>    <span class="hljs-keyword">switch</span> (s.charAt(i)) &#123;<br>        <span class="hljs-comment">// 正负号</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>)&#123;<br>          state = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state ==<span class="hljs-number">6</span>)&#123;<br>          state = <span class="hljs-number">7</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 数字</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (state==<span class="hljs-number">0</span>||state==<span class="hljs-number">1</span>||state==<span class="hljs-number">2</span>)&#123;<br>          state = <span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state==<span class="hljs-number">3</span>||state==<span class="hljs-number">4</span>||state==<span class="hljs-number">5</span>)&#123;<br>          state = <span class="hljs-number">5</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state==<span class="hljs-number">6</span>||state==<span class="hljs-number">7</span>||state==<span class="hljs-number">8</span>)&#123;<br>          state = <span class="hljs-number">8</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 小数点</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;.&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (state==<span class="hljs-number">0</span>||state==<span class="hljs-number">1</span>)&#123;<br>          state = <span class="hljs-number">4</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state==<span class="hljs-number">2</span>)&#123;<br>          state = <span class="hljs-number">3</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// E e</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (state==<span class="hljs-number">2</span>||state==<span class="hljs-number">3</span>||state==<span class="hljs-number">5</span>)&#123;<br>          state=<span class="hljs-number">6</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回接受状态</span><br>  <span class="hljs-keyword">return</span> state==<span class="hljs-number">2</span>||state==<span class="hljs-number">3</span>||state==<span class="hljs-number">5</span>||state==<span class="hljs-number">8</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1765_地图中的最高点</title>
    <link href="/2022/01/29/1765-%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/"/>
    <url>/2022/01/29/1765-%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个大小为 <code>m x n</code> 的整数矩阵 isWater ，它代表了一个由 <strong>陆地</strong> 和 <strong>水域</strong> 单元格组成的地图。</p><p>如果 <code>isWater[i][j] == 0</code>，格子 <code>(i, j)</code> 是一个 陆地 格子。<br>如果 <code>isWater[i][j] == 1</code>，格子 <code>(i, j)</code> 是一个 水域 格子。<br>你需要按照如下规则给每个单元格安排高度：</p><p>每个格子的高度都必须是非负的。<br>如果一个格子是是<strong>水域</strong>，那么它的高度必须为 <strong>0</strong> 。<br>任意相邻的格子高度差 <strong>至多</strong> 为 <strong>1</strong> 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）<br>找到一种安排高度的方案，使得矩阵中的最高高度值<strong>最大</strong> 。</p><p>请你返回一个大小为 <code>m x n</code> 的整数矩阵<code>height</code> ，其中 <code>height[i][j]</code>是格子 <code>(i, j)</code> 的高度。如果有多种解法，请返回<strong>任意一个</strong> 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220129111515.png" alt="img"></p><p><strong>输入</strong>：isWater = [[0,1],[0,0]]<br><strong>输出</strong>：[[1,0],[2,1]]<br><strong>解释</strong>：上图展示了给各个格子安排的高度。<br>蓝色格子是水域格，绿色格子是陆地格。</p></blockquote><p>示例二：</p><blockquote><p><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220129111603.png" alt="img"></p><p><strong>输入</strong>：isWater = [[0,0,1],[1,0,0],[0,0,0]]<br><strong>输出</strong>：[[1,1,0],[0,1,1],[1,2,2]]<br><strong>解释</strong>：所有安排方案中，最高可行高度为 2 。<br>任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>m == isWater.length</li><li>n == isWater[i].length</li><li>1 &lt;= m, n &lt;= 1000</li><li><code>isWater[i][j]</code> 要么是 0 ，要么是 1 。</li><li>至少有 1 个水域格子。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>根据题意，空间内水面的高度为0，这是确定信息，因此可以从水面的高度出发，向周围迭代计算对应的高度，因为相邻格子的高度差最大为1，所以每个地方只需要迭代一次，并记录第一次访问的高度。</p><p>相邻格子可定义为 <code>int[][] directions = &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;</code></p><p>用队列来控制迭代的顺序（从高度为0的水面开始，然后是高度为1的陆地，依此类推）</p><p>刚开始给所有位置赋值 -1 ，表示未访问过该位置，然后遍历，将判定为水面的位置赋值 -1 ，并推入队列。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 数组填充</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>  <span class="hljs-comment">// 全部填充-1，表示未访问过</span><br>  Arrays.fill(ans[i],-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后从队列中的水面点开始迭代。每从队列取出一个位置，就计算它的相邻格子，如果相邻格子未访问过（为 -1 ），则设置相邻格子的高度为当前位置 +1，并将该格子推入队列。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] directions = &#123;&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] highestPeak(<span class="hljs-keyword">int</span>[][] isWater) &#123;<br>  <span class="hljs-keyword">int</span> m = isWater.length;<br>  <span class="hljs-keyword">int</span> n = isWater[<span class="hljs-number">0</span>].length;<br>  <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>  <br>  <span class="hljs-comment">// 数组填充 -1 ，表示未访问过</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>    Arrays.fill(ans[i],-<span class="hljs-number">1</span>);<br>  &#125;<br>  <br>  Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>      <span class="hljs-keyword">if</span>(isWater[i][j]==<span class="hljs-number">1</span>)&#123;<br>        ans[i][j]=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录水面的点</span><br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>    <span class="hljs-keyword">int</span>[] p = queue.poll();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] dir: directions)&#123;<br>      <span class="hljs-keyword">int</span> x = p[<span class="hljs-number">0</span>]+dir[<span class="hljs-number">0</span>],y = p[<span class="hljs-number">1</span>]+dir[<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;=x&amp;&amp;x&lt;m&amp;&amp;<span class="hljs-number">0</span>&lt;=y&amp;&amp;y&lt;n&amp;&amp;ans[x][y]==-<span class="hljs-number">1</span>)&#123;<br>        ans[x][y] = ans[p[<span class="hljs-number">0</span>]][p[<span class="hljs-number">1</span>]]+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 将该点推入队列</span><br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;x,y&#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2047_句子中的有效单词数</title>
    <link href="/2022/01/28/2047-%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <url>/2022/01/28/2047-%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>难度：简单</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>句子仅由小写字母（<code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code>）、数字（<code>&#39;0&#39;</code> 到<code> &#39;9&#39;</code>）、连字符（<code>&#39;-&#39;</code>）、标点符号（<code>&#39;!&#39;</code>、<code>&#39;.&#39;</code> 和 <code>&#39;,&#39;</code>）以及空格（<code>&#39; &#39;</code>）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 <code>&#39; &#39;</code> 分隔。</p><p>如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：</p><p>仅由小写字母、连字符和/或标点（不含数字）。<br>至多一个 连字符 <code>&#39;-&#39;</code> 。如果存在，连字符两侧应当都存在小写字母（<code>&quot;a-b&quot;</code> 是一个有效单词，但<code> &quot;-ab&quot;</code> 和 <code>&quot;ab-&quot;</code> 不是有效单词）。<br>至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。<br>这里给出几个有效单词的例子：<code>&quot;a-b.&quot;</code>、<code>&quot;afad&quot;</code>、<code>&quot;ba-c&quot;</code>、<code>&quot;a!&quot;</code> 和 <code>&quot;!&quot;</code> 。</p><p>给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：sentence = “cat and  dog”<br><strong>输出</strong>：3<br><strong>解释</strong>：句子中的有效单词是 “cat”、”and” 和 “dog”</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：sentence = “!this  1-s b8d!”<br><strong>输出</strong>：0<br><strong>解释</strong>：句子中没有有效单词<br>“!this” 不是有效单词，因为它以一个标点开头<br>“1-s” 和 “b8d” 也不是有效单词，因为它们都包含数字</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：sentence = “alice and  bob are playing stone-game10”<br><strong>输出</strong>：5<br><strong>解释</strong>：句子中的有效单词是 “alice”、”and”、”bob”、”are” 和 “playing”<br>“stone-game10” 不是有效单词，因为它含有数字</p></blockquote><p>示例四：</p><blockquote><p><strong>输入</strong>：sentence = “he bought 2 pencils, 3 erasers, and 1  pencil-sharpener.”<br><strong>输出</strong>：6<br><strong>解释</strong>：句子中的有效单词是 “he”、”bought”、”pencils,”、”erasers,”、”and” 和 “pencil-sharpener.”</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>1 &lt;= sentence.length &lt;= 1000</code></li><li>sentence 由小写英文字母、数字（<code>0-9</code>）、以及字符（<code>&#39; &#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;!&#39;</code>、<code>&#39;.&#39;</code> 和<code> &#39;,&#39;</code>）组成</li><li>句子中至少有 1 个 token</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>首先根据空格将句子分为单词</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>  <span class="hljs-keyword">while</span> (left&lt;n&amp;&amp;sentence.charAt(left)==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>    left++;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (left&gt;=n) <span class="hljs-keyword">break</span>;<br>  right = left+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (right &lt;n&amp;&amp;sentence.charAt(right)!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>    right++;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (isValidWord(sentence.substring(left,right)))&#123;<br>    ans++;<br>  &#125;<br>  left = right + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后判断单词是否有效。根据题目，单词有效的条件有三个：</p><ol><li>不能有数字</li><li>标点符号只能存在于单词结尾，且只能有一个</li><li>连字符最多只有一个，且连字符两端为小写字母</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidWord</span><span class="hljs-params">(String word)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> n = word.length();<br>  <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span> (word.charAt(i)&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;word.charAt(i)&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>      <span class="hljs-comment">// 判定为数字</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word.charAt(i)==<span class="hljs-string">&#x27;,&#x27;</span>||word.charAt(i)==<span class="hljs-string">&#x27;.&#x27;</span>||word.charAt(i)==<span class="hljs-string">&#x27;!&#x27;</span>)&#123;<br>      <span class="hljs-comment">// 判定标点符号位置</span><br>      <span class="hljs-keyword">if</span> (i!=n-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word.charAt(i)==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>      <span class="hljs-comment">// 判定是否有多个连字符，判定连字符位置（不能是0和n-1），判定连字符两端是否为字母</span><br>      <span class="hljs-keyword">if</span> (flag||i==<span class="hljs-number">0</span>||i==n-<span class="hljs-number">1</span>||!Character.isLetter(word.charAt(i-<span class="hljs-number">1</span>))||!Character.isLetter(word.charAt(i+<span class="hljs-number">1</span>)))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<br>      flag = <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>汇总起来即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countValidWords</span><span class="hljs-params">(String sentence)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>,left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> n = sentence.length();<br>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>    <span class="hljs-keyword">while</span> (left&lt;n&amp;&amp;sentence.charAt(left)==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>      left++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left&gt;= n) <span class="hljs-keyword">break</span>;<br>    right = left+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (right&lt;n&amp;&amp;sentence.charAt(right)!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>      right++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(isValidWord(sentence.substring(left,right)))&#123;<br>      ans++;<br>    &#125;<br>    left = right + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidWord</span><span class="hljs-params">(String word)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> n = word.length();<br>  <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span> (word.charAt(i)&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;word.charAt(i)&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>      <span class="hljs-comment">// 判定为数字</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word.charAt(i)==<span class="hljs-string">&#x27;,&#x27;</span>||word.charAt(i)==<span class="hljs-string">&#x27;.&#x27;</span>||word.charAt(i)==<span class="hljs-string">&#x27;!&#x27;</span>)&#123;<br>      <span class="hljs-keyword">if</span> (i!=n-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word.charAt(i)==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>      <span class="hljs-keyword">if</span> (flag||i==<span class="hljs-number">0</span>||i==n-<span class="hljs-number">1</span>||!Character.isLetter(word.charAt(i-<span class="hljs-number">1</span>))||!Character.isLetter(word.charAt(i+<span class="hljs-number">1</span>)))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<br>      flag = <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1996_游戏中弱角色的数量</title>
    <link href="/2022/01/28/1996-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/28/1996-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>难度：中等</p>          </div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 <code>properties</code> ，其中 <code>properties[i] = [attacki, defensei] </code>表示游戏中第 <code>i</code> 个角色的属性。</p><p>如果存在一个其他角色的攻击和防御等级 <strong>都严格高于</strong> 该角色的攻击和防御等级，则认为该角色为 <strong>弱角色</strong> 。更正式地，如果认为角色<code> i</code> 弱于 存在的另一个角色 <code>j</code> ，那么 <code>attackj &gt; attacki </code>且 <code>defensej &gt; defensei </code>。</p><p>返回 弱角色 的数量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><blockquote><p><strong>输入</strong>：properties = [[5,5],[6,3],[3,6]]<br><strong>输出</strong>：0<br><strong>解释</strong>：不存在攻击和防御都严格高于其他角色的角色。</p></blockquote><p>示例二：</p><blockquote><p><strong>输入</strong>：properties = [[2,2],[3,3]]<br><strong>输出</strong>：1<br><strong>解释</strong>：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</p></blockquote><p>示例三：</p><blockquote><p><strong>输入</strong>：properties = [[1,5],[10,4],[4,3]]<br><strong>输出</strong>：1<br><strong>解释</strong>：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><code>2 &lt;= properties.length &lt;= 105</code></li><li><code>properties[i].length == 2</code></li><li><code>1 &lt;= attacki, defensei &lt;= 105</code></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>因为判定弱角色的条件为有人攻击力和防御力都比它高</p><p>所以按照攻击力从大到小排序，然后开始遍历，遍历过程中更新最高防御力。只要前面有比它防御力高的，则它是弱角色。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numberOfWeakCharacters</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] properties)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        Arrays.sort(properties, (a, b) -&gt; a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>] : b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> max = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> n =properties.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(max&gt;properties[i][<span class="hljs-number">1</span>])&#123;<br>                ans++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            max = Math.max(max, properties[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="关于-Java-的数组排序"><a href="#关于-Java-的数组排序" class="headerlink" title="关于 Java 的数组排序"></a>关于 Java 的数组排序</h3><p>Arrarys.sort() 是用于给数组排序的，默认的情况下，是顺序排序，即从小到大</p><p>在自定义比较器，重写compare方法时，return正值，返回后一个元素；return负值，返回前一个元素；return 0，两个元素顺序不变。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Arrays.sort(properties,(a,b)-&gt;&#123;<br>  <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>])&#123;<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]-b[<span class="hljs-number">1</span>];<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>]-a[<span class="hljs-number">0</span>];<br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty学习之NIO基础</title>
    <link href="/2022/01/27/NIO%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/27/NIO%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty学习之NIO基础"><a href="#Netty学习之NIO基础" class="headerlink" title="Netty学习之NIO基础"></a>Netty学习之NIO基础</h1><h1 id="一、三大组件简介"><a href="#一、三大组件简介" class="headerlink" title="一、三大组件简介"></a>一、三大组件简介</h1><p>Channel与Buffer</p><p>Java NIO系统的<strong>核心</strong>在于：<strong>通道(Channel)和缓冲区(Buffer)<strong>。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于</strong>连接 IO 设备的通道</strong>以及用于<strong>容纳数据的缓冲区</strong>。然后操作缓冲区，对数据进行处理</p><p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p><p><strong>常见的Channel有以下四种</strong>，其中FileChannel主要用于文件传输，其余三种用于网络通信</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p><strong>Buffer有以下几种</strong>，其中使用较多的是ByteBuffer</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412135510.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214549.png" alt="img"></a></p><h2 id="1、Selector"><a href="#1、Selector" class="headerlink" title="1、Selector"></a>1、Selector</h2><p>在使用Selector之前，处理socket连接还有以下两种方法</p><p><strong>使用多线程技术</strong></p><p>为每个连接分别开辟一个线程，分别去处理对应的socke连接</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181918.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214553.png" alt="img"></a></p><p>这种方法存在以下几个问题</p><ul><li>内存占用高<ul><li>每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存</li></ul></li><li>线程上下文切换成本高</li><li>只适合连接数少的场景<ul><li>连接数过多，会导致创建很多线程，从而出现问题</li></ul></li></ul><p><strong>使用线程池技术</strong></p><p>使用线程池，让线程池中的线程去处理连接</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181933.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214558.png" alt="img"></a></p><p>这种方法存在以下几个问题</p><ul><li><p>阻塞模式下，线程仅能处理一个连接</p><ul><li>线程池中的线程获取任务（task）后，<strong>只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务</strong></li><li>若socke连接一直未断开，则其对应的线程无法处理其他socke连接</li></ul></li><li><p>仅适合</p><p>短连接</p><p>场景</p><ul><li>短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接</li></ul></li></ul><p><strong>使用选择器</strong></p><p><strong>selector 的作用就是配合一个线程来管理多个 channel（fileChannel因为是阻塞式的，所以无法使用selector）</strong>，获取这些 channel 上发生的<strong>事件</strong>，这些 channel 工作在<strong>非阻塞模式</strong>下，当一个channel中没有执行任务时，可以去执行其他channel中的任务。<strong>适合连接数多，但流量较少的场景</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181947.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214604.png" alt="img"></a></p><p>若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理</p><h2 id="2、ByteBuffer"><a href="#2、ByteBuffer" class="headerlink" title="2、ByteBuffer"></a>2、ByteBuffer</h2><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li><p>向 buffer 写入数据，例如调用 channel.read(buffer)</p></li><li><p>调用 flip() 切换至</p><p>读模式</p><ul><li><strong>flip会使得buffer中的limit变为position，position变为0</strong></li></ul></li><li><p>从 buffer 读取数据，例如调用 buffer.get()</p></li><li><p>调用 clear() 或者compact()切换至</p><p>写模式</p><ul><li>调用clear()方法时<strong>position=0，limit变为capacity</strong></li><li>调用compact()方法时，<strong>会将缓冲区中的未读数据压缩到缓冲区前面</strong></li></ul></li><li><p>重复以上步骤</p></li></ul><p><strong>使用ByteBuffer读取文件中的内容</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestByteBuffer</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 获得FileChannel</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span> (FileChannel channel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;stu.txt&quot;</span>).<span class="hljs-built_in">getChannel</span>()) &#123;<br>            <span class="hljs-comment">// 获得缓冲区</span><br>            ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">int</span> hasNext = <span class="hljs-number">0</span>;<br>            StringBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>            <span class="hljs-keyword">while</span>((hasNext = channel.<span class="hljs-built_in">read</span>(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 切换模式 limit=position, position=0</span><br>                buffer.<span class="hljs-built_in">flip</span>();<br>                <span class="hljs-comment">// 当buffer中还有数据时，获取其中的数据</span><br>                <span class="hljs-keyword">while</span>(buffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>                    builder.<span class="hljs-built_in">append</span>((<span class="hljs-keyword">char</span>)buffer.<span class="hljs-built_in">get</span>());<br>                &#125;<br>                <span class="hljs-comment">// 切换模式 position=0, limit=capacity</span><br>                buffer.<span class="hljs-built_in">clear</span>();<br>            &#125;<br>            System.out.<span class="hljs-built_in">println</span>(builder.<span class="hljs-built_in">toString</span>());<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>打印结果</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">0123456789abcdefCopy<br></code></pre></div></td></tr></table></figure><h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><p>字节缓冲区的父类Buffer中有几个核心属性，如下</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mark = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;Copy<br></code></pre></div></td></tr></table></figure><ul><li><strong>capacity</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li><strong>limit</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li><strong>position</strong>：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li><strong>mark</strong>：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214537.png" alt="img"></a></p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214613.png" alt="img"></a></p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li><li><strong>注意：get(i)方法不会改变position的值</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214617.png" alt="img"></a></p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214622.png" alt="img"></a></p><h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h4><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214637.png" alt="img"></a></p><h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值</li></ul><h4 id="compact-方法"><a href="#compact-方法" class="headerlink" title="compact()方法"></a>compact()方法</h4><p><strong>此方法为ByteBuffer的方法，而不是Buffer的方法</strong></p><ul><li>compact会把未读完的数据向前压缩，然后切换到写模式</li><li>数据前移后，原位置的值并未清零，写时会<strong>覆盖</strong>之前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412155726.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214649.png" alt="img"></a></p><h4 id="clear-VS-compact"><a href="#clear-VS-compact" class="headerlink" title="clear() VS compact()"></a>clear() VS compact()</h4><p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。<strong>所以compact比clear更耗性能。</strong>但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p><p><strong>所以需要根据情况来判断使用哪种方法进行模式切换</strong></p><h3 id="方法调用及演示"><a href="#方法调用及演示" class="headerlink" title="方法调用及演示"></a>方法调用及演示</h3><h4 id="ByteBuffer调试工具类"><a href="#ByteBuffer调试工具类" class="headerlink" title="ByteBuffer调试工具类"></a>ByteBuffer调试工具类</h4><p>需要先导入netty依赖</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">&lt;dependency&gt;<br>  &lt;groupId&gt;io.netty&lt;/groupId&gt;<br>  &lt;artifactId&gt;netty-all&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">4.1</span>.<span class="hljs-number">51</span>.<span class="hljs-keyword">Final</span>&lt;/version&gt;<br>&lt;/dependency&gt;<span class="hljs-keyword">Copy</span><br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-keyword">import</span> io.netty.util.internal.MathUtil;<br><span class="hljs-keyword">import</span> io.netty.util.internal.StringUtil;<br><span class="hljs-keyword">import</span> io.netty.util.internal.MathUtil.*;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author Panwen Chen</span><br><span class="hljs-comment"> * @date 2021/4/12 15:59</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ByteBufferUtil &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] BYTE2CHAR = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] HEXDUMP_TABLE = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">256</span> * <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXPADDING = <span class="hljs-keyword">new</span> String[<span class="hljs-number">16</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="hljs-keyword">new</span> String[<span class="hljs-number">65536</span> &gt;&gt;&gt; <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTE2HEX = <span class="hljs-keyword">new</span> String[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTEPADDING = <span class="hljs-keyword">new</span> String[<span class="hljs-number">16</span>];<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] DIGITS = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>            HEXDUMP_TABLE[i &lt;&lt; <span class="hljs-number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0</span>x0F];<br>            HEXDUMP_TABLE[(i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>] = DIGITS[i &amp; <span class="hljs-number">0</span>x0F];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> i;<br><br>        <span class="hljs-comment">// Generate the lookup table for hex dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXPADDING.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> padding = HEXPADDING.length - i;<br>            StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(padding * <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot;   &quot;</span>);<br>            &#125;<br>            HEXPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;<br>            StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">12</span>);<br>            buf.<span class="hljs-keyword">append</span>(StringUtil.NEWLINE);<br>            buf.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">Long</span>.toHexString(i &lt;&lt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0</span>xFFFFFFFFL | <span class="hljs-number">0</span>x100000000L));<br>            buf.setCharAt(buf.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            buf.<span class="hljs-keyword">append</span>(<span class="hljs-string">&#x27;|&#x27;</span>);<br>            HEXDUMP_ROWPREFIXES[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-hex-dump conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;<br>            BYTE2HEX[i] = <span class="hljs-string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> padding = BYTEPADDING.length - i;<br>            StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(padding);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.<span class="hljs-keyword">append</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>            BYTEPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-char conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0</span>x1f || i &gt;= <span class="hljs-number">0</span>x7f) &#123;<br>                BYTE2CHAR[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                BYTE2CHAR[i] = (<span class="hljs-keyword">char</span>) i;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印所有内容</span><br><span class="hljs-comment">     * @param buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> debugAll(ByteBuffer buffer) &#123;<br>        <span class="hljs-keyword">int</span> oldlimit = buffer.limit();<br>        buffer.limit(buffer.capacity());<br>        StringBuilder origin = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(origin, buffer, <span class="hljs-number">0</span>, buffer.capacity());<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);<br>        System.out.<span class="hljs-keyword">println</span>(origin);<br>        buffer.limit(oldlimit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印可读取内容</span><br><span class="hljs-comment">     * @param buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> debugRead(ByteBuffer buffer) &#123;<br>        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());<br>        System.out.<span class="hljs-keyword">println</span>(builder);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> appendPrettyHexDump(StringBuilder <span class="hljs-keyword">dump</span>, ByteBuffer buf, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length) &#123;<br>        <span class="hljs-keyword">if</span> (MathUtil.isOutOfBounds(offset, length, buf.capacity())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<br>                    <span class="hljs-string">&quot;expected: &quot;</span> + <span class="hljs-string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="hljs-string">&quot;) &lt;= offset + length(&quot;</span> + length<br>                            + <span class="hljs-string">&quot;) &lt;= &quot;</span> + <span class="hljs-string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(<br>                <span class="hljs-string">&quot;         +-------------------------------------------------+&quot;</span> +<br>                        StringUtil.NEWLINE + <span class="hljs-string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +<br>                        StringUtil.NEWLINE + <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startIndex = offset;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fullRows = length &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> remainder = length &amp; <span class="hljs-number">0</span>xF;<br><br>        <span class="hljs-comment">// Dump the rows which have 16 bytes.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; fullRows; row++) &#123;<br>            <span class="hljs-keyword">int</span> rowStartIndex = (row &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br><br>            <span class="hljs-comment">// Per-row prefix.</span><br>            appendHexDumpRowPrefix(<span class="hljs-keyword">dump</span>, row, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-keyword">int</span> rowEndIndex = rowStartIndex + <span class="hljs-number">16</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// ASCII dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Dump the last row which has less than 16 bytes.</span><br>        <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> rowStartIndex = (fullRows &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br>            appendHexDumpRowPrefix(<span class="hljs-keyword">dump</span>, fullRows, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-keyword">int</span> rowEndIndex = rowStartIndex + remainder;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(HEXPADDING[remainder]);<br>            <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// Ascii dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(BYTEPADDING[remainder]);<br>            <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(StringUtil.NEWLINE +<br>                <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> appendHexDumpRowPrefix(StringBuilder <span class="hljs-keyword">dump</span>, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> rowStartIndex) &#123;<br>        <span class="hljs-keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;<br>            <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(HEXDUMP_ROWPREFIXES[row]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(StringUtil.NEWLINE);<br>            <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">Long</span>.toHexString(rowStartIndex &amp; <span class="hljs-number">0</span>xFFFFFFFFL | <span class="hljs-number">0</span>x100000000L));<br>            <span class="hljs-keyword">dump</span>.setCharAt(<span class="hljs-keyword">dump</span>.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            <span class="hljs-keyword">dump</span>.<span class="hljs-keyword">append</span>(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">short</span> getUnsignedByte(ByteBuffer buffer, <span class="hljs-keyword">int</span> index) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">short</span>) (buffer.get(index) &amp; <span class="hljs-number">0</span>xFF);<br>    &#125;<br>&#125;<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><h4 id="调用ByteBuffer的方法"><a href="#调用ByteBuffer的方法" class="headerlink" title="调用ByteBuffer的方法"></a>调用ByteBuffer的方法</h4><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestByteBuffer</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 向buffer中写入1个字节的数据</span><br>        buffer.<span class="hljs-built_in">put</span>((<span class="hljs-keyword">byte</span>)<span class="hljs-number">97</span>);<br>        <span class="hljs-comment">// 使用工具类，查看buffer状态</span><br>        ByteBufferUtil.<span class="hljs-built_in">debugAll</span>(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入4个字节的数据</span><br>        buffer.<span class="hljs-built_in">put</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">98</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>&#125;);<br>        ByteBufferUtil.<span class="hljs-built_in">debugAll</span>(buffer);<br><br>        <span class="hljs-comment">// 获取数据</span><br>        buffer.<span class="hljs-built_in">flip</span>();<br>        ByteBufferUtil.<span class="hljs-built_in">debugAll</span>(buffer);<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">get</span>());<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">get</span>());<br>        ByteBufferUtil.<span class="hljs-built_in">debugAll</span>(buffer);<br><br>        <span class="hljs-comment">// 使用compact切换模式</span><br>        buffer.<span class="hljs-built_in">compact</span>();<br>        ByteBufferUtil.<span class="hljs-built_in">debugAll</span>(buffer);<br><br>        <span class="hljs-comment">// 再次写入</span><br>        buffer.<span class="hljs-built_in">put</span>((<span class="hljs-keyword">byte</span>)<span class="hljs-number">102</span>);<br>        buffer.<span class="hljs-built_in">put</span>((<span class="hljs-keyword">byte</span>)<span class="hljs-number">103</span>);<br>        ByteBufferUtil.<span class="hljs-built_in">debugAll</span>(buffer);<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-comment">// 向缓冲区写入了一个字节的数据，此时postition为1</span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [1], limit: [10]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 00 00 00 00 00 00 00 00 00                   |a.........      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><span class="hljs-comment">// 向缓冲区写入四个字节的数据，此时position为5</span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [5], limit: [10]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><span class="hljs-comment">// 调用flip切换模式，此时position为0，表示从第0个数据开始读取</span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [0], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-comment">// 读取两个字节的数据             </span><br>97<br>98<br><span class="hljs-code">            </span><br><span class="hljs-comment">// position变为2             </span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [2], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">             </span><br><span class="hljs-comment">// 调用compact切换模式，此时position及其后面的数据被压缩到ByteBuffer前面去了</span><br><span class="hljs-comment">// 此时position为3，会覆盖之前的数据             </span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [3], limit: [10]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 64 65 64 65 00 00 00 00 00                   |cdede.....      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">             </span><br><span class="hljs-comment">// 再次写入两个字节的数据，之前的 0x64 0x65 被覆盖         </span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [5], limit: [10]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 63 64 65 66 67 00 00 00 00 00                   |cdefg.....      |<br><span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span>Copy<br></code></pre></div></td></tr></table></figure><h3 id="字符串与ByteBuffer的相互转换"><a href="#字符串与ByteBuffer的相互转换" class="headerlink" title="字符串与ByteBuffer的相互转换"></a><strong>字符串与ByteBuffer的相互转换</strong></h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><strong>编码</strong>：字符串调用getByte方法获得byte数组，将byte数组放入ByteBuffer中</p><p><strong>解码</strong>：<strong>先调用ByteBuffer的flip方法，然后通过StandardCharsets的decoder方法解码</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Translate &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 准备两个字符串</span><br>        String str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String str2 = <span class="hljs-string">&quot;&quot;</span>;<br><br><br>        ByteBuffer buffer1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">// 通过字符串的getByte方法获得字节数组，放入缓冲区中</span><br>        buffer1.put(str1.get<span class="hljs-constructor">Bytes()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br><br>        <span class="hljs-comment">// 将缓冲区中的数据转化为字符串</span><br>        <span class="hljs-comment">// 切换模式</span><br>        buffer1.flip<span class="hljs-literal">()</span>;<br>        <br>        <span class="hljs-comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span><br>        str2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardCharsets</span>.</span><span class="hljs-module"><span class="hljs-identifier">UTF_8</span>.</span></span>decode(buffer1).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str2);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">+--------+-------------------- all ------------------------+----------------+<br>position: [5], limit: [16]<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 68 </span>65 6c 6c 6f<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>|hello...........|<br>+--------+-------------------------------------------------+----------------+<br>hello<br>+--------+-------------------- all ------------------------+----------------+<br>position: [5], limit: [5]<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 68 </span>65 6c 6c 6f<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>|hello...........|<br>+--------+-------------------------------------------------+----------------+Copy<br></code></pre></div></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>编码</strong>：通过StandardCharsets的encode方法获得ByteBuffer，此时获得的ByteBuffer为读模式，无需通过flip切换模式</p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Translate &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 准备两个字符串</span><br>        String str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String str2 = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 通过StandardCharsets的encode方法获得ByteBuffer</span><br>        <span class="hljs-comment">// 此时获得的ByteBuffer为读模式，无需通过flip切换模式</span><br>        ByteBuffer buffer1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardCharsets</span>.</span><span class="hljs-module"><span class="hljs-identifier">UTF_8</span>.</span></span>encode(str1);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br><br>        <span class="hljs-comment">// 将缓冲区中的数据转化为字符串</span><br>        <span class="hljs-comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span><br>        str2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardCharsets</span>.</span><span class="hljs-module"><span class="hljs-identifier">UTF_8</span>.</span></span>decode(buffer1).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str2);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [0], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>hello<br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [5], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 68 65 6c 6c 6f                                  |hello           |<br><span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span>Copy<br></code></pre></div></td></tr></table></figure><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a><strong>方法三</strong></h4><p><strong>编码</strong>：字符串调用getByte()方法获得字节数组，将字节数组传给<strong>ByteBuffer的wrap()方法</strong>，通过该方法获得ByteBuffer。<strong>同样无需调用flip方法切换为读模式</strong></p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Translate &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 准备两个字符串</span><br>        String str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String str2 = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 通过StandardCharsets的encode方法获得ByteBuffer</span><br>        <span class="hljs-comment">// 此时获得的ByteBuffer为读模式，无需通过flip切换模式</span><br>        ByteBuffer buffer1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>wrap(str1.get<span class="hljs-constructor">Bytes()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br><br>        <span class="hljs-comment">// 将缓冲区中的数据转化为字符串</span><br>        <span class="hljs-comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span><br>        str2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardCharsets</span>.</span><span class="hljs-module"><span class="hljs-identifier">UTF_8</span>.</span></span>decode(buffer1).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str2);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [0], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>hello<br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [5], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 68 65 6c 6c 6f                                  |hello           |<br><span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span>Copy<br></code></pre></div></td></tr></table></figure><h3 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p><ul><li>Hello,world\n</li><li>I’m Nyima\n</li><li>How are you?\n</li></ul><p>变成了下面的两个 byteBuffer (粘包，半包)</p><ul><li>Hello,world\nI’m Nyima\nHo</li><li>w are you?\n</li></ul><h4 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h4><p><strong>粘包</strong></p><p>发送方在发送数据时，并不是一条一条地发送数据，而是<strong>将数据整合在一起</strong>，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</p><p><strong>半包</strong></p><p>接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要<strong>将信息截断</strong>，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li><p>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。</p><p>注意</p><p>：get(index)不会改变position的值</p><ul><li>记录该段数据长度，以便于申请对应大小的缓冲区</li><li>将缓冲区的数据通过get()方法写入到target中</li></ul></li><li><p>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</p></li></ul><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufferDemo</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">32</span>);<br>        <span class="hljs-comment">// 模拟粘包+半包</span><br>        buffer.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;Hello,world\nI&#x27;m Nyima\nHo&quot;</span>.<span class="hljs-built_in">getBytes</span>());<br>        <span class="hljs-comment">// 调用split函数处理</span><br>        <span class="hljs-built_in">split</span>(buffer);<br>        buffer.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;w are you?\n&quot;</span>.<span class="hljs-built_in">getBytes</span>());<br>        <span class="hljs-built_in">split</span>(buffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(ByteBuffer buffer)</span> </span>&#123;<br>        <span class="hljs-comment">// 切换为读模式</span><br>        buffer.<span class="hljs-built_in">flip</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.<span class="hljs-built_in">limit</span>(); i++) &#123;<br><br>            <span class="hljs-comment">// 遍历寻找分隔符</span><br>            <span class="hljs-comment">// get(i)不会移动position</span><br>            <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">get</span>(i) == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 缓冲区长度</span><br>                <span class="hljs-keyword">int</span> length = i+<span class="hljs-number">1</span>-buffer.<span class="hljs-built_in">position</span>();<br>                ByteBuffer target = ByteBuffer.<span class="hljs-built_in">allocate</span>(length);<br>                <span class="hljs-comment">// 将前面的内容写入target缓冲区</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                    <span class="hljs-comment">// 将buffer中的数据写入target中</span><br>                    target.<span class="hljs-built_in">put</span>(buffer.<span class="hljs-built_in">get</span>());<br>                &#125;<br>                <span class="hljs-comment">// 打印查看结果</span><br>                ByteBufferUtil.<span class="hljs-built_in">debugAll</span>(target);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 切换为写模式，但是缓冲区可能未读完，这里需要使用compact</span><br>        buffer.<span class="hljs-built_in">compact</span>();<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [12], limit: [12]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 48 65 6c 6c 6f 2c 77 6f 72 6c 64 0a             |Hello,world.    |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [10], limit: [10]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 49 27 6d 20 4e 79 69 6d 61 0a                   |I&#x27;m Nyima.      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [13], limit: [13]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 48 6f 77 20 61 72 65 20 79 6f 75 3f 0a          |How are you?.   |<br><span class="hljs-code">+--------+</span>-------------------------------------------------<span class="hljs-code">+----------------+</span>Copy<br></code></pre></div></td></tr></table></figure><h1 id="二、文件编程"><a href="#二、文件编程" class="headerlink" title="二、文件编程"></a>二、文件编程</h1><h2 id="1、FileChannel"><a href="#1、FileChannel" class="headerlink" title="1、FileChannel"></a>1、FileChannel</h2><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>FileChannel<strong>只能在阻塞模式下工作</strong>，所以无法搭配Selector</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>不能直接打开 FileChannel，<strong>必须</strong>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel <strong>只能读</strong></li><li>通过 FileOutputStream 获取的 channel <strong>只能写</strong></li><li>通过 RandomAccessFile 是否能读写<strong>根据构造 RandomAccessFile 时的读写模式决定</strong></li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>通过 FileInputStream 获取channel，通过read方法将数据写入到ByteBuffer中</p><p>read方法的返回值表示读到了多少字节，若读到了文件末尾则返回-1</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> readBytes = channel.<span class="hljs-built_in">read</span>(buffer);Copy<br></code></pre></div></td></tr></table></figure><p><strong>可根据返回值判断是否读取完毕</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">while</span>(channel.<span class="hljs-built_in">read</span>(buffer) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 进行对应操作</span><br>    ...<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>因为channel也是有大小的，所以 write 方法并不能保证一次将 buffer 中的内容全部写入 channel。必须<strong>需要按照以下规则进行写入</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">// 通过hasRemaining()方法查看缓冲区中是否还有数据未写入到通道中</span><br><span class="hljs-keyword">while</span>(buffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>channel.<span class="hljs-built_in">write</span>(buffer);<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>通道需要close，一般情况通过try-with-resource进行关闭，<strong>最好使用以下方法获取strea以及channel，避免某些原因使得资源未被关闭</strong></p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestChannel</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) throws IOException &#123;<br>        <span class="hljs-keyword">try</span> (FileInputStream fis = <span class="hljs-keyword">new</span> <span class="hljs-type">FileInputStream</span>(<span class="hljs-string">&quot;stu.txt&quot;</span>);<br>             FileOutputStream fos = <span class="hljs-keyword">new</span> <span class="hljs-type">FileOutputStream</span>(<span class="hljs-string">&quot;student.txt&quot;</span>);<br>             FileChannel inputChannel = fis.getChannel();<br>             FileChannel outputChannel = fos.getChannel()) &#123;<br>            <br>            <span class="hljs-comment">// 执行对应操作</span><br>            ...<br>                <br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><strong>position</strong></p><p>channel也拥有一个保存读取数据位置的属性，即position</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">long pos <span class="hljs-operator">=</span> channel.<span class="hljs-built_in">position</span>();<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><p>可以通过position(int pos)设置channel中position的值</p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe">long <span class="hljs-keyword">new</span><span class="hljs-type">Pos</span> = ...;<br>channel.position(<span class="hljs-keyword">new</span><span class="hljs-type">Pos</span>);Copy<br></code></pre></div></td></tr></table></figure><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1 </li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘，而是等到缓存满了以后将所有数据一次性的写入磁盘。可以调用 <strong>force(true)</strong> 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h2 id="2、两个Channel传输数据"><a href="#2、两个Channel传输数据" class="headerlink" title="2、两个Channel传输数据"></a>2、两个Channel传输数据</h2><h3 id="transferTo方法"><a href="#transferTo方法" class="headerlink" title="transferTo方法"></a>transferTo方法</h3><p>使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但<strong>一次只能传输2G的内容</strong></p><p>transferTo底层使用了零拷贝技术</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestChannel</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span> (FileInputStream fis = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;stu.txt&quot;</span>);<br>             FileOutputStream fos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileOutputStream</span>(<span class="hljs-string">&quot;student.txt&quot;</span>);<br>             FileChannel inputChannel = fis.<span class="hljs-built_in">getChannel</span>();<br>             FileChannel outputChannel = fos.<span class="hljs-built_in">getChannel</span>()) &#123;<br>            <span class="hljs-comment">// 参数：inputChannel的起始位置，传输数据的大小，目的channel</span><br>            <span class="hljs-comment">// 返回值为传输的数据的字节数</span><br>            <span class="hljs-comment">// transferTo一次只能传输2G的数据</span><br>            inputChannel.<span class="hljs-built_in">transferTo</span>(<span class="hljs-number">0</span>, inputChannel.<span class="hljs-built_in">size</span>(), outputChannel);<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>当传输的文件<strong>大于2G</strong>时，需要使用以下方法进行多次传输</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestChannel</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span> (FileInputStream fis = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;stu.txt&quot;</span>);<br>             FileOutputStream fos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileOutputStream</span>(<span class="hljs-string">&quot;student.txt&quot;</span>);<br>             FileChannel inputChannel = fis.<span class="hljs-built_in">getChannel</span>();<br>             FileChannel outputChannel = fos.<span class="hljs-built_in">getChannel</span>()) &#123;<br>            <span class="hljs-keyword">long</span> size = inputChannel.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">long</span> capacity = inputChannel.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 分多次传输</span><br>            <span class="hljs-keyword">while</span> (capacity &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// transferTo返回值为传输了的字节数</span><br>                capacity -= inputChannel.<span class="hljs-built_in">transferTo</span>(size-capacity, capacity, outputChannel);<br>            &#125;<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><h2 id="3、Path与Paths"><a href="#3、Path与Paths" class="headerlink" title="3、Path与Paths"></a>3、Path与Paths</h2><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">Path source = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(<span class="hljs-string">&quot;1.txt&quot;</span>); <span class="hljs-comment">// 相对路径 不带盘符 使用 user.dir 环境变量来定位 1.txt</span><br><br>Path source = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>); <span class="hljs-comment">// 绝对路径 代表了  d:\1.txt 反斜杠需要转义</span><br><br>Path source = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(<span class="hljs-string">&quot;d:/1.txt&quot;</span>); <span class="hljs-comment">// 绝对路径 同样代表了  d:\1.txt</span><br><br>Path projects = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(<span class="hljs-string">&quot;d:\\data&quot;</span>, <span class="hljs-string">&quot;projects&quot;</span>); <span class="hljs-comment">// 代表了  d:\data\projectsCopy</span><br></code></pre></div></td></tr></table></figure><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">d:<br><span class="hljs-string">|- data</span><br><span class="hljs-string">|- projects</span><br><span class="hljs-string">|- a</span><br><span class="hljs-string">|- bCopy</span><br></code></pre></div></td></tr></table></figure><p>代码</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">Path</span> <span class="hljs-keyword">path</span> = Paths.<span class="hljs-keyword">get</span>(&quot;d:\\data\\projects\\a\\..\\b&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">path</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">path</span>.normalize()); // 正常化路径 会去除 . 以及 ..<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><p>输出结果为</p><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">d:<span class="hljs-symbol">\d</span>ata<span class="hljs-symbol">\p</span>rojects<span class="hljs-symbol">\a</span><span class="hljs-symbol">\.</span>.<span class="hljs-symbol">\b</span><br>d:<span class="hljs-symbol">\d</span>ata<span class="hljs-symbol">\p</span>rojects<span class="hljs-symbol">\b</span>Copy<br></code></pre></div></td></tr></table></figure><h2 id="4、Files"><a href="#4、Files" class="headerlink" title="4、Files"></a>4、Files</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>检查文件是否存在</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">Path</span> <span class="hljs-keyword">path</span> = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/data.txt&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Files.<span class="hljs-keyword">exists</span>(<span class="hljs-type">path</span>));<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建<strong>一级目录</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">Path</span> <span class="hljs-keyword">path</span> = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/d1&quot;);<br>Files.createDirectory(<span class="hljs-type">path</span>);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建<strong>多级目录用</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">Path</span> <span class="hljs-keyword">path</span> = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/d1/d2&quot;);<br>Files.createDirectories(<span class="hljs-type">path</span>);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><h3 id="拷贝及移动"><a href="#拷贝及移动" class="headerlink" title="拷贝及移动"></a>拷贝及移动</h3><p><strong>拷贝文件</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-type">Path</span> source = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/data.txt&quot;);<br><span class="hljs-type">Path</span> target = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/target.txt&quot;);<br><br>Files.<span class="hljs-keyword">copy</span>(source, target);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source <strong>覆盖</strong>掉 target，需要用 StandardCopyOption 来控制</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">Files.<span class="hljs-keyword">copy</span>(<span class="hljs-keyword">source</span>, target, StandardCopyOption.REPLACE_EXISTING);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><p>移动文件</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-type">Path</span> source = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/data.txt&quot;);<br><span class="hljs-type">Path</span> target = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/data.txt&quot;);<br><br>Files.<span class="hljs-keyword">move</span>(source, target, StandardCopyOption.ATOMIC_MOVE);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</strong></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除文件</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-type">Path</span> target = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/target.txt&quot;);<br><br>Files.<span class="hljs-keyword">delete</span>(target);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-type">Path</span> target = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/d1&quot;);<br><br>Files.<span class="hljs-keyword">delete</span>(target);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><ul><li>如果<strong>目录还有内容</strong>，会抛异常 DirectoryNotEmptyException</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>可以<strong>使用Files工具类中的walkFileTree(Path, FileVisitor)方法</strong>，其中需要传入两个参数</p><ul><li><p>Path：文件起始路径</p></li><li><p>FileVisitor：文件访问器，</p><p>使用访问者模式</p><ul><li><p>接口的实现类</p><p>SimpleFileVisitor</p><p>有四个方法</p><ul><li>preVisitDirectory：访问目录前的操作</li><li>visitFile：访问文件的操作</li><li>visitFileFailed：访问文件失败时的操作</li><li>postVisitDirectory：访问目录后的操作</li></ul></li></ul></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TestWalkFileTree &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException &#123;<br>        Path path = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(<span class="hljs-string">&quot;F:\\JDK 8&quot;</span>);<br>        <span class="hljs-comment">// 文件目录数目</span><br>        AtomicInteger dirCount = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AtomicInteger()</span>;<br>        <span class="hljs-comment">// 文件数目</span><br>        AtomicInteger fileCount = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AtomicInteger()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Files</span>.</span></span>walk<span class="hljs-constructor">FileTree(<span class="hljs-params">path</span>, <span class="hljs-params">new</span> SimpleFileVisitor&lt;Path&gt;()</span>&#123;<br>            @Override<br>            public FileVisitResult pre<span class="hljs-constructor">VisitDirectory(Path <span class="hljs-params">dir</span>, BasicFileAttributes <span class="hljs-params">attrs</span>)</span> throws IOException &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===&gt;&quot;</span>+dir);<br>                <span class="hljs-comment">// 增加文件目录数</span><br>                dirCount.increment<span class="hljs-constructor">AndGet()</span>;<br>                return super.pre<span class="hljs-constructor">VisitDirectory(<span class="hljs-params">dir</span>, <span class="hljs-params">attrs</span>)</span>;<br>            &#125;<br><br>            @Override<br>            public FileVisitResult visit<span class="hljs-constructor">File(Path <span class="hljs-params">file</span>, BasicFileAttributes <span class="hljs-params">attrs</span>)</span> throws IOException &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file);<br>                <span class="hljs-comment">// 增加文件数</span><br>                fileCount.increment<span class="hljs-constructor">AndGet()</span>;<br>                return super.visit<span class="hljs-constructor">File(<span class="hljs-params">file</span>, <span class="hljs-params">attrs</span>)</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 打印数目</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;文件目录数:&quot;</span>+dirCount.get<span class="hljs-literal">()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;文件数:&quot;</span>+fileCount.get<span class="hljs-literal">()</span>);<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>运行结果如下</p><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">...<br>===&gt;F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>ecurity<span class="hljs-symbol">\p</span>olicy<span class="hljs-symbol">\u</span>nlimited<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>ecurity<span class="hljs-symbol">\p</span>olicy<span class="hljs-symbol">\u</span>nlimited<span class="hljs-symbol">\l</span>ocal_policy.jar<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>ecurity<span class="hljs-symbol">\p</span>olicy<span class="hljs-symbol">\u</span>nlimited<span class="hljs-symbol">\U</span>S_export_policy.jar<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>ecurity<span class="hljs-symbol">\t</span>rusted.libraries<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>ound.properties<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\t</span>zdb.dat<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\t</span>zmappings<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\L</span>ICENSE<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\R</span>EADME.txt<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\r</span>elease<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\T</span>HIRDPARTYLICENSEREADME-JAVAFX.txt<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\T</span>HIRDPARTYLICENSEREADME.txt<br>F:<span class="hljs-symbol">\J</span>DK 8<span class="hljs-symbol">\W</span>elcome.html<br>文件目录数:23<br>文件数:279Copy<br></code></pre></div></td></tr></table></figure><h1 id="三、网络编程"><a href="#三、网络编程" class="headerlink" title="三、网络编程"></a>三、网络编程</h1><h2 id="1、阻塞"><a href="#1、阻塞" class="headerlink" title="1、阻塞"></a>1、阻塞</h2><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li><li>SocketChannel.read 会在<strong>通道中没有数据可读时</strong>让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li></ul></li></ul><p><strong>服务端代码</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建缓冲区</span><br>        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">// 获得服务器通道</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span>(ServerSocketChannel server = ServerSocketChannel.<span class="hljs-built_in">open</span>()) &#123;<br>            <span class="hljs-comment">// 为服务器通道绑定端口</span><br>            server.<span class="hljs-built_in">bind</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 用户存放连接的集合</span><br>            ArrayList&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-comment">// 循环接收连接</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;before connecting...&quot;</span>);<br>                <span class="hljs-comment">// 没有连接时，会阻塞线程</span><br>                SocketChannel socketChannel = server.<span class="hljs-built_in">accept</span>();<br>                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;after connecting...&quot;</span>);<br>                channels.<span class="hljs-built_in">add</span>(socketChannel);<br>                <span class="hljs-comment">// 循环遍历集合中的连接</span><br>                <span class="hljs-keyword">for</span>(SocketChannel channel : channels) &#123;<br>                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;before reading&quot;</span>);<br>                    <span class="hljs-comment">// 处理通道中的数据</span><br>                    <span class="hljs-comment">// 当通道中没有数据可读时，会阻塞线程</span><br>                    channel.<span class="hljs-built_in">read</span>(buffer);<br>                    buffer.<span class="hljs-built_in">flip</span>();<br>                    ByteBufferUtil.<span class="hljs-built_in">debugRead</span>(buffer);<br>                    buffer.<span class="hljs-built_in">clear</span>();<br>                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;after reading&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>客户端代码</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span> (SocketChannel socketChannel = SocketChannel.<span class="hljs-built_in">open</span>()) &#123;<br>            <span class="hljs-comment">// 建立连接</span><br>            socketChannel.<span class="hljs-built_in">connect</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>运行结果</p><ul><li>客户端-服务器建立连接前：服务器端因accept阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213318.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214712.png" alt="img"></a></p><ul><li>客户端-服务器建立连接后，客户端发送消息前：服务器端因通道为空被阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213446.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214716.png" alt="img"></a></p><ul><li>客户端发送数据后，服务器处理通道中的数据。再次进入循环时，再次被accept阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214109.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214721.png" alt="img"></a></p><ul><li>之前的客户端再次发送消息<strong>，服务器端因为被accept阻塞</strong>，无法处理之前客户端发送到通道中的信息</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214505.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214727.png" alt="img"></a></p><h2 id="2、非阻塞"><a href="#2、非阻塞" class="headerlink" title="2、非阻塞"></a>2、非阻塞</h2><ul><li>可以通过ServerSocketChannel的configureBlocking(<strong>false</strong>)方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</li><li>可以通过SocketChannel的configureBlocking(<strong>false</strong>)方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</li></ul><p>服务器代码如下</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建缓冲区</span><br>        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">// 获得服务器通道</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span>(ServerSocketChannel server = ServerSocketChannel.<span class="hljs-built_in">open</span>()) &#123;<br>            <span class="hljs-comment">// 为服务器通道绑定端口</span><br>            server.<span class="hljs-built_in">bind</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 用户存放连接的集合</span><br>            ArrayList&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-comment">// 循环接收连接</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 设置为非阻塞模式，没有连接时返回null，不会阻塞线程</span><br>                server.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>                SocketChannel socketChannel = server.<span class="hljs-built_in">accept</span>();<br>                <span class="hljs-comment">// 通道不为空时才将连接放入到集合中</span><br>                <span class="hljs-keyword">if</span> (socketChannel != null) &#123;<br>                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;after connecting...&quot;</span>);<br>                    channels.<span class="hljs-built_in">add</span>(socketChannel);<br>                &#125;<br>                <span class="hljs-comment">// 循环遍历集合中的连接</span><br>                <span class="hljs-keyword">for</span>(SocketChannel channel : channels) &#123;<br>                    <span class="hljs-comment">// 处理通道中的数据</span><br>                    <span class="hljs-comment">// 设置为非阻塞模式，若通道中没有数据，会返回0，不会阻塞线程</span><br>                    channel.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-keyword">int</span> read = channel.<span class="hljs-built_in">read</span>(buffer);<br>                    <span class="hljs-keyword">if</span>(read &gt; <span class="hljs-number">0</span>) &#123;<br>                        buffer.<span class="hljs-built_in">flip</span>();<br>                        ByteBufferUtil.<span class="hljs-built_in">debugRead</span>(buffer);<br>                        buffer.<span class="hljs-built_in">clear</span>();<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;after reading&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p>这样写存在一个问题，因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求</p><h2 id="3、Selector"><a href="#3、Selector" class="headerlink" title="3、Selector"></a>3、Selector</h2><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p><ul><li><strong>多路复用仅针对网络 IO</strong>，普通文件 IO <strong>无法</strong>利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul></li></ul><h2 id="4、使用及Accpet事件"><a href="#4、使用及Accpet事件" class="headerlink" title="4、使用及Accpet事件"></a>4、使用及Accpet事件</h2><p>要使用Selector实现多路复用，服务端代码如下改进</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> SelectServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ByteBuffer buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">// 获得服务器通道</span><br>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>) &#123;<br>            server.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(8080)</span>);<br>            <span class="hljs-comment">// 创建选择器</span><br>            Selector selector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Selector</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>            <br>            <span class="hljs-comment">// 通道必须设置为非阻塞模式</span><br>            server.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>            <span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的事件</span><br>            server.register(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span><br>                <span class="hljs-comment">// 返回值为就绪的事件个数</span><br>                <span class="hljs-built_in">int</span> ready = selector.select<span class="hljs-literal">()</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;selector ready counts : &quot;</span> + ready);<br>                <br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selected<span class="hljs-constructor">Keys()</span>;<br>                <br>                <span class="hljs-comment">// 使用迭代器遍历事件</span><br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">while</span> (iterator.has<span class="hljs-constructor">Next()</span>) &#123;<br>                    SelectionKey key = iterator.next<span class="hljs-literal">()</span>;<br>                    <br>                    <span class="hljs-comment">// 判断key的类型</span><br>                    <span class="hljs-keyword">if</span>(key.is<span class="hljs-constructor">Acceptable()</span>) &#123;<br>                        <span class="hljs-comment">// 获得key对应的channel</span><br>                        ServerSocketChannel channel = (ServerSocketChannel) key.channel<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;before accepting...&quot;</span>);<br>                        <br>        <span class="hljs-comment">// 获取连接并处理，而且是必须处理，否则需要取消</span><br>                        SocketChannel socketChannel = channel.accept<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;after accepting...&quot;</span>);<br>                        <br>                        <span class="hljs-comment">// 处理完毕后移除</span><br>                        iterator.remove<span class="hljs-literal">()</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; catch (IOException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p><strong>步骤解析</strong></p><ul><li>获得选择器Selector</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene"><span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span> = <span class="hljs-keyword">Selector</span>.open();<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><ul><li><p>将</p><p>通道设置为非阻塞模式</p><p>，并注册到选择器中，并设置感兴趣的事件</p><ul><li><p>channel 必须工作在非阻塞模式</p></li><li><p>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</p></li><li><p>绑定的</p><p>事件类型</p><p>可以有</p><ul><li>connect - 客户端连接成功时触发</li><li>accept - 服务器端成功接受连接时触发</li><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul></li></ul><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-comment">// 通道必须设置为非阻塞模式</span><br><span class="hljs-keyword">server</span>.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的实践</span><br><span class="hljs-keyword">server</span>.register(selector, SelectionKey.OP_ACCEPT);Copy<br></code></pre></div></td></tr></table></figure><ul><li><p>通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞</p><ul><li><p>阻塞直到绑定事件发生</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = selector.<span class="hljs-keyword">select</span>();Copy<br></code></pre></div></td></tr></table></figure></li><li><p>阻塞直到绑定事件发生，<strong>或是超时</strong>（时间单位为 ms）</p><figure class="highlight axapta"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = selector.<span class="hljs-keyword">select</span>(<span class="hljs-built_in">long</span> timeout);Copy<br></code></pre></div></td></tr></table></figure></li><li><p><strong>不会阻塞</strong>，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = selector.selectNow();<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>获取就绪事件并<strong>得到对应的通道</strong>，然后进行处理</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取所有事件<br>Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                <br><span class="hljs-regexp">//</span> 使用迭代器遍历事件<br>Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br><br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>SelectionKey key = iterator.<span class="hljs-keyword">next</span>();<br>                    <br><span class="hljs-regexp">//</span> 判断key的类型，此处为Accept类型<br><span class="hljs-keyword">if</span>(key.isAcceptable()) &#123;<br>        <span class="hljs-regexp">//</span> 获得key对应的channel<br>        ServerSocketChannel channel = (ServerSocketChannel) key.channel();<br><br>        <span class="hljs-regexp">//</span> 获取连接并处理，而且是必须处理，否则需要取消<br>        SocketChannel socketChannel = channel.accept();<br><br>        <span class="hljs-regexp">//</span> 处理完毕后移除<br>        iterator.remove();<br>&#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p><strong>事件发生后能否不处理</strong></p><p>事件发生后，<strong>要么处理，要么取消（cancel）</strong>，不能什么都不做，<strong>否则下次该事件仍会触发</strong>，这是因为 nio 底层使用的是水平触发</p><h2 id="5、Read事件"><a href="#5、Read事件" class="headerlink" title="5、Read事件"></a>5、Read事件</h2><ul><li>在Accept事件中，若有客户端与服务器端建立了连接，<strong>需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中</strong></li><li>添加Read事件，触发后进行读取操作</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> SelectServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ByteBuffer buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">// 获得服务器通道</span><br>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>) &#123;<br>            server.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(8080)</span>);<br>            <span class="hljs-comment">// 创建选择器</span><br>            Selector selector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Selector</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 通道必须设置为非阻塞模式</span><br>            server.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>            <span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的实践</span><br>            server.register(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-comment">// 为serverKey设置感兴趣的事件</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span><br>                <span class="hljs-comment">// 返回值为就绪的事件个数</span><br>                <span class="hljs-built_in">int</span> ready = selector.select<span class="hljs-literal">()</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;selector ready counts : &quot;</span> + ready);<br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selected<span class="hljs-constructor">Keys()</span>;<br>                <span class="hljs-comment">// 使用迭代器遍历事件</span><br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">while</span> (iterator.has<span class="hljs-constructor">Next()</span>) &#123;<br>                    SelectionKey key = iterator.next<span class="hljs-literal">()</span>;<br>                    <span class="hljs-comment">// 判断key的类型</span><br>                    <span class="hljs-keyword">if</span>(key.is<span class="hljs-constructor">Acceptable()</span>) &#123;<br>                        <span class="hljs-comment">// 获得key对应的channel</span><br>                        ServerSocketChannel channel = (ServerSocketChannel) key.channel<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;before accepting...&quot;</span>);<br>                        <span class="hljs-comment">// 获取连接</span><br>                        SocketChannel socketChannel = channel.accept<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;after accepting...&quot;</span>);<br>                        <span class="hljs-comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中</span><br>                        socketChannel.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>                        socketChannel.register(selector, SelectionKey.OP_READ);<br>                        <span class="hljs-comment">// 处理完毕后移除</span><br>                        iterator.remove<span class="hljs-literal">()</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.is<span class="hljs-constructor">Readable()</span>) &#123;<br>                        SocketChannel channel = (SocketChannel) key.channel<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;before reading...&quot;</span>);<br>                        channel.read(buffer);<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;after reading...&quot;</span>);<br>                        buffer.flip<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">Read(<span class="hljs-params">buffer</span>)</span>;<br>                        buffer.clear<span class="hljs-literal">()</span>;<br>                        <span class="hljs-comment">// 处理完毕后移除</span><br>                        iterator.remove<span class="hljs-literal">()</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; catch (IOException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p><strong>删除事件</strong></p><p><strong>当处理完一个事件后，一定要调用迭代器的remove方法移除对应事件，否则会出现错误</strong>。原因如下</p><p>以我们上面的 <strong>Read事件</strong> 的代码为例</p><ul><li><p>当调用了 server.register(selector, SelectionKey.OP_ACCEPT)后，Selector中维护了一个集合，<strong>用于存放SelectionKey以及其对应的通道</strong></p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-comment">// WindowsSelectorImpl 中的 SelectionKeyImpl数组</span><br><span class="hljs-keyword">private</span> SelectionKeyImpl[] channelArray = <span class="hljs-keyword">new</span> SelectionKeyImpl[<span class="hljs-number">8</span>];<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectionKeyImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSelectionKey</span> </span>&#123;<br>    <span class="hljs-comment">// Key对应的通道</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelChImpl</span> channel;<br>    ...<br>&#125;<span class="hljs-type">Copy</span><br></code></pre></div></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214738.png" alt="img"></a></p></li><li><p>当<strong>选择器中的通道对应的事件发生后</strong>，selecionKey会被放到另一个集合中，但是<strong>selecionKey不会自动移除</strong>，所以需要我们在处理完一个事件后，通过迭代器手动移除其中的selecionKey。否则会导致已被处理过的事件再次被处理，就会引发错误<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214743.png" alt="img"></a></p></li></ul><h3 id="断开处理"><a href="#断开处理" class="headerlink" title="断开处理"></a>断开处理</h3><p>当客户端与服务器之间的连接<strong>断开时，会给服务器端发送一个读事件</strong>，对异常断开和正常断开需要加以不同的方式进行处理</p><ul><li><p><strong>正常断开</strong></p><ul><li><p>正常断开时，服务器端的channel.read(buffer)方法的返回值为-1，<strong>所以当结束到返回值为-1时，需要调用key的cancel方法取消此事件，并在取消后移除该事件</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> read = channel.<span class="hljs-built_in">read</span>(buffer);<br><span class="hljs-comment">// 断开连接时，客户端会向服务器发送一个写事件，此时read的返回值为-1</span><br><span class="hljs-keyword">if</span>(read == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// 取消该事件的处理</span><br>key.<span class="hljs-built_in">cancel</span>();<br>    channel.<span class="hljs-built_in">close</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    ...<br>&#125;<br><span class="hljs-comment">// 取消或者处理，都需要移除key</span><br>iterator.<span class="hljs-built_in">remove</span>();Copy<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>异常断开</p><ul><li>异常断开时，会抛出IOException异常， 在try-catch的<strong>catch块中捕获异常并调用key的cancel方法即可</strong></li></ul></li></ul><h3 id="消息边界"><a href="#消息边界" class="headerlink" title="消息边界"></a>消息边界</h3><p><strong>不处理消息边界存在的问题</strong></p><p>将缓冲区的大小设置为4个字节，发送2个汉字（你好），通过decode解码并打印时，会出现乱码</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">ByteBuffer buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 解码并打印</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardCharsets</span>.</span><span class="hljs-module"><span class="hljs-identifier">UTF_8</span>.</span></span>decode(buffer));Copy<br>你�<br>��Copy<br></code></pre></div></td></tr></table></figure><p>这是因为UTF-8字符集下，1个汉字占用3个字节，此时缓冲区大小为4个字节，<strong>一次读时间无法处理完通道中的所有数据，所以一共会触发两次读事件</strong>。这就导致 <code>你好</code> 的 <code>好</code> 字被拆分为了前半部分和后半部分发送，解码时就会出现问题</p><p><strong>处理消息边界</strong></p><p>传输的文本可能有以下三种情况</p><ul><li>文本大于缓冲区大小<ul><li>此时需要将缓冲区进行扩容</li></ul></li><li>发生半包现象</li><li>发生粘包现象</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103442.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214750.png" alt="img"></a></p><p>解决思路大致有以下三种</p><ul><li><p><strong>固定消息长度</strong>，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽</p></li><li><p>另一种思路是按分隔符拆分，缺点是效率低，需要一个一个字符地去匹配分隔符</p></li><li><p>TLV 格式，即 Type 类型、Length 长度、Value 数据</p><p>（也就是在消息开头</p><p>用一些空间存放后面数据的长度</p><p>），如HTTP请求头中的Content-Type与</p><p>Content-Length</p><p>。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量</p><ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103926.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214754.png" alt="img"></a></li></ul></li></ul><p>下文的消息边界处理方式为<strong>第二种：按分隔符拆分</strong></p><p><strong>附件与扩容</strong></p><p>Channel的register方法还有<strong>第三个参数</strong>：<code>附件</code>，可以向其中放入一个Object类型的对象，该对象会与登记的Channel以及其对应的SelectionKey绑定，可以从SelectionKey获取到对应通道的附件</p><figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> SelectionKey <span class="hljs-keyword">register</span>(<span class="hljs-keyword">Selector</span> sel, int ops, Object att)<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><p>可通过SelectionKey的<strong>attachment()方法获得附件</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ByteBuffer </span><span class="hljs-keyword">buffer </span>= (<span class="hljs-keyword">ByteBuffer) </span>key.attachment()<span class="hljs-comment">;Copy</span><br></code></pre></div></td></tr></table></figure><p>我们需要在Accept事件发生后，将通道注册到Selector中时，<strong>对每个通道添加一个ByteBuffer附件</strong>，让每个通道发生读事件时都使用自己的通道，避免与其他通道发生冲突而导致问题</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件</span><br>socketChannel.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 添加通道对应的Buffer附件</span><br>socketChannel.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(selector, SelectionKey.OP_READ, buffer);Copy<br></code></pre></div></td></tr></table></figure><p>当Channel中的数据大于缓冲区时，需要对缓冲区进行<strong>扩容</strong>操作。此代码中的扩容的判定方法：<strong>Channel调用compact方法后，的position与limit相等，说明缓冲区中的数据并未被读取（容量太小），此时创建新的缓冲区，其大小扩大为两倍。同时还要将旧缓冲区中的数据拷贝到新的缓冲区中，同时调用SelectionKey的attach方法将新的缓冲区作为新的附件放入SelectionKey中</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">// 如果缓冲区太小，就进行扩容</span><br><span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">position</span>() == buffer.<span class="hljs-built_in">limit</span>()) &#123;<br>    ByteBuffer newBuffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(buffer.<span class="hljs-built_in">capacity</span>()*<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 将旧buffer中的内容放入新的buffer中</span><br>    ewBuffer.<span class="hljs-built_in">put</span>(buffer);<br>    <span class="hljs-comment">// 将新buffer作为附件放到key中</span><br>    key.<span class="hljs-built_in">attach</span>(newBuffer);<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><p><strong>改造后的服务器代码如下</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectServer</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 获得服务器通道</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span>(ServerSocketChannel server = ServerSocketChannel.<span class="hljs-built_in">open</span>()) &#123;<br>            server.<span class="hljs-built_in">bind</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 创建选择器</span><br>            Selector selector = Selector.<span class="hljs-built_in">open</span>();<br>            <span class="hljs-comment">// 通道必须设置为非阻塞模式</span><br>            server.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>            <span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的事件</span><br>            server.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-comment">// 为serverKey设置感兴趣的事件</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span><br>                <span class="hljs-comment">// 返回值为就绪的事件个数</span><br>                <span class="hljs-keyword">int</span> ready = selector.<span class="hljs-built_in">select</span>();<br>                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;selector ready counts : &quot;</span> + ready);<br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; selectionKeys = selector.<span class="hljs-built_in">selectedKeys</span>();<br>                <span class="hljs-comment">// 使用迭代器遍历事件</span><br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.<span class="hljs-built_in">iterator</span>();<br>                <span class="hljs-keyword">while</span> (iterator.<span class="hljs-built_in">hasNext</span>()) &#123;<br>                    SelectionKey key = iterator.<span class="hljs-built_in">next</span>();<br>                    <span class="hljs-comment">// 判断key的类型</span><br>                    <span class="hljs-keyword">if</span>(key.<span class="hljs-built_in">isAcceptable</span>()) &#123;<br>                        <span class="hljs-comment">// 获得key对应的channel</span><br>                        ServerSocketChannel channel = (ServerSocketChannel) key.<span class="hljs-built_in">channel</span>();<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;before accepting...&quot;</span>);<br>                        <span class="hljs-comment">// 获取连接</span><br>                        SocketChannel socketChannel = channel.<span class="hljs-built_in">accept</span>();<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;after accepting...&quot;</span>);<br>                        <span class="hljs-comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件</span><br>                        socketChannel.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>                        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">16</span>);<br>                        socketChannel.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(selector, SelectionKey.OP_READ, buffer);<br>                        <span class="hljs-comment">// 处理完毕后移除</span><br>                        iterator.<span class="hljs-built_in">remove</span>();<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.<span class="hljs-built_in">isReadable</span>()) &#123;<br>                        SocketChannel channel = (SocketChannel) key.<span class="hljs-built_in">channel</span>();<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;before reading...&quot;</span>);<br>                        <span class="hljs-comment">// 通过key获得附件（buffer）</span><br>                        ByteBuffer buffer = (ByteBuffer) key.<span class="hljs-built_in">attachment</span>();<br>                        <span class="hljs-keyword">int</span> read = channel.<span class="hljs-built_in">read</span>(buffer);<br>                        <span class="hljs-keyword">if</span>(read == <span class="hljs-number">-1</span>) &#123;<br>                            key.<span class="hljs-built_in">cancel</span>();<br>                            channel.<span class="hljs-built_in">close</span>();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// 通过分隔符来分隔buffer中的数据</span><br>                            <span class="hljs-built_in">split</span>(buffer);<br>                            <span class="hljs-comment">// 如果缓冲区太小，就进行扩容</span><br>                            <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">position</span>() == buffer.<span class="hljs-built_in">limit</span>()) &#123;<br>                                ByteBuffer newBuffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(buffer.<span class="hljs-built_in">capacity</span>()*<span class="hljs-number">2</span>);<br>                                <span class="hljs-comment">// 将旧buffer中的内容放入新的buffer中</span><br>                                buffer.<span class="hljs-built_in">flip</span>();<br>                                newBuffer.<span class="hljs-built_in">put</span>(buffer);<br>                                <span class="hljs-comment">// 将新buffer放到key中作为附件</span><br>                                key.<span class="hljs-built_in">attach</span>(newBuffer);<br>                            &#125;<br>                        &#125;<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;after reading...&quot;</span>);<br>                        <span class="hljs-comment">// 处理完毕后移除</span><br>                        iterator.<span class="hljs-built_in">remove</span>();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(ByteBuffer buffer)</span> </span>&#123;<br>        buffer.<span class="hljs-built_in">flip</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.<span class="hljs-built_in">limit</span>(); i++) &#123;<br>            <span class="hljs-comment">// 遍历寻找分隔符</span><br>            <span class="hljs-comment">// get(i)不会移动position</span><br>            <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">get</span>(i) == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 缓冲区长度</span><br>                <span class="hljs-keyword">int</span> length = i+<span class="hljs-number">1</span>-buffer.<span class="hljs-built_in">position</span>();<br>                ByteBuffer target = ByteBuffer.<span class="hljs-built_in">allocate</span>(length);<br>                <span class="hljs-comment">// 将前面的内容写入target缓冲区</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                    <span class="hljs-comment">// 将buffer中的数据写入target中</span><br>                    target.<span class="hljs-built_in">put</span>(buffer.<span class="hljs-built_in">get</span>());<br>                &#125;<br>                <span class="hljs-comment">// 打印结果</span><br>                ByteBufferUtil.<span class="hljs-built_in">debugAll</span>(target);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 切换为写模式，但是缓冲区可能未读完，这里需要使用compact</span><br>        buffer.<span class="hljs-built_in">compact</span>();<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><h3 id="ByteBuffer的大小分配"><a href="#ByteBuffer的大小分配" class="headerlink" title="ByteBuffer的大小分配"></a>ByteBuffer的大小分配</h3><ul><li>每个 channel 都需要记录可能被切分的消息，因为 <strong>ByteBuffer 不能被多个 channel 共同使用</strong>，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer</li><li>分配思路可以参考<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能<ul><li>参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li></ul></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h2 id="6、Write事件"><a href="#6、Write事件" class="headerlink" title="6、Write事件"></a>6、Write事件</h2><p>服务器通过Buffer向通道中写入数据时，<strong>可能因为通道容量小于Buffer中的数据大小，导致无法一次性将Buffer中的数据全部写入到Channel中，这时便需要分多次写入</strong>，具体步骤如下</p><ul><li><p>执行一次写操作，向将buffer中的内容写入到SocketChannel中，然后判断Buffer中是否还有数据</p></li><li><p>若Buffer中还有数据，则<strong>需要将SockerChannel注册到Seletor中，并关注写事件，同时将未写完的Buffer作为附件一起放入到SelectionKey中</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"> <span class="hljs-keyword">int</span> write = socket.<span class="hljs-built_in">write</span>(buffer);<br><span class="hljs-comment">// 通道中可能无法放入缓冲区中的所有数据</span><br><span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>    <span class="hljs-comment">// 注册到Selector中，关注可写事件，并将buffer添加到key的附件中</span><br>    socket.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>    socket.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(selector, SelectionKey.OP_WRITE, buffer);<br>&#125;Copy<br></code></pre></div></td></tr></table></figure></li><li><p>添加写事件的相关操作<code>key.isWritable()</code>，对Buffer再次进行写操作</p><ul><li>每次写后需要判断Buffer中是否还有数据（是否写完）。<strong>若写完，需要移除SelecionKey中的Buffer附件，避免其占用过多内存，同时还需移除对写事件的关注</strong></li></ul><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">SocketChannel socket = (SocketChannel) key.<span class="hljs-built_in">channel</span>();<br><span class="hljs-comment">// 获得buffer</span><br>ByteBuffer buffer = (ByteBuffer) key.<span class="hljs-built_in">attachment</span>();<br><span class="hljs-comment">// 执行写操作</span><br><span class="hljs-keyword">int</span> write = socket.<span class="hljs-built_in">write</span>(buffer);<br>System.out.<span class="hljs-built_in">println</span>(write);<br><span class="hljs-comment">// 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣</span><br><span class="hljs-keyword">if</span> (!buffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>    key.<span class="hljs-built_in">attach</span>(null);<br>    key.<span class="hljs-built_in">interestOps</span>(<span class="hljs-number">0</span>);<br>&#125;Copy<br></code></pre></div></td></tr></table></figure></li></ul><p><strong>整体代码如下</strong></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteServer</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span>(ServerSocketChannel server = ServerSocketChannel.<span class="hljs-built_in">open</span>()) &#123;<br>            server.<span class="hljs-built_in">bind</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            server.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>            Selector selector = Selector.<span class="hljs-built_in">open</span>();<br>            server.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                selector.<span class="hljs-built_in">select</span>();<br>                Set&lt;SelectionKey&gt; selectionKeys = selector.<span class="hljs-built_in">selectedKeys</span>();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.<span class="hljs-built_in">iterator</span>();<br>                <span class="hljs-keyword">while</span> (iterator.<span class="hljs-built_in">hasNext</span>()) &#123;<br>                    SelectionKey key = iterator.<span class="hljs-built_in">next</span>();<br>                    <span class="hljs-comment">// 处理后就移除事件</span><br>                    iterator.<span class="hljs-built_in">remove</span>();<br>                    <span class="hljs-keyword">if</span> (key.<span class="hljs-built_in">isAcceptable</span>()) &#123;<br>                        <span class="hljs-comment">// 获得客户端的通道</span><br>                        SocketChannel socket = server.<span class="hljs-built_in">accept</span>();<br>                        <span class="hljs-comment">// 写入数据</span><br>                        StringBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500000000</span>; i++) &#123;<br>                            builder.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>                        &#125;<br>                        ByteBuffer buffer = StandardCharsets.UTF_8.<span class="hljs-built_in">encode</span>(builder.<span class="hljs-built_in">toString</span>());<br>                        <span class="hljs-comment">// 先执行一次Buffer-&gt;Channel的写入，如果未写完，就添加一个可写事件</span><br>                        <span class="hljs-keyword">int</span> write = socket.<span class="hljs-built_in">write</span>(buffer);<br>                        System.out.<span class="hljs-built_in">println</span>(write);<br>                        <span class="hljs-comment">// 通道中可能无法放入缓冲区中的所有数据</span><br>                        <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>                            <span class="hljs-comment">// 注册到Selector中，关注可写事件，并将buffer添加到key的附件中</span><br>                            socket.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>                            socket.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(selector, SelectionKey.OP_WRITE, buffer);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.<span class="hljs-built_in">isWritable</span>()) &#123;<br>                        SocketChannel socket = (SocketChannel) key.<span class="hljs-built_in">channel</span>();<br>                        <span class="hljs-comment">// 获得buffer</span><br>                        ByteBuffer buffer = (ByteBuffer) key.<span class="hljs-built_in">attachment</span>();<br>                        <span class="hljs-comment">// 执行写操作</span><br>                        <span class="hljs-keyword">int</span> write = socket.<span class="hljs-built_in">write</span>(buffer);<br>                        System.out.<span class="hljs-built_in">println</span>(write);<br>                        <span class="hljs-comment">// 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣</span><br>                        <span class="hljs-keyword">if</span> (!buffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>                            key.<span class="hljs-built_in">attach</span>(null);<br>                            key.<span class="hljs-built_in">interestOps</span>(<span class="hljs-number">0</span>);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><h2 id="7、优化"><a href="#7、优化" class="headerlink" title="7、优化"></a>7、优化</h2><h3 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h3><p>充分利用多核CPU，分两组选择器</p><ul><li>单线程配一个选择器（Boss），<strong>专门处理 accept 事件</strong></li><li>创建 cpu 核心数的线程（Worker），<strong>每个线程配一个选择器，轮流处理 read 事件</strong></li></ul><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li><p>创建<strong>一个</strong>负责处理Accept事件的Boss线程，与<strong>多个</strong>负责处理Read事件的Worker线程</p></li><li><p><strong>Boss线程</strong>执行的操作</p><ul><li><p>接受并处理Accepet事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要<strong>根据标识robin去判断将任务分配给哪个Worker</strong></p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-comment">// 创建固定数量的Worker</span><br>Worker[] workers = <span class="hljs-keyword">new</span> <span class="hljs-type">Worker</span>[<span class="hljs-number">4</span>];<br><span class="hljs-comment">// 用于负载均衡的原子整数</span><br>AtomicInteger robin = <span class="hljs-keyword">new</span> <span class="hljs-type">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 负载均衡，轮询分配Worker</span><br>workers[robin.getAndIncrement()% workers.length].register(socket);Copy<br></code></pre></div></td></tr></table></figure></li><li><p>register(SocketChannel socket)方法会<strong>通过同步队列完成Boss线程与Worker线程之间的通信</strong>，让SocketChannel的注册任务被Worker线程执行。添加任务后需要调用selector.wakeup()来唤醒被阻塞的Selector</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketChannel socket)</span> throws IOException </span>&#123;<br>    <span class="hljs-comment">// 只启动一次</span><br>    <span class="hljs-keyword">if</span> (!started) &#123;<br>       <span class="hljs-comment">// 初始化操作</span><br>    &#125;<br>    <span class="hljs-comment">// 向同步队列中添加SocketChannel的注册事件</span><br>    <span class="hljs-comment">// 在Worker线程中执行注册事件</span><br>    queue.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Runnable</span>() &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(selector, SelectionKey.OP_READ);<br>            &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>                e.<span class="hljs-built_in">printStackTrace</span>();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 唤醒被阻塞的Selector</span><br>    <span class="hljs-comment">// select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark</span><br>    selector.<span class="hljs-built_in">wakeup</span>();<br>&#125;Copy<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p><strong>Worker线程执行</strong>的操作</p><ul><li><strong>从同步队列中获取注册任务，并处理Read事件</strong></li></ul></li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadsServer</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">try</span></span> (ServerSocketChannel server = ServerSocketChannel.<span class="hljs-built_in">open</span>()) &#123;<br>            <span class="hljs-comment">// 当前线程为Boss线程</span><br>            Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;Boss&quot;</span>);<br>            server.<span class="hljs-built_in">bind</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 负责轮询Accept事件的Selector</span><br>            Selector boss = Selector.<span class="hljs-built_in">open</span>();<br>            server.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>            server.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(boss, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-comment">// 创建固定数量的Worker</span><br>            Worker[] workers = <span class="hljs-keyword">new</span> Worker[<span class="hljs-number">4</span>];<br>            <span class="hljs-comment">// 用于负载均衡的原子整数</span><br>            AtomicInteger robin = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; workers.length; i++) &#123;<br>                workers[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Worker</span>(<span class="hljs-string">&quot;worker-&quot;</span>+i);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                boss.<span class="hljs-built_in">select</span>();<br>                Set&lt;SelectionKey&gt; selectionKeys = boss.<span class="hljs-built_in">selectedKeys</span>();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.<span class="hljs-built_in">iterator</span>();<br>                <span class="hljs-keyword">while</span> (iterator.<span class="hljs-built_in">hasNext</span>()) &#123;<br>                    SelectionKey key = iterator.<span class="hljs-built_in">next</span>();<br>                    iterator.<span class="hljs-built_in">remove</span>();<br>                    <span class="hljs-comment">// BossSelector负责Accept事件</span><br>                    <span class="hljs-keyword">if</span> (key.<span class="hljs-built_in">isAcceptable</span>()) &#123;<br>                        <span class="hljs-comment">// 建立连接</span><br>                        SocketChannel socket = server.<span class="hljs-built_in">accept</span>();<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;connected...&quot;</span>);<br>                        socket.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>                        <span class="hljs-comment">// socket注册到Worker的Selector中</span><br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;before read...&quot;</span>);<br>                        <span class="hljs-comment">// 负载均衡，轮询分配Worker</span><br>                        workers[robin.<span class="hljs-built_in">getAndIncrement</span>()% workers.length].<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(socket);<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;after read...&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span> &#123;</span><br>        <span class="hljs-keyword">private</span> Thread thread;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Selector selector;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 同步队列，用于Boss线程与Worker线程之间的通信</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketChannel socket)</span> throws IOException </span>&#123;<br>            <span class="hljs-comment">// 只启动一次</span><br>            <span class="hljs-keyword">if</span> (!started) &#123;<br>                thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(<span class="hljs-keyword">this</span>, name);<br>                selector = Selector.<span class="hljs-built_in">open</span>();<br>                queue = <span class="hljs-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();<br>                thread.<span class="hljs-built_in">start</span>();<br>                started = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 向同步队列中添加SocketChannel的注册事件</span><br>            <span class="hljs-comment">// 在Worker线程中执行注册事件</span><br>            queue.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Runnable</span>() &#123;<br>                @Override<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        socket.<span class="hljs-built_in"><span class="hljs-keyword">register</span></span>(selector, SelectionKey.OP_READ);<br>                    &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>                        e.<span class="hljs-built_in">printStackTrace</span>();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">// 唤醒被阻塞的Selector</span><br>            <span class="hljs-comment">// select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark</span><br>            selector.<span class="hljs-built_in">wakeup</span>();<br>        &#125;<br><br>        @<span class="hljs-function">Override</span><br><span class="hljs-function">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    selector.<span class="hljs-built_in">select</span>();<br>                    <span class="hljs-comment">// 通过同步队列获得任务并运行</span><br>                    Runnable task = queue.<span class="hljs-built_in">poll</span>();<br>                    <span class="hljs-keyword">if</span> (task != null) &#123;<br>                        <span class="hljs-comment">// 获得任务，执行注册操作</span><br>                        task.<span class="hljs-built_in">run</span>();<br>                    &#125;<br>                    Set&lt;SelectionKey&gt; selectionKeys = selector.<span class="hljs-built_in">selectedKeys</span>();<br>                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.<span class="hljs-built_in">iterator</span>();<br>                    <span class="hljs-keyword">while</span>(iterator.<span class="hljs-built_in">hasNext</span>()) &#123;<br>                        SelectionKey key = iterator.<span class="hljs-built_in">next</span>();<br>                        iterator.<span class="hljs-built_in">remove</span>();<br>                        <span class="hljs-comment">// Worker只负责Read事件</span><br>                        <span class="hljs-keyword">if</span> (key.<span class="hljs-built_in">isReadable</span>()) &#123;<br>                            <span class="hljs-comment">// 简化处理，省略细节</span><br>                            SocketChannel socket = (SocketChannel) key.<span class="hljs-built_in">channel</span>();<br>                            ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">16</span>);<br>                            socket.<span class="hljs-built_in">read</span>(buffer);<br>                            buffer.<span class="hljs-built_in">flip</span>();<br>                            ByteBufferUtil.<span class="hljs-built_in">debugAll</span>(buffer);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (IOException e) &#123;<br>                    e.<span class="hljs-built_in">printStackTrace</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></div></td></tr></table></figure><h1 id="四、NIO与BIO"><a href="#四、NIO与BIO" class="headerlink" title="四、NIO与BIO"></a>四、NIO与BIO</h1><h2 id="1、Stream与Channel"><a href="#1、Stream与Channel" class="headerlink" title="1、Stream与Channel"></a>1、Stream与Channel</h2><ul><li><p>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</p></li><li><p>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，<strong>网络 channel 可配合 selector 实现多路复用</strong></p></li><li><p>二者</p><p>均为全双工</p><p>，即读写可以同时进行</p><ul><li>虽然Stream是单向流动的，但是它也是全双工的</li></ul></li></ul><h2 id="2、IO模型"><a href="#2、IO模型" class="headerlink" title="2、IO模型"></a>2、IO模型</h2><ul><li><p>同步</p><p>：线程自己去获取结果（一个线程）</p><ul><li>例如：线程调用一个方法后，需要等待方法返回结果</li></ul></li><li><p>异步</p><p>：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）</p><ul><li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li></ul></li></ul><p>当调用一次 channel.<strong>read</strong> 或 stream.<strong>read</strong> 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p><ul><li><p>等待数据阶段</p></li><li><p>复制数据阶段</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214806.png" alt="img"></a></p></li></ul><p>根据UNIX 网络编程 - 卷 I，IO模型主要有以下几种</p><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214809.png" alt="img"></a></p><ul><li>用户线程进行read操作时，<strong>需要等待操作系统执行实际的read操作</strong>，此期间用户线程是被阻塞的，无法执行其他操作</li></ul><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214813.png" alt="img"></a></p><ul><li><p>用户线程</p><p>在一个循环中一直调用read方法</p><p>，若内核空间中还没有数据可读，立即返回</p><ul><li><strong>只是在等待阶段非阻塞</strong></li></ul></li><li><p>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</p></li></ul><h3 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214818.png" alt="img"></a></p><p><strong>Java中通过Selector实现多路复用</strong></p><ul><li>当没有事件是，调用select方法会被阻塞住</li><li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li></ul><p><strong>多路复用与阻塞IO的区别</strong></p><ul><li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li><li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li></ul><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214822.png" alt="img"></a></p><ul><li>线程1调用方法后理解返回，<strong>不会被阻塞也不需要立即获取结果</strong></li><li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li></ul><h2 id="3、零拷贝"><a href="#3、零拷贝" class="headerlink" title="3、零拷贝"></a>3、零拷贝</h2><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存中</strong>，同时具有以下三个优点</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h3><p>传统的 IO 将一个文件通过 socket 写出</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle"><span class="hljs-keyword">File</span> f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br>RandomAccessFile <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-keyword">file</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)f.length()];<br><span class="hljs-keyword">file</span>.<span class="hljs-keyword">read</span>(buf);<br><br>Socket socket = ...;<br>socket.getOutputStream().<span class="hljs-keyword">write</span>(buf);<span class="hljs-keyword">Copy</span><br></code></pre></div></td></tr></table></figure><p><strong>内部工作流如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214827.png" alt="img"></a></p><ul><li><p>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的<strong>用户态切换至内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU</p><p><code>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</code></p></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 <strong>CPU 会参与拷贝</strong>，无法利用 DMA</p></li><li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区，CPU 会参与拷贝</strong></p></li><li><p>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</p></li></ul><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h3 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h3><p>通过 <strong>DirectByteBuf</strong></p><ul><li>ByteBuffer.allocate(10)<ul><li>底层对应 HeapByteBuffer，使用的还是 Java 内存</li></ul></li><li>ByteBuffer.allocateDirect(10)<ul><li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214831.png" alt="img"></a></p><p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p><ul><li>这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列<ul><li>当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存 </li><li>DirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法</li></ul></li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></li></ul><h3 id="进一步优化1"><a href="#进一步优化1" class="headerlink" title="进一步优化1"></a>进一步优化1</h3><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p><p>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo/transferFrom</strong> 方法拷贝数据</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214848.png" alt="img"></a></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p>这种方法下</p><ul><li>只发生了1次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><h3 id="进一步优化2"><a href="#进一步优化2" class="headerlink" title="进一步优化2"></a>进一步优化2</h3><p><strong>linux 2.4</strong> 对上述方法再次进行了优化</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png"><img src="https://gitee.com/accept_one_time/pic-bed/raw/master/img/20220127214939.png" alt="img"></a></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p><strong>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</strong></p><h2 id="4、AIO"><a href="#4、AIO" class="headerlink" title="4、AIO"></a>4、AIO</h2><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP <strong>实现了真正的异步 IO</strong></li><li>Linux 系统异步 IO 在 2.6 版本引入，但其<strong>底层实现还是用多路复用模拟了异步 IO，性能没有优势</strong></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/01/27/hello-world/"/>
    <url>/2022/01/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><div class="note note-success">            <p>Tag test</p>          </div><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
